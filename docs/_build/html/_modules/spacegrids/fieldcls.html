<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>spacegrids.fieldcls &mdash; spacegrids  documentation</title>
    
    <link rel="stylesheet" href="../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="top" title="spacegrids  documentation" href="../../index.html" />
    <link rel="up" title="Module code" href="../index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../index.html">spacegrids  documentation</a> &raquo;</li>
          <li><a href="../index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for spacegrids.fieldcls</h1><div class="highlight"><pre>
<span class="c">#encoding:utf-8</span>

<span class="sd">&quot;&quot;&quot;Field and Gr objects represent data defined on grids and reflecting Netcdf data: Coord, Gr, Ax, AxGr and Field.</span>

<span class="sd">Gr (grid) objects are constructed from Coord (coordinate) objects as tuples and Membered methods. Similarly, AxGr (axis grid) objects are constructed from Ax (axis, e.g. X or Y) objects. Field objects contain a grid (a Gr object) attribute and a ndarray value attribute of data defined on that grid. Vfield objects (vector fields) are tuples of Field objects with Membered methods.</span>

<span class="sd">The fieldcls module contains the following classes:</span>

<span class="sd">Coord</span>
<span class="sd">-----</span>

<span class="sd">Represents distrete coordinate collection in a direction (e.g. 10m depth, 20m depth,...). Corresponds to dimension variable in Netcdf.</span>

<span class="sd">Gr</span>
<span class="sd">--</span>

<span class="sd">Represents Coord grids. Consists of a tuple of Coord objects, with additional Membered and other methods.</span>

<span class="sd">Ax</span>
<span class="sd">--</span>

<span class="sd">Axis. Represents direction: e.g. the longitudinal direction, X, or the vertical, Z. Coord objects have an attribute that points to an Ax object, representing its direction.</span>

<span class="sd">AxGr</span>
<span class="sd">----</span>

<span class="sd">Same as Gr, but containing Ax objects instead of Coord. Difference is mainly in the multiplication methods.</span>

<span class="sd">Field</span>
<span class="sd">-----</span>

<span class="sd">Represents a dataset defined on a grid.</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">numpy.ma</span> <span class="kn">as</span> <span class="nn">ma</span>
<span class="kn">from</span> <span class="nn">scipy.interpolate</span> <span class="kn">import</span> <span class="n">griddata</span>

<span class="kn">import</span> <span class="nn">inspect</span>
<span class="kn">import</span> <span class="nn">datetime</span>
<span class="kn">import</span> <span class="nn">glob</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">from</span> <span class="nn">_config</span> <span class="kn">import</span> <span class="o">*</span>

<span class="kn">import</span> <span class="nn">os</span>

<span class="kn">from</span> <span class="nn">decorators</span> <span class="kn">import</span> <span class="n">method2members</span><span class="p">,</span> <span class="n">att2members</span>

<span class="c">#from spacegrids.decorators import _field2cumsum</span>

<span class="kn">from</span> <span class="nn">utilsg</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">_iosg</span> <span class="kn">import</span> <span class="o">*</span>

<span class="kn">from</span> <span class="nn">abstract</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">warnings</span><span class="o">.</span><span class="n">formatwarning</span> <span class="o">=</span> <span class="n">warning_on_one_line</span>


<span class="c"># ---- decorators ------</span>

<span class="k">def</span> <span class="nf">_field2cumsum</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Decorator to dispatch argument to other methods depending on argument.</span>

<span class="sd">  Args:</span>
<span class="sd">    func: function.</span>

<span class="sd">  Returns:</span>
<span class="sd">    Function: the decorator.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  
  <span class="k">def</span> <span class="nf">dispatcher</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Decorator function. Expect args rather than kwargs. </span>

<span class="sd">    args will (calling object, other, some_more_args_maybe)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">caller</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">other</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
      

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">Field</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">VField</span><span class="p">):</span>
      <span class="k">return</span> <span class="n">other</span><span class="o">.</span><span class="n">vcumsum</span><span class="p">(</span><span class="n">coord</span> <span class="o">=</span> <span class="n">caller</span><span class="p">)</span>

    <span class="c"># otherwise go about normal business:</span>
    <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span> <span class="p">)</span>

  <span class="k">return</span> <span class="n">dispatcher</span>





<span class="c"># -------- Coord  ----------------</span>

<div class="viewcode-block" id="Coord"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Coord">[docs]</a><span class="k">class</span> <span class="nc">Coord</span><span class="p">(</span><span class="n">Directional</span><span class="p">,</span> <span class="n">Valued</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Represents distrete coordinate collection in a direction (e.g. 10m depth, 20m depth,...). Corresponds to dimension variable in Netcdf.</span>

<span class="sd">  Coord objects are defined by a name, value (generally a numpy array) and units. The value of a Coord is a 1D ndarray containing the locations of data points. Coord is the basic building block of Gr (grid) objects.</span>
<span class="sd">  Examples of Coord objects are xt or yt, corresponding to the tracer grid cells in the x and y directions. Coord objects have a corresponding dual. For xt it is xt_edges and vice versa. The dual generally contains the edges of the grid cells. If no dual argument is given, the Coord object is its own dual.</span>

<span class="sd">  Coord objects c1 and c2 are considered weakly the same, c1.weaksame(c2) yields True, when the name, value (numpy array) and units attributes are equal.</span>

<span class="sd">  Being a container of Coord objects, the Gr object (grid) is closely related to Coord. A shorthand for Gr construction is via multiplication of Coord objects. If two Coord objects coord1 and coord2 are not equivalent (generally when they point in different directions, e.g. X and Y), their product is a shorthand for the creation of a 2D grid coord1*coord2 = Gr((coord1, coord2)). By induction, products containing n elements yield Gr objects of dimension &lt;=n. See class documentation.</span>

<span class="sd">  An abstract equivalence relationship is inherited from the Directional classs where two objects are equivalent when they have the same &#39;associative&#39; attribute (pointing to an Associative object). This relationship is generally used to indicate whether two Directional objects have the same direction (e.g. X,Y), but could represent other relationships depending on the user.</span>


<span class="sd">  The Coord class contains methods related to distances, with the following dependencies. dist is fundamental. delta_dist depends on dist. der depends on dist. d depends on dual Coord and delta_dist. vol depends on d.</span>


<span class="sd">  Attributes:</span>
<span class="sd">    axis: (Ax) axis along which Coord is defined.</span>
<span class="sd">    dual: (Coord) link to other Coord object, usually representing edges of cells.</span>
<span class="sd">    direction: (str) name of direction in which Coord is defined.</span>
<span class="sd">    equivs: (list of Coords) list of links to equivalent Coord objects. Usually coincides with all Coord&#39;s defined in same direction.</span>
<span class="sd">    len: (int) length of the value attribute (ndarray)</span>
<span class="sd">    long_name: (str) a longer description. Usually taken from identically named variable in Netcdf file.</span>
<span class="sd">    metadata: (dict) name vs value dict of metadata to save into Netcdf. Usually obtained from Netcdf read.</span>
<span class="sd">    name: (str) name of object (e.g. &#39;xt&#39; or &#39;depth&#39;).</span>
<span class="sd">    nbytes: (int) approximate memory usage of Coord object.</span>
<span class="sd">    strings: (list of strings or None) str labels for coord points. If not None, needs to be of same length as value</span>
<span class="sd">    units: (str) units (e.g. &quot;meter&quot;)</span>
<span class="sd">    value: (Numpy ndarray) 1D array corresponding to spatial points (e.g. 10 degrees S for a point).</span>

<span class="sd">  Examples:    </span>
<span class="sd">    &gt;&gt;&gt; coord1 = sg.fieldcls.Coord(name = &#39;test1&#39;,value =np.array([1.,2.,3.]) ,axis =sg.fieldcls.Ax(&#39;X&#39;),direction =&#39;X&#39;, metadata = {&#39;hi&#39;:5} )</span>
<span class="sd">    &gt;&gt;&gt; coord2 = sg.fieldcls.Coord(name = &#39;test2&#39;,value =np.array([1.,2.,3.,4.]),axis =sg.fieldcls.Ax(&#39;Y&#39;),direction =&#39;Y&#39;, metadata = {&#39;hi&#39;:7})</span>
<span class="sd">    &gt;&gt;&gt; coord3 = sg.fieldcls.Coord(name = &#39;test3&#39;,value =np.array([1.5,2.5,3.5,4.5]),axis =sg.fieldcls.Ax(&#39;X&#39;),direction =&#39;X&#39;, metadata = {&#39;hi&#39;:7})</span>
<span class="sd">  &quot;&quot;&quot;</span>


<div class="viewcode-block" id="Coord.same"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Coord.same">[docs]</a>  <span class="k">def</span> <span class="nf">same</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Coord method to check whether this Coord has identical main attributes (except units) to argument other Coord.</span>

<span class="sd">    The axis attributes may sometimes be a str. In this case, == is applied and a warning is issued.</span>

<span class="sd">    Args:</span>
<span class="sd">      other: (Coord) Coord to check against</span>

<span class="sd">    Returns:</span>
<span class="sd">      True/ False</span>

<span class="sd">    Attributes checked:</span>
<span class="sd">      value: via Coord array_equal method</span>
<span class="sd">      name: via str ==</span>
<span class="sd">      axis: same method if Ax object, str == otherwise (axis attribute can sometimes str by choice, although this is not great)</span>
<span class="sd">      direction: via str == method</span>

<span class="sd">    See also:</span>
<span class="sd">      samein method</span>
<span class="sd">      same_index method</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c"># not checking for units</span>

    <span class="c"># the following test and warning is to do with little things that we don&#39;t want to trip over with errors:</span>
    <span class="c"># self is a Coord, so it has an axis attribute (this should be put into the specs!), but other might not:</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="s">&#39;axis&#39;</span><span class="p">):</span>
      <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;Coords method </span><span class="si">%s</span><span class="s">.same(</span><span class="si">%s</span><span class="s">) on argument without Ax attribute.&#39;</span><span class="o">%</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>      
     
    <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">,</span><span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">,</span><span class="nb">unicode</span><span class="p">))</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">axis</span><span class="p">,</span><span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">axis</span><span class="p">,</span><span class="nb">unicode</span><span class="p">)):</span>
      <span class="c"># Both of the axis attributes are a str. Comparing apples with apples.</span>

      <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&#39;Coords </span><span class="si">%s</span><span class="s">, </span><span class="si">%s</span><span class="s"> have str axis attribute </span><span class="si">%s</span><span class="s">, </span><span class="si">%s</span><span class="s">&#39;</span><span class="o">%</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">name</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">axis</span><span class="p">))</span>

      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">name</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axis</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">axis</span> <span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">direction</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">direction</span>  <span class="p">)</span>

    <span class="k">elif</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">,</span><span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">,</span><span class="nb">unicode</span><span class="p">))</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">axis</span><span class="p">,</span><span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">axis</span><span class="p">,</span><span class="nb">unicode</span><span class="p">)):</span>
      <span class="c"># only one of the axis attributes is a str. The other would be an Ax. Apples and oranges: tricky, but should be uncommon.</span>

      <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&#39;!! One of Coords </span><span class="si">%s</span><span class="s">, </span><span class="si">%s</span><span class="s"> has str axis, not the other! Proceeding using str compare. (</span><span class="si">%s</span><span class="s">, </span><span class="si">%s</span><span class="s">)&#39;</span><span class="o">%</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">name</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">axis</span><span class="p">))</span>


      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">name</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">)</span> <span class="o">==</span> <span class="nb">str</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">axis</span><span class="p">)</span> <span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">direction</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">direction</span>  <span class="p">)</span>


    <span class="k">else</span><span class="p">:</span>
      <span class="c"># Both of the axis attributes are an Ax. Comparing apples with apples. Best case of 3.</span>
      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">name</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="o">.</span><span class="n">same</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">axis</span><span class="p">)</span> <span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">direction</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">direction</span>  <span class="p">)</span>

</div>
<div class="viewcode-block" id="Coord.weaksame"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Coord.weaksame">[docs]</a>  <span class="k">def</span> <span class="nf">weaksame</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Tests whether Coord objects contain identical Coord values, name and direction. </span>

<span class="sd">    Overrides Directional weaksame method and is a stronger condition.</span>

<span class="sd">    Args:</span>
<span class="sd">      other: (Coord) object to compare against.</span>

<span class="sd">    Returns: </span>
<span class="sd">      True/ False</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c"># the following test and warning is to do with little things that we don&#39;t want to trip over with errors:</span>
    <span class="c"># self is a Coord, so it has a value attribute (this should be put into the specs!), but other might not:</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="s">&#39;value&#39;</span><span class="p">):</span>
      <span class="c"># raising might be a bit harsh here...</span>
      <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;Coords method </span><span class="si">%s</span><span class="s">.weaksame(</span><span class="si">%s</span><span class="s">) on argument without value attribute: returning False.&#39;</span><span class="o">%</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>      
      

    <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">name</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">direction</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">direction</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> 




    </div>
<div class="viewcode-block" id="Coord.sort"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Coord.sort">[docs]</a>  <span class="k">def</span> <span class="nf">sort</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Sorts Coord value. Passes arguments on to Numpy sort method.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

</div>
  <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;scalar&#39;</span><span class="p">,</span><span class="n">value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">]),</span> <span class="n">dual</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span><span class="n">axis</span> <span class="o">=</span> <span class="s">&#39;?&#39;</span><span class="p">,</span><span class="n">direction</span> <span class="o">=</span><span class="s">&#39;scalar&#39;</span><span class="p">,</span> <span class="n">units</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span><span class="n">long_name</span> <span class="o">=</span><span class="s">&#39;?&#39;</span><span class="p">,</span> <span class="n">metadata</span> <span class="o">=</span> <span class="p">{}</span> <span class="p">,</span> <span class="n">strings</span> <span class="o">=</span> <span class="bp">None</span> <span class="p">,</span> <span class="n">associative</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>  
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Initialisation of Coord object. </span>

<span class="sd">    If argument dual is provided, the dual attribute of that Coord object is also set to self (the Coord objects become each other&#39;s dual).</span>

<span class="sd">    Args:</span>
<span class="sd">      name: (str) name of object (e.g. &#39;xt&#39; or &#39;depth&#39;).</span>
<span class="sd">      value: (Numpy ndarray) 1D array corresponding to spatial points (e.g. 10 degrees S for a point).</span>
<span class="sd">      dual: (Coord) link to other Coord object, usually representing edges of cells.</span>
<span class="sd">      axis: (Ax) axis along which Coord is defined.</span>
<span class="sd">      direction: (str) name of direction in which Coord is defined.</span>
<span class="sd">      units: (str) units (e.g. &quot;meter&quot;)</span>
<span class="sd">      long_name: (str) a longer description. Usually taken from identically named variable in Netcdf file.</span>
<span class="sd">      metadata: (dict) name vs value dict of metadata to save into Netcdf. Usually obtained from Netcdf read.</span>
<span class="sd">      strings: (list of strings or None) str labels for coord points. If not None, needs to be of same length as value</span>
<span class="sd">      associative: (Coord) object that this object is equivalent to (same direction)</span>

<span class="sd">    Raises:</span>
<span class="sd">      ValueError: if argument strings is not None and if len(strings) != len(value) or when associative has no associative attribute</span>
<span class="sd">    &quot;&quot;&quot;</span>
  
<span class="c"># choosing the name ID creates an identity object. ID*b = b for all Coord elements b.</span>
<span class="c"># could implement the identity Field in __call__</span>

<span class="c"># Metric could be a class. Objects of this class could be constructed by a method of the Coord class (Coord objects then spawn metric objects).</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">equivs</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="p">]</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">axis</span> <span class="o">=</span> <span class="n">axis</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">units</span> <span class="o">=</span> <span class="n">units</span>
 
    <span class="bp">self</span><span class="o">.</span><span class="n">direction</span> <span class="o">=</span> <span class="n">direction</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">long_name</span> <span class="o">=</span> <span class="n">long_name</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">fld</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span> <span class="o">=</span> <span class="n">metadata</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">nbytes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">nbytes</span>

    <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">axis</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">Ax</span><span class="p">)</span>  <span class="p">:</span>
      <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">equivs</span><span class="p">)</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">strings</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
      <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">strings</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Provide strings argument of equal length to value argument for Coord </span><span class="si">%s</span><span class="s"> if providing strings argument. </span><span class="si">%s</span><span class="s"> vs </span><span class="si">%s</span><span class="s">&#39;</span><span class="o">%</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">strings</span><span class="p">)))</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">strings</span> <span class="o">=</span> <span class="n">strings</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">give_dual</span><span class="p">(</span><span class="n">dual</span><span class="p">)</span>
 

    <span class="k">if</span> <span class="n">associative</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">associative</span> <span class="o">=</span> <span class="n">Associative</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="o">+</span><span class="s">&#39;_assoc&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">associative</span><span class="p">,</span> <span class="s">&#39;associative&#39;</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">associative</span> <span class="o">=</span> <span class="n">associative</span><span class="o">.</span><span class="n">associative</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;provide object with associative attribute for associative.&#39;</span><span class="p">)</span>



  <span class="k">def</span> <span class="nf">_copy_cleanup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="o">**</span><span class="n">new_kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    When a Coord is copied and is self-dual, the new copy must be dual to itself, not the original calling Coord that is being copied. </span>

<span class="sd">    This method is called by the copy method of the parent class. If this method were not called, the copy of a self-dual Coord would be dual to its original calling Coord rather than itself.</span>

<span class="sd">    Note that this method works only on self-dual coords: copies of other-dual Coord objects remain dual to that existing dual Coord.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="s">&#39;dual&#39;</span> <span class="ow">in</span> <span class="n">new_kwargs</span><span class="p">:</span>

      <span class="k">if</span> <span class="n">new_kwargs</span><span class="p">[</span><span class="s">&#39;dual&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">self</span><span class="p">:</span>
        <span class="n">new_kwargs</span><span class="p">[</span><span class="s">&#39;dual&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="k">return</span> <span class="n">new_kwargs</span>

<div class="viewcode-block" id="Coord.give_axis"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Coord.give_axis">[docs]</a>  <span class="k">def</span> <span class="nf">give_axis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Give axis attribute value and set equivalence to axis.</span>

<span class="sd">    Args:</span>
<span class="sd">      axis: (Ax) the axis to provide</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">axis</span> <span class="o">=</span> <span class="n">axis</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">make_equiv</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="Coord.give_dual"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Coord.give_dual">[docs]</a>  <span class="k">def</span> <span class="nf">give_dual</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">dual</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Provide Coord with dual Coord (e.g. latitude vs latitude_edges). </span>

<span class="sd">    If Coord is provided, dual attribute will be set to that Coord and vice versa. Called upon initialization, and therefore by copy method.</span>

<span class="sd">    Args:</span>
<span class="sd">      dual: (Coord or None) Coord to make dual </span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">dual</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">dual</span> <span class="o">=</span> <span class="bp">self</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">dual</span> <span class="o">=</span><span class="n">dual</span>
      <span class="n">dual</span><span class="o">.</span><span class="n">dual</span> <span class="o">=</span> <span class="bp">self</span>


</div>
<div class="viewcode-block" id="Coord.sliced"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Coord.sliced">[docs]</a>  <span class="k">def</span> <span class="nf">sliced</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">slice_obj</span> <span class="o">=</span> <span class="bp">None</span> <span class="p">,</span><span class="n">suffix</span> <span class="o">=</span> <span class="s">&#39;_sliced&#39;</span><span class="p">,</span> <span class="n">slice_dual</span> <span class="o">=</span> <span class="bp">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Create new sliced Coord and dual with sliced value.</span>

<span class="sd">    Also slices &#39;strings&#39; attribute if set.</span>

<span class="sd">    Sliced Coord object and possible dual are not registered with cstack. The sliced dual Coord can be accessed via the sliced Coord.</span>

<span class="sd">    Args:</span>
<span class="sd">      slice_obj: (slice object) to slice value with</span>
<span class="sd">      suffix: (str) suffix to use for sliced Coord </span>
<span class="sd">      slice_dual: (Boolean) determines whether dual Coord is sliced too</span>

<span class="sd">    Returns:</span>
<span class="sd">      Coord object containing sliced value, or self if slice(None,None,None)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">slice_obj</span> <span class="o">==</span> <span class="nb">slice</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span><span class="bp">None</span><span class="p">,</span><span class="bp">None</span><span class="p">):</span>
      <span class="k">return</span> <span class="bp">self</span>

    <span class="c"># Keeping the int argument results in a float value attribute to the new Coord, so we make it a slice object instead:</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">slice_obj</span><span class="p">,</span><span class="nb">int</span><span class="p">):</span>
      <span class="n">slice_obj</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">slice_obj</span><span class="p">,</span> <span class="n">slice_obj</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="bp">None</span><span class="p">)</span>

    <span class="n">new_name</span> <span class="o">=</span> <span class="n">affix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">suffix</span><span class="p">)</span>
    <span class="n">new_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="n">slice_obj</span><span class="p">]</span>

    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">strings</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
      <span class="n">new_strings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">strings</span><span class="p">[</span><span class="n">slice_obj</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">new_strings</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="n">new_coord</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">name</span> <span class="o">=</span> <span class="n">new_name</span> <span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="n">new_value</span><span class="p">,</span> <span class="n">strings</span> <span class="o">=</span> <span class="n">new_strings</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">slice_dual</span><span class="p">:</span>
      <span class="c"># also slice the dual (edges) Coord and assign to new Coord.</span>
      <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dual</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">self</span><span class="p">:</span>
        <span class="c"># create new dual coord</span>

        <span class="n">new_stop</span> <span class="o">=</span> <span class="n">slice_obj</span><span class="o">.</span><span class="n">stop</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dual</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">new_stop</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">):</span>
          <span class="n">new_stop</span> <span class="o">+=</span> <span class="mi">1</span>
          <span class="n">new_slice_obj</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">slice_obj</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">new_stop</span><span class="p">,</span> <span class="n">slice_obj</span><span class="o">.</span><span class="n">step</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="n">new_slice_obj</span> <span class="o">=</span> <span class="n">slice_obj</span>
          
        <span class="n">new_dual</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dual</span><span class="o">.</span><span class="n">sliced</span><span class="p">(</span><span class="n">slice_obj</span> <span class="o">=</span> <span class="n">new_slice_obj</span> <span class="p">,</span><span class="n">suffix</span> <span class="o">=</span> <span class="n">suffix</span><span class="p">,</span> <span class="n">slice_dual</span> <span class="o">=</span> <span class="bp">False</span><span class="p">)</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="c"># give_dual will make the new_coord self-dual</span>
        <span class="n">new_dual</span> <span class="o">=</span> <span class="bp">None</span>

      <span class="n">new_coord</span><span class="o">.</span><span class="n">give_dual</span><span class="p">(</span><span class="n">new_dual</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">new_coord</span>


</div>
  <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Obtain length of value attribute (1D ndarray)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">len</span>

<span class="c"># belongs to Coord </span>
  <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Shorthand for cast. See cast method.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">other</span><span class="o">=</span><span class="n">other</span><span class="p">,</span> <span class="n">index</span> <span class="o">=</span> <span class="n">index</span><span class="p">)</span>

<div class="viewcode-block" id="Coord.cast"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Coord.cast">[docs]</a>  <span class="k">def</span> <span class="nf">cast</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Broadcasts Coord onto grid.</span>

<span class="sd">    Calling a Coord object with a grid Gr object as argument yields an array with the coord values broadcast onto that grid.</span>

<span class="sd">    In other words, the resulting array A is defined on that grid where A[:,i,...] = self.value[i] for all i. This leads to an expansion of the Coord value useful for grid operations such as interpolation.</span>

<span class="sd">    Args:</span>
<span class="sd">      other: (Gr, Field, None) Gr to broadcast on or Field to slice.</span>
<span class="sd">      index: (int) index at which to take a slice in case of Field argument.</span>

<span class="sd">    Returns:</span>
<span class="sd">       Field with Coord broadcast onto that grid if Coord is in that Gr. If not, None is returned.</span>
<span class="sd">       </span>
<span class="sd">    Examples:</span>
<span class="sd">      &gt;&gt;&gt; R = xt(xt*yt*zt)   # obtain Field R</span>
<span class="sd">      &gt;&gt;&gt; R.shape == (len(xt),len(yt),len(zt))</span>
<span class="sd">      True</span>
<span class="sd">      &gt;&gt;&gt; R.grid</span>
<span class="sd">      (xt, yt, zt)</span>
<span class="sd">      &gt;&gt;&gt; # Here, the value of R is constant in yt and zt, but equal to xt along the xt axis.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<span class="c">#    if not(other) or (other is self):</span>
<span class="c">#      if not(self.fld):</span>
<span class="c">#        self.fld = Field(name = self.name, value = self.value, grid = self**2, units = self.units)</span>
    
<span class="c">#      return self.fld</span>
<span class="c">#    else:</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">Gr</span><span class="p">):</span>
      <span class="k">if</span> <span class="bp">self</span> <span class="ow">in</span> <span class="n">other</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Field</span><span class="p">(</span><span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">**</span><span class="mi">2</span><span class="p">)(</span><span class="n">other</span><span class="p">)(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">),</span> <span class="n">grid</span> <span class="o">=</span> <span class="n">other</span><span class="p">)</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> 
<span class="c">#      elif isinstance(other,Field):</span>
<span class="c">#          return self._bigslice(other,index)</span>


<span class="c"># ----- addition related --------- </span>
</div>
  <span class="k">def</span> <span class="nf">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Refine Coord by combining grid points from both. Only implemented for self-dual Coord objects.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">dual</span> <span class="o">==</span> <span class="bp">self</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">dual</span> <span class="o">==</span> <span class="n">other</span><span class="p">)):</span>

      <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

      <span class="n">result</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">merge</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">,</span><span class="n">other</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
      
      <span class="k">return</span> <span class="n">result</span>

    <span class="k">else</span><span class="p">:</span>

      <span class="k">print</span> <span class="s">&#39;+ only implemented for self-dual Coord objects (e.g. time), returning None.&#39;</span>
      <span class="k">return</span> <span class="bp">None</span>  


      
  <span class="k">def</span> <span class="nf">__neg__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Obtain version of Coord with negative values (e.g. -xt). Includes a negative dual (edges). </span>

<span class="sd">    Returns:</span>
<span class="sd">      Coord copy with value is -self.value</span>

<span class="sd">    The dual is also made negative.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c"># This method needs to override the parent class because dual needs to be handled.</span>

    <span class="n">neg_crd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">value</span> <span class="o">=-</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>

    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dual</span> <span class="ow">is</span> <span class="bp">self</span><span class="p">:</span>
      <span class="n">neg_crd</span><span class="o">.</span><span class="n">give_dual</span><span class="p">()</span>
   
    <span class="k">else</span><span class="p">:</span>
     
      <span class="n">neg_dual</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dual</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">value</span> <span class="o">=-</span><span class="bp">self</span><span class="o">.</span><span class="n">dual</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
      <span class="n">neg_crd</span><span class="o">.</span><span class="n">give_dual</span><span class="p">(</span><span class="n">neg_dual</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">neg_crd</span>


<span class="c"># Belongs to Coord</span>

  <span class="nd">@_field2cumsum</span>
  <span class="k">def</span> <span class="nf">__or__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Shorthand calling make_equiv (to register equivalence with other Directional object). </span>

<span class="sd">    Args:</span>
<span class="sd">      other: (Coord)</span>

<span class="sd">    Returns:</span>
<span class="sd">      None</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">make_equiv</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>



  <span class="k">def</span> <span class="nf">__xor__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Shorthand for several methods depending on argument type. </span>

<span class="sd">    Becomes is_equiv if argument Coord, Gr.eq_in on self if argument is Gr and self.der on argument for Field argument.</span>

<span class="sd">    Args:</span>
<span class="sd">      other: (Coord, Gr or Field)</span>

<span class="sd">    Returns</span>
<span class="sd">      None unless other is Field</span>

<span class="sd">    Raises: TypeError</span>
<span class="sd">    &quot;&quot;&quot;</span>


    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">Coord</span><span class="p">)</span> <span class="o">|</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">Ax</span><span class="p">):</span>
      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_equiv</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
      
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">Gr</span><span class="p">):</span>
      <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">eq_in</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">other</span><span class="p">[</span><span class="n">other</span><span class="o">.</span><span class="n">eq_index</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>  <span class="p">]</span>
      <span class="k">else</span><span class="p">:</span>   
        <span class="k">return</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">Field</span><span class="p">):</span>
      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">der</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;Coord error in </span><span class="si">%s</span><span class="s">^</span><span class="si">%s</span><span class="s"> with Coord </span><span class="si">%s</span><span class="s">. Provide Coord,Gr or Field object for right multiplicant (now </span><span class="si">%s</span><span class="s">).&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">,</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">)</span> <span class="p">)</span>
      <span class="k">return</span>

<div class="viewcode-block" id="Coord.eq_index"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Coord.eq_index">[docs]</a>  <span class="k">def</span> <span class="nf">eq_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">grid</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">grid</span><span class="o">.</span><span class="n">eq_in</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="k">return</span> <span class="n">grid</span><span class="o">.</span><span class="n">eq_index</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>  
    <span class="k">else</span><span class="p">:</span>   
      <span class="k">return</span>




<span class="c"># ----- multiplication related ---------      </span>


<span class="c"># --&gt; belongs to Coord </span></div>
  <span class="k">def</span> <span class="nf">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Multiplication of Coord with Coord, Ax, Gr, (V)Field.</span>
<span class="sd">    </span>
<span class="sd">    A shorthand for grid (Gr object) construction is via multiplication of Coord objects. If two Coord objects coord1 and coord2 are not equivalent (generally when they point in different directions, e.g. X and Y), their product is a shorthand for the creation of a 2D grid coord1*coord2 = Gr((coord1, coord2)). If coord1 and coord2 are equivalent (point in the same direction), coord1*coord2 yields Gr((coord1,)). By induction, products containing n elements yield Gr objects of dimension &lt;=n. See class documentation.</span>

<span class="sd">    In case the right multiplicant (argument) is a (V)Field, the product yields the zonal integral of that (V)Field.</span>

<span class="sd">    Args:</span>
<span class="sd">      other: (Coord, Ax, Gr or (V)Field)</span>

<span class="sd">    Returns</span>
<span class="sd">      Gr if argument Coord/ Gr </span>
<span class="sd">      None, Coord if argument Ax (so that Ax multiplication commutes)</span>
<span class="sd">      (V)Field if argument field (zonal integral)</span>

<span class="sd">    Raises: TypeError    </span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">Coord</span><span class="p">):</span>   
      <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">is_equiv</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Gr</span><span class="p">((</span><span class="bp">self</span><span class="p">,))</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Gr</span><span class="p">((</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">))</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">Ax</span><span class="p">):</span>
      <span class="c"># Ax and Coord objects commute</span>
      <span class="k">return</span> <span class="n">other</span><span class="o">*</span><span class="bp">self</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">Gr</span><span class="p">):</span>   
      <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">eq_in</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">new_other</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
       
        <span class="n">new_other</span><span class="p">[</span><span class="n">other</span><span class="o">.</span><span class="n">eq_index</span><span class="p">(</span><span class="bp">self</span><span class="p">)]</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">return</span> <span class="n">Gr</span><span class="p">(</span><span class="n">new_other</span><span class="p">)</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Gr</span><span class="p">(</span> <span class="p">[</span><span class="bp">self</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">other</span><span class="p">))</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">Field</span><span class="p">):</span>
<span class="c">#        print &#39;Warning (benign): converting left multiplicant to Gr object from Coord object.&#39;</span>
      <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">other</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">VField</span><span class="p">):</span>
       <span class="c"># case whether vector Field is multiplied by Coord (yielding vsum).</span>
       <span class="c"># this commutes:</span>
       <span class="k">return</span> <span class="n">other</span><span class="o">*</span><span class="bp">self</span>

    <span class="k">else</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;Coord error in </span><span class="si">%s</span><span class="s">*</span><span class="si">%s</span><span class="s"> with Coord </span><span class="si">%s</span><span class="s">: provide Coord, Gr or Field object as right multiplicant (now </span><span class="si">%s</span><span class="s">). If multiplicant appears to be a Coord of other multiplicant Field, check whether its definition is stale (reloaded sg since its creation). &#39;</span><span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">,</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">)</span> <span class="p">)</span>




<div class="viewcode-block" id="Coord.start_zero"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Coord.start_zero">[docs]</a>  <span class="k">def</span> <span class="nf">start_zero</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a copy of this Coord where the coordinate values start at 0.</span>

<span class="sd">    This is achieved by subtraction of self.value[0] from self.value</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s">&#39;_zero&#39;</span>  <span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
 </div>
  <span class="k">def</span> <span class="nf">_cdf_insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">file_handle</span><span class="p">,</span> <span class="n">miss_default</span> <span class="o">=</span> <span class="mf">9.96921e+36</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Netcdf insert method of Coord </span>
<span class="sd">    Inserts Coord as variable into Netcdf file.</span>

<span class="sd">    Input: file_handle file handle of opened Netcdf file.</span>

<span class="sd">    Inserts Coord as variable into Netcdf file.</span>

<span class="sd">    Args:</span>
<span class="sd">      file_handle: (file object). Points to opened file.</span>
<span class="sd">      miss_default: (float) value to use as default for missing values/ NaNs</span>

<span class="sd">    Returns:</span>
<span class="sd">      file_handle</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c"># make a copy of self content and deal with missing values.</span>
    <span class="n">value</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">[:])</span>

    <span class="n">miss_val</span> <span class="o">=</span> <span class="n">miss_default</span>
    <span class="k">if</span> <span class="s">&#39;FillValue&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">:</span>
      <span class="n">miss_val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s">&#39;FillValue&#39;</span><span class="p">]</span>
    <span class="k">elif</span> <span class="s">&#39;missing_value&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">:</span>
      <span class="n">miss_val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s">&#39;missing_value&#39;</span><span class="p">]</span>

    <span class="k">try</span><span class="p">:</span>
    
      <span class="n">value</span><span class="p">[</span>  <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span> <span class="n">value</span><span class="p">[:]</span>  <span class="p">)</span> <span class="o">==</span> <span class="bp">True</span>   <span class="p">]</span> <span class="o">=</span> <span class="n">miss_val</span>
    <span class="k">except</span><span class="p">:</span>
      <span class="k">try</span><span class="p">:</span>
        <span class="n">value</span><span class="p">[</span>  <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span> <span class="n">value</span><span class="p">[:]</span>  <span class="p">)</span> <span class="o">==</span> <span class="bp">True</span>   <span class="p">]</span> <span class="o">=</span> <span class="n">miss_default</span>

      <span class="k">except</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&#39;Could not set missing value for Coord </span><span class="si">%s</span><span class="s">.&#39;</span><span class="o">%</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

    <span class="n">file_handle</span><span class="o">.</span><span class="n">createDimension</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>


    <span class="n">var_cdf</span> <span class="o">=</span> <span class="n">file_handle</span><span class="o">.</span><span class="n">createVariable</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">char</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,)</span>   <span class="p">)</span>
    
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">:</span>
      <span class="nb">setattr</span><span class="p">(</span><span class="n">var_cdf</span><span class="p">,</span><span class="n">k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> 

    <span class="n">var_cdf</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">return</span> <span class="n">file_handle</span>


<div class="viewcode-block" id="Coord.write"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Coord.write">[docs]</a>  <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">name</span> <span class="o">=</span> <span class="bp">None</span> <span class="p">,</span> <span class="n">history</span> <span class="o">=</span> <span class="s">&#39;Created from Spacegrids &#39;</span>  <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Writes Coord data to Netcdf file.</span>


<span class="sd">    Args:</span>
<span class="sd">      path: (str) path to the directory where the file will go (e.g. &#39;data/&#39; or &#39;/home/me/&#39;, default pwd).</span>
<span class="sd">      name: (str) file name (e.g. &quot;foo.nc&quot;)</span>
<span class="sd">      history: (str) Brief history or general description of the data.</span>
<span class="sd">      insert_dual: (Boolean) Flag determining whether to include the duals of the Coord objects in the file.</span>


<span class="sd">    Returns:</span>
<span class="sd">      None</span>
<span class="sd">   </span>
<span class="sd">    No error is raised in case of problems (only a message is displayed).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
      <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;.&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&#39;nc&#39;</span><span class="p">,</span><span class="s">&#39;cdf&#39;</span><span class="p">]:</span>
      <span class="n">name</span> <span class="o">=</span> <span class="n">name</span> <span class="o">+</span><span class="s">&#39;.nc&#39;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">path</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
      <span class="n">name</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span> <span class="n">path</span> <span class="p">,</span> <span class="n">name</span> <span class="p">)</span> 

    <span class="k">print</span> <span class="s">&#39;Writing Field to file </span><span class="si">%s</span><span class="s">&#39;</span><span class="o">%</span><span class="n">name</span>

    <span class="k">try</span><span class="p">:</span>
      <span class="c"># using io_sg version of netcdf_file. May use ScientificIO or Scipy</span>
      <span class="n">file_handle</span> <span class="o">=</span> <span class="n">netcdf_file</span><span class="p">(</span><span class="n">name</span> <span class="p">,</span> <span class="s">&#39;w&#39;</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">IOError</span><span class="p">:</span>
      <span class="k">print</span> <span class="s">&#39;Cannot write &#39;</span><span class="p">,</span> <span class="n">name</span>
    <span class="k">else</span><span class="p">:</span>

      <span class="n">file_handle</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cdf_insert</span><span class="p">(</span><span class="n">file_handle</span><span class="p">)</span>

      <span class="n">file_handle</span><span class="o">.</span><span class="n">history</span> <span class="o">=</span> <span class="n">history</span> <span class="o">+</span> <span class="s">&#39;</span><span class="si">%s</span><span class="s">&#39;</span><span class="o">%</span><span class="nb">str</span><span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">())</span>
 
<span class="c">#    var_cdf.units = self.units</span>

      <span class="n">file_handle</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>


</div>
<div class="viewcode-block" id="Coord.finer"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Coord.finer">[docs]</a>  <span class="k">def</span> <span class="nf">finer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">factor</span> <span class="o">=</span> <span class="mf">5.</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Method of Coord. Refine the coordinate point interval by a given factor.</span>

<span class="sd">    Args:</span>
<span class="sd">      factor: (float) factor by which to refined Coord value.</span>

<span class="sd">    Returns:</span>
<span class="sd">      Coord with value refined according to factor.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
      <span class="n">result</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">],(</span><span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">/</span><span class="n">factor</span><span class="p">))</span>


    <span class="n">finer_coord</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s">&#39;_fine&#39;</span><span class="p">,</span><span class="n">value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">result</span><span class="p">))</span>  
    <span class="n">finer_coord</span><span class="o">.</span><span class="n">make_equiv</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">finer_coord</span>

</div>
  <span class="k">def</span> <span class="nf">_bigslice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">F</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">   Coord method that takes slice of field along Coord (self) at argument index.    </span>

<span class="sd">    Args:</span>
<span class="sd">      F: (Field) field to slice</span>
<span class="sd">      index: (int) location of slice</span>


<span class="sd">    Returns:</span>
<span class="sd">      Field representing sliced object, with self no longer appearing in Gr.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">F</span><span class="p">):</span>
      <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&#39;Warning Coord part: Provide Field.&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="bp">self</span> <span class="ow">in</span> <span class="n">F</span><span class="o">.</span><span class="n">grid</span><span class="p">:</span>
      <span class="n">sl</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span><span class="bp">None</span><span class="p">,</span><span class="bp">None</span><span class="p">)</span>
      <span class="n">sl2</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">index</span><span class="p">,</span><span class="n">index</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
      <span class="n">L</span> <span class="o">=</span> <span class="p">[]</span>
      <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">F</span><span class="o">.</span><span class="n">grid</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span> <span class="ow">is</span> <span class="n">e</span><span class="p">:</span>
          <span class="n">L</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sl2</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="n">L</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sl</span><span class="p">)</span>

      <span class="k">return</span> <span class="n">F</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">name</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">name</span> <span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="n">L</span><span class="p">]),</span> <span class="n">grid</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">grid</span><span class="o">/</span><span class="bp">self</span><span class="p">,</span> <span class="n">units</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">units</span><span class="p">)</span>
   
    <span class="k">else</span><span class="p">:</span>
      <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&#39;Warning Coord slice: Coord not in Field grid. Returning Field.&#39;</span> <span class="p">)</span>   
      <span class="k">return</span> <span class="n">F</span>

<span class="c"># belongs to  Coord</span>
<div class="viewcode-block" id="Coord.coord_shift"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Coord.coord_shift">[docs]</a>  <span class="k">def</span> <span class="nf">coord_shift</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">F</span><span class="p">,</span><span class="n">shift</span><span class="p">,</span> <span class="n">keepgrid</span> <span class="o">=</span> <span class="bp">False</span><span class="p">,</span> <span class="n">nan_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Coord method that shifts the coordinates and value of a field by a number of indices. </span>

<span class="sd">    The shifted Coord in the grid of the Field argument is replaced with a (different) shifted Coord: disable this behaviour with argument keepgrid = True. Calls roll function. </span>

<span class="sd">    Args:</span>
<span class="sd">      F: (Field) field to shift</span>
<span class="sd">      shift: (int) magnitude (corresponding to array index) of shift</span>
<span class="sd">      keepgrid: (Boolean, default False) grid not updated if True</span>

<span class="sd">    Returns:</span>
<span class="sd">      The shifted Field.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="n">roll</span><span class="p">(</span><span class="n">F</span><span class="p">,</span><span class="n">shift</span> <span class="o">=</span> <span class="n">shift</span><span class="p">,</span><span class="n">coord</span> <span class="o">=</span> <span class="bp">self</span><span class="p">,</span><span class="n">mask</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">keepgrid</span> <span class="o">=</span> <span class="n">keepgrid</span><span class="p">,</span> <span class="n">nan_val</span> <span class="o">=</span> <span class="n">nan_val</span><span class="p">)</span>

<span class="c"># belongs to  Coord </span></div>
<div class="viewcode-block" id="Coord.trans"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Coord.trans">[docs]</a>  <span class="k">def</span> <span class="nf">trans</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">F</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Gives the change in Field F upon a Coord shift of 1 index in the direction of the self Coord.</span>

<span class="sd">    F - self.coord_shift(F,shift=1,keepgrid = True)</span>

<span class="sd">    Args:</span>
<span class="sd">      F: (Field) field to act on</span>

<span class="sd">    Returns:</span>
<span class="sd">      Field: the transformed Field.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c"># select keepgrid = True to avoid substraction errors relating to different grids</span>
    <span class="k">return</span> <span class="n">F</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">coord_shift</span><span class="p">(</span><span class="n">F</span><span class="p">,</span><span class="n">shift</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">keepgrid</span> <span class="o">=</span> <span class="bp">True</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Coord.sum"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Coord.sum">[docs]</a>  <span class="k">def</span> <span class="nf">sum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">F</span><span class="p">,</span> <span class="n">land_nan</span> <span class="o">=</span> <span class="bp">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Method of Coord  that sums Field F along self Coord direction. Not weighted with grid cell width. Uses masked arrays to handle nan values. nan values can be used to eliminate areas from summing area.</span>


<span class="sd">    Args:</span>
<span class="sd">      F: (Field) field of certain dimension n to sum</span>
<span class="sd">      land_nan: (Boolean)</span>

<span class="sd">    Returns:</span>
<span class="sd">      Field of dimension n-1 or float if n=1. </span>

<span class="sd">    Raises:</span>
<span class="sd">      ValueError: when Coord (self) is not in F.grid (grid of Field).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span> <span class="ow">in</span> <span class="n">F</span><span class="o">.</span><span class="n">grid</span><span class="p">:</span>
      <span class="k">raise</span>  <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Coord sum method of </span><span class="si">%s</span><span class="s">: Coord must be in grid of argument Field. Make sure Coord object is identical to one of Coord objects in Field grid. (Also watch for stale objects.)&#39;</span><span class="o">%</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>   

    <span class="n">value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ma</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_array</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">value</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">value</span><span class="p">)),</span> <span class="n">axis</span> <span class="o">=</span> <span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">grid</span><span class="p">)</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="p">))</span>
    <span class="n">find_land</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ma</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">value</span><span class="p">)),</span> <span class="n">axis</span> <span class="o">=</span> <span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">grid</span><span class="p">)</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="p">))</span>

    <span class="k">if</span> <span class="n">land_nan</span><span class="p">:</span>
      <span class="k">if</span> <span class="ow">not</span> <span class="n">value</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">value</span><span class="p">[</span><span class="n">find_land</span> <span class="o">==</span> <span class="mf">0.</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>


    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">grid</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
      <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span> 
      <span class="k">return</span> <span class="n">F</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">name</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">name</span><span class="p">,</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="p">,</span> <span class="n">grid</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">grid</span><span class="o">/</span><span class="bp">self</span> <span class="p">)</span>
 

<span class="c"># ---&gt; belongs to Coord class</span>
</div>
<div class="viewcode-block" id="Coord.roll"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Coord.roll">[docs]</a>  <span class="k">def</span> <span class="nf">roll</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">shift</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Yields copy of Coord (self) with value shifted by (int) argument shift using numpy.roll().</span>

<span class="sd">    Args:</span>
<span class="sd">      shift: (int) number of array positions to shift by</span>
<span class="sd"> </span>
<span class="sd">    Returns:</span>
<span class="sd">      Coord: shifted Coord.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s">&#39;_rolled&#39;</span><span class="p">,</span><span class="n">value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">,</span><span class="n">shift</span> <span class="o">=</span> <span class="n">shift</span><span class="p">))</span>
</div>
<div class="viewcode-block" id="Coord.flip"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Coord.flip">[docs]</a>  <span class="k">def</span> <span class="nf">flip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">F</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Reverse order of elements along axis of this Coord (a mirror, or flip). </span>

<span class="sd">    Grid remains unchanged: strictly, this will lead to an inconsistency between the Field data and the grid, assuming this is what the user wants.</span>


<span class="sd">    Args:</span>
<span class="sd">      F: (Field) Field to mirror</span>
<span class="sd"> </span>
<span class="sd">    Returns:</span>
<span class="sd">      Field of equal dimension, mirrored along Coord.</span>
<span class="sd">    &quot;&quot;&quot;</span>
  
    <span class="n">SI</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_slice_index</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span> <span class="n">slice_obj</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span><span class="bp">None</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">F</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">name</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">name</span><span class="p">,</span><span class="n">value</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="n">SI</span><span class="p">],</span><span class="n">grid</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span> <span class="n">units</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">units</span><span class="p">)</span>


</div>
  <span class="k">def</span> <span class="nf">_slice_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">grid</span> <span class="p">,</span> <span class="n">slice_obj</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="bp">None</span><span class="p">,</span><span class="bp">None</span><span class="p">)):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Yields a list of slice objects that can be used to slice along the axis of this (self) Coord.</span>


<span class="sd">    Args:</span>
<span class="sd">      grid: (Gr) grid context of slicing</span>
<span class="sd">      slice_obj: Slice object </span>

<span class="sd">    Returns:</span>
<span class="sd">      List of slice objects of equal length to (argument) grid. These objects can be used to slice Field objects defined on that grid.</span>


<span class="sd">    Examples:</span>

<span class="sd">    &gt;&gt;&gt; coord1 = sg.fieldcls.Coord(name = &#39;test1&#39;,direction =&#39;X&#39;,value =np.array([1.,2.,3.]) )</span>
<span class="sd">    &gt;&gt;&gt; coord2 = sg.fieldcls.Coord(name = &#39;test2&#39;,direction =&#39;Y&#39;,value =np.array([1.,2.,3.,4.]) )</span>
<span class="sd">    &gt;&gt;&gt; K = coord1(coord1*coord2)</span>
<span class="sd">    &gt;&gt;&gt; coord1.slice_index(K)</span>
<span class="sd">    [slice(1, None, None), slice(None, None, None)]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sl</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="bp">None</span><span class="p">,))</span>
    <span class="n">L</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">grid</span><span class="p">:</span>
      <span class="k">if</span> <span class="bp">self</span> <span class="ow">is</span> <span class="n">e</span><span class="p">:</span>
        <span class="n">L</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">slice_obj</span><span class="p">)</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="n">L</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sl</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">L</span>

<span class="c"># --&gt; belongs to Coord </span>

<div class="viewcode-block" id="Coord.cumsum"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Coord.cumsum">[docs]</a>  <span class="k">def</span> <span class="nf">cumsum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">F</span><span class="p">,</span> <span class="n">upward</span> <span class="o">=</span> <span class="bp">False</span><span class="p">,</span><span class="n">land_nan</span> <span class="o">=</span> <span class="bp">True</span><span class="p">):</span>
    
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute cumulative sum (integral) of input Field F along axis of F corresponding to this Coord object.</span>

<span class="sd">     If argument upward is set to true, summing takes place with increasing array index. If it is set to False, summing takes place with decreasing array index starting at index -1. Values of nan are set to 0, and therefore not counted.</span>

<span class="sd">    Args:</span>
<span class="sd">      F: (Field) Field to sum</span>
<span class="sd">      upward: (Boolean) flag to set direction of cumsum</span>
<span class="sd">      land_nan: (Boolean) flag to set land to nan in the resulting array</span>

<span class="sd">    Returns:</span>
<span class="sd">      Field on same grid containing the cumsum.</span>

<span class="sd">    Raises:</span>
<span class="sd">      ValueError: when Coord (self) is not in F.grid (grid of Field).</span>

<span class="sd">    Examples:</span>

<span class="sd">    &gt;&gt;&gt; coord1 = sg.fieldcls.Coord(name = &#39;test1&#39;,direction =&#39;X&#39;,value =np.array([1.,2.,3.]) )</span>
<span class="sd">    &gt;&gt;&gt; coord2 = sg.fieldcls.Coord(name = &#39;test2&#39;,direction =&#39;Y&#39;,value =np.array([1.,2.,3.,4.]) )</span>
<span class="sd">    &gt;&gt;&gt; R = coord1.cumsum(sg.ones(coord1*coord2)  );R.value</span>
<span class="sd">    array([[ 3.,  3.,  3.,  3.],</span>
<span class="sd">           [ 2.,  2.,  2.,  2.],</span>
<span class="sd">           [ 1.,  1.,  1.,  1.]])</span>

<span class="sd">    &gt;&gt;&gt; R = coord1.cumsum(sg.ones(coord1*coord2) , upward = True );R.value</span>
<span class="sd">    array([[ 1.,  1.,  1.,  1.],</span>
<span class="sd">           [ 2.,  2.,  2.,  2.],</span>
<span class="sd">           [ 3.,  3.,  3.,  3.]])</span>
<span class="sd">    &quot;&quot;&quot;</span>

<span class="c"># nan values are set to 0. They are not counted.</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span> <span class="ow">in</span> <span class="n">F</span><span class="o">.</span><span class="n">grid</span><span class="p">:</span>

      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Coord </span><span class="si">%s</span><span class="s"> cum_sum method: Coord must be in grid of argument Field </span><span class="si">%s</span><span class="s">. Make sure Coord object is identical to Coord objects in Field grid.&#39;</span><span class="o">%</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">F</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>  <span class="p">)</span>


    <span class="k">if</span> <span class="n">upward</span><span class="p">:</span>
      <span class="c"># use the copy method of the Field to obtain a similar Field, but with some attributes different (namely, those set in the argument).</span>
      <span class="n">Fc</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
    <span class="k">else</span><span class="p">:</span>
      <span class="n">Fc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="p">)</span>
    
    <span class="c"># do not count land in sums:  </span>
    <span class="n">land_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">Fc</span><span class="o">.</span><span class="n">value</span><span class="p">)</span> 
    <span class="n">Fc</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="n">land_i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.</span>

    <span class="n">result_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">Fc</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="p">(</span><span class="n">Fc</span><span class="o">.</span><span class="n">grid</span><span class="p">)</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="p">))</span>

    <span class="k">if</span> <span class="n">land_nan</span> <span class="o">==</span> <span class="bp">True</span><span class="p">:</span>
      <span class="c"># if desired, set land to nan in resulting array:</span>
      <span class="n">result_array</span><span class="p">[</span><span class="n">land_i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

    <span class="k">if</span> <span class="n">upward</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">F</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">value</span> <span class="o">=</span> <span class="n">result_array</span> <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="c"># need to flip back:</span>
      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">value</span> <span class="o">=</span> <span class="n">result_array</span><span class="p">))</span>


</div>
<div class="viewcode-block" id="Coord.vsum"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Coord.vsum">[docs]</a>  <span class="k">def</span> <span class="nf">vsum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">F</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Method of Coord .</span>
<span class="sd">    Sums Field along self Coord, weighted with grid cell width (using self.d(), called by self.vol(F.grid)). Note: due to possible dependence of one Coord on the other, only use mean method of grid. There is no mean method for Coord objects.</span>

<span class="sd">    Method of Coord  that sums Field F along self Coord direction, weighted with the grid cell width. Calls sum method. See sum method.</span>

<span class="sd">    Calculation is self.sum(F*(self.vol(F.grid))). For grids with grid cell width depending on coordinates, use corresponding Gr methods.     </span>

<span class="sd">    Args:</span>
<span class="sd">      F: (Field) field of certain dimension n to sum</span>
<span class="sd">      </span>
<span class="sd">    Returns:</span>
<span class="sd">      Field of dimension n-1 or float if n=1. </span>

<span class="sd">    Raises:</span>
<span class="sd">      ValueError: when Coord (self) is not in F.grid (grid of Field).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">F</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vol</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">grid</span><span class="p">)))</span>     


</div>
<div class="viewcode-block" id="Coord.vcumsum"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Coord.vcumsum">[docs]</a>  <span class="k">def</span> <span class="nf">vcumsum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">F</span><span class="p">,</span><span class="n">upward</span> <span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute cumulative sum, weighted with grid cell width, of input Field F along axis of F corresponding to this Coord object.</span>

<span class="sd">     If argument upward is set to true, summing takes place with increasing array index. If it is set to False, summing takes place with decreasing array index starting at index -1. Values of nan are set to 0, and therefore not counted. Calls cumsum method. See cumsum.  For grids with grid cell width depending on coordinates, use corresponding Gr methods.     </span>

<span class="sd">    Calculation is self.cumsum(F*(self.vol(F.grid)) )   </span>

<span class="sd">    Args:</span>
<span class="sd">      F: (Field) Field to sum</span>
<span class="sd">      upward: (Boolean) flag to set direction of cumsum</span>
<span class="sd">      land_nan: (Boolean) flag to set land to nan in the resulting array</span>

<span class="sd">    Returns:</span>
<span class="sd">      Field on same grid containing the cumsum.</span>

<span class="sd">    Raises:</span>
<span class="sd">      ValueError: when Coord (self) is not in F.grid (grid of Field).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">F</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vol</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">grid</span><span class="p">))</span> <span class="p">,</span> <span class="n">upward</span> <span class="o">=</span> <span class="n">upward</span><span class="p">)</span>   

<span class="c"># belongs to  Coord</span></div>
<div class="viewcode-block" id="Coord.dist"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Coord.dist">[docs]</a>  <span class="k">def</span> <span class="nf">dist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fact</span> <span class="o">=</span> <span class="mf">1.</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Distance (signed) along Coord from a certain fixed point (e.g. from ocean surface or from equator along y-direction).</span>


<span class="sd">    Args:</span>
<span class="sd">      fact: (float) magnification factor if required (e.g. radius of Earth).</span>

<span class="sd">    Returns:</span>
<span class="sd">      Field on rid self**2 containing factor*self.value as value. Represents distances of points from a certain point along Coord.</span>

<span class="sd">    See also:</span>
<span class="sd">      d method </span>
<span class="sd">      delta_dist method</span>
<span class="sd">      der method</span>
<span class="sd">      vol method      </span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="n">Field</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;distance_&#39;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span><span class="n">value</span> <span class="o">=</span> <span class="n">fact</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">,</span><span class="n">grid</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span> <span class="n">units</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">units</span><span class="p">)</span> 

</div>
<div class="viewcode-block" id="Coord.der"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Coord.der">[docs]</a>  <span class="k">def</span> <span class="nf">der</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">F</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Coord derivative method on Field argument F. </span>

<span class="sd">    If Coord non-cyclical, the first derivative element is nan and the second is the derivative at the first element of the original Coord. </span>


<span class="sd">    Args:</span>
<span class="sd">      F: (Field) Field to take derivative of</span>

<span class="sd">    Returns:</span>
<span class="sd">      Field on same grid containing the derivative.</span>

<span class="sd">    Raises:</span>
<span class="sd">      ValueError: when Coord (self) is not in F.grid (grid of Field).</span>

<span class="sd">    See also:</span>
<span class="sd">      d method </span>
<span class="sd">      delta_dist method</span>
<span class="sd">      dist method </span>
<span class="sd">      vol method      </span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="bp">self</span> <span class="ow">in</span> <span class="n">F</span><span class="o">.</span><span class="n">grid</span><span class="p">:</span>
      <span class="n">dF</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">trans</span><span class="p">(</span><span class="n">F</span><span class="p">)</span>
      <span class="n">ds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">trans</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist</span><span class="p">())</span>

      <span class="k">return</span> <span class="n">dF</span><span class="o">/</span><span class="n">ds</span>

    <span class="k">else</span><span class="p">:</span>

      <span class="k">raise</span>  <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Field argument grid does not contain Coord </span><span class="si">%s</span><span class="s">.&quot;</span><span class="o">%</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>


<span class="c"># belongs to  Coord  </span></div>
<div class="viewcode-block" id="Coord.delta_dist"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Coord.delta_dist">[docs]</a>  <span class="k">def</span> <span class="nf">delta_dist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fact</span> <span class="o">=</span> <span class="mf">1.</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Method to calculate the distance between adjacent elements of Coord.</span>
<span class="sd">    Appropriate to vertical direction.</span>
<span class="sd">    To be over-ridden for hor coords x,y =&gt; derive classes XCoord, YCoord</span>

<span class="sd">    Calls dist method and applies trans method.</span>

<span class="sd">    Returns an array as len(result) == len(grid)-1</span>

<span class="sd">    Calculates self.trans(self.dist())*fact</span>

<span class="sd">    Args:</span>
<span class="sd">      fact: (float) magnification factor if required (e.g. radius of Earth).</span>

<span class="sd">    Returns:</span>
<span class="sd">      Field: containing the distances between the adjacent coord points (i.e. i and i+1).</span>

<span class="sd">    See also:</span>
<span class="sd">      d method </span>
<span class="sd">      der method</span>
<span class="sd">      dist method </span>
<span class="sd">      vol method      </span>

<span class="sd">    Examples:</span>

<span class="sd">    &gt;&gt;&gt; coord1 = sg.fieldcls.Coord(name = &#39;test1&#39;,direction =&#39;X&#39;,value =np.array([1.,2.,3.]) )</span>
<span class="sd">    &gt;&gt;&gt; R = coord1.delta_dist();R.value</span>
<span class="sd">    array([ nan,   1.,   1.])</span>
<span class="sd">    &quot;&quot;&quot;</span>
       
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">trans</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist</span><span class="p">())</span><span class="o">*</span><span class="n">fact</span>

<span class="c"># --&gt; belongs to  Coord</span></div>
<div class="viewcode-block" id="Coord.d"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Coord.d">[docs]</a>  <span class="k">def</span> <span class="nf">d</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates width of grid cell in direction of Coord (self) using the dual of self (e.g. zt_edges). </span>

<span class="sd">    Yields grid cell widths. Can be used to compute volumes.</span>

<span class="sd">    To be overriden in x and y direction to accomodate for sphere.</span>

<span class="sd">    Calculates self.dual.delta_dist() where it is defined</span>

<span class="sd">    Returns:</span>
<span class="sd">      Field: containing the distances between the adjacent coord cell edges.</span>

<span class="sd">    See also: </span>
<span class="sd">      delta_dist method</span>
<span class="sd">      der method</span>
<span class="sd">      dist method </span>
<span class="sd">      vol method      </span>

<span class="sd">    Examples:</span>

<span class="sd">    &gt;&gt;&gt; coord1 = sg.fieldcls.Coord(name = &#39;test1&#39;,direction =&#39;X&#39;,value =np.array([1.,2.,3.]))</span>
<span class="sd">    &gt;&gt;&gt; coord1_edges = sg.fieldcls.Coord(name = &#39;test1_edges&#39;,direction =&#39;X&#39;,value =np.array([0.5,1.5,2.5,3.5]), dual = coord1 ) # specifying the dual here registers coord1_edges also as the dual attribute of coord1</span>
<span class="sd">    &gt;&gt;&gt; coord1.d().value    # the distance between the cell edges</span>
<span class="sd">    array([ 1.,  1.,  1.])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c"># calculate distances between adjacent points in dual:</span>
    <span class="n">ret_Field</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dual</span><span class="o">.</span><span class="n">delta_dist</span><span class="p">()</span>
    <span class="k">if</span> <span class="bp">self</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dual</span><span class="p">:</span>
      <span class="c"># for non-self dual Coord objects: truncate to achieve equal length to self:</span>
      <span class="n">ret_Field</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">ret_Field</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

    <span class="c"># update these attributes, as the original copy was based on self.dual:</span>
    <span class="n">ret_Field</span><span class="o">.</span><span class="n">grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">ret_Field</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">ret_Field</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">ret_Field</span>

</div>
<div class="viewcode-block" id="Coord.vol"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Coord.vol">[docs]</a>  <span class="k">def</span> <span class="nf">vol</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generalized volume method related to .d() method: self.d() if self in gr, None otherwise.</span>

<span class="sd">    Determines widths of cells along self Coord. grid argument acts as filter: aborts if self not in grid. The grid argument becomes much more critical in some derived classes (e.g. XCoord), where auxhiliary coordinates are picked from Gr and need to be present.</span>

<span class="sd">    See .d() method.</span>
<span class="sd"> </span>
<span class="sd">    Args:</span>
<span class="sd">      gr: (Gr) grid to test against.</span>

<span class="sd">    Returns:</span>
<span class="sd">       Field or None: self.d() if self in gr, None otherwise.</span>

<span class="sd">    Raises:</span>
<span class="sd">       ValueError: when Coord not in argument gr (so get this right in your scripts).</span>

<span class="sd">    See also: </span>
<span class="sd">      d method </span>
<span class="sd">      delta_dist method</span>
<span class="sd">      der method</span>
<span class="sd">      dist method </span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="bp">self</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">gr</span><span class="p">:</span>
      <span class="c"># Raising an error here to avoid harder debugging later on.</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Coord &quot;</span><span class="si">%s</span><span class="s">&quot; must be in grid argument &quot;</span><span class="si">%s</span><span class="s">&quot;.&#39;</span><span class="o">%</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">gr</span><span class="o">.</span><span class="n">__repr__</span><span class="p">()</span> <span class="p">)</span> <span class="p">)</span>
      
    <span class="k">else</span><span class="p">:</span>
      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">()</span>




<span class="c"># -------- End Coord  ----------------</span>


<span class="c"># The following contains two Coord subclasses XCoord and YCoord.</span>
<span class="c"># x is longitude and re-entrant and y is latitude.</span>
</div></div>
<div class="viewcode-block" id="XCoord"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.XCoord">[docs]</a><span class="k">class</span> <span class="nc">XCoord</span><span class="p">(</span><span class="n">Coord</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Specialized Coord class for representing longitudinal direction in spherical coordinates. A re-entrant geometry is assumed. See Coord.</span>

<span class="sd">  The XCoord class contains methods related to distances, with the following dependencies. dist and delta_dist are fundamental (no link, in contrast to Coord). The rest is the same as Coord: der depends on dist. d depends on dual Coord and delta_dist. vol depends on d.</span>
<span class="sd">  &quot;&quot;&quot;</span>


<div class="viewcode-block" id="XCoord.roll"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.XCoord.roll">[docs]</a>  <span class="k">def</span> <span class="nf">roll</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">shift</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Yields copy of XCoord (self) with value shifted by integer using numpy.roll().</span>

<span class="sd">    Values are modulo 720 degrees from -360. </span>

<span class="sd">    Overrides .copy method of Coord</span>

<span class="sd">    Args:</span>
<span class="sd">      shift: (int) number of array positions to shift by</span>
<span class="sd"> </span>
<span class="sd">    Returns:</span>
<span class="sd">      Coord: shifted Coord.</span>

<span class="sd">    Examples:</span>

<span class="sd">    &gt;&gt;&gt; xcoord1 = sg.fieldcls.XCoord(name = &#39;test1&#39;,direction =&#39;X&#39;,value =np.array([1.,2.,3.]) )</span>
<span class="sd">    &gt;&gt;&gt; xcoord1.roll(1).value</span>
<span class="sd">    array([-357.,    1.,    2.])</span>
<span class="sd">    &quot;&quot;&quot;</span>

 
    <span class="n">value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">,</span><span class="n">shift</span> <span class="o">=</span> <span class="n">shift</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">shift</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
      <span class="n">value</span><span class="p">[:</span><span class="n">shift</span><span class="p">]</span> <span class="o">-=</span> <span class="mf">360.</span>
    <span class="k">elif</span> <span class="n">shift</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
      <span class="n">value</span><span class="p">[</span><span class="n">shift</span><span class="p">:]</span> <span class="o">+=</span> <span class="mf">360.</span>
      <span class="n">value</span> <span class="o">-=</span> <span class="mf">360.</span>
   
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s">&#39;_rolled&#39;</span><span class="p">,</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="p">)</span>

<span class="c"># belongs to XCoord </span></div>
<div class="viewcode-block" id="XCoord.coord_shift"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.XCoord.coord_shift">[docs]</a>  <span class="k">def</span> <span class="nf">coord_shift</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">F</span><span class="p">,</span><span class="n">shift</span><span class="p">,</span> <span class="n">keepgrid</span> <span class="o">=</span> <span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    XCoord method that shifts the coordinates and value of a field by a number of indices. </span>

<span class="sd">    Overides Coord coord_shift method. Here, mask is False, so that the array elements are (1D) rotated: this is the simple way in which this method differs from its Coord counterpart.</span>

<span class="sd">    Note that because this method overrides, the trans method also behaves differently because it calls coord_shift, even though the trans method itself is not overriden! </span>

<span class="sd">    The shifted Coord in the grid of the Field argument is replaced with a (different) shifted Coord: disable this behaviour with argument keepgrid = True. Calls roll function. </span>

<span class="sd">    Args:</span>
<span class="sd">      F: (Field) field to shift</span>
<span class="sd">      shift: (int) magnitude (corresponding to array index) of shift</span>
<span class="sd">      keepgrid: (Boolean, default False) grid not updated if True</span>

<span class="sd">    Returns:</span>
<span class="sd">      The shifted Field, where elements at the very beginning or end of the value array re-appear at the other side of the array (1D-rotation).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="n">roll</span><span class="p">(</span><span class="n">F</span><span class="p">,</span><span class="n">shift</span> <span class="o">=</span> <span class="n">shift</span><span class="p">,</span><span class="n">coord</span> <span class="o">=</span> <span class="bp">self</span><span class="p">,</span> <span class="n">mask</span> <span class="o">=</span> <span class="bp">False</span><span class="p">,</span> <span class="n">keepgrid</span> <span class="o">=</span> <span class="n">keepgrid</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="XCoord.delta_dist"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.XCoord.delta_dist">[docs]</a>  <span class="k">def</span> <span class="nf">delta_dist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">y_coord</span><span class="p">,</span><span class="n">fact</span> <span class="o">=</span> <span class="n">R</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes distances between adjacent spherical longitudinal coordinate points of XCoord (self) taking into account latitudinal positions.</span>

<span class="sd">    Overrides delta_dist method of Coord class. Does not call dist method (unlike Coord method), but assumes self.value to be an array of longitudinal polar coord values in degrees.</span>

<span class="sd">    Args:</span>
<span class="sd">      y_coord: (YCoord) latitudinal coordinate positions (usually component in grid context).</span>
<span class="sd">      fact: (float) factor by which to multiply result: this should be radius of sphere.</span>

<span class="sd">    Returns:</span>
<span class="sd">      Field: defined on grid y_coord*self (2D), containing the longitudinal distances.</span>

<span class="sd">    See also: </span>
<span class="sd">      d method </span>
<span class="sd">      der method</span>
<span class="sd">      dist method </span>
<span class="sd">      vol method      </span>
<span class="sd">    &quot;&quot;&quot;</span>
 
    <span class="c"># crdvals is in degrees longitude</span>
    <span class="n">crdvals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">crdvals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-=</span> <span class="mf">360.</span>
    <span class="n">crdvals</span> <span class="o">-=</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span>

    <span class="n">val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span> <span class="o">-</span><span class="n">fact</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">y</span><span class="p">))</span><span class="o">*</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mf">180.</span><span class="p">)</span><span class="o">*</span><span class="n">crdvals</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">y_coord</span>  <span class="p">])</span>
   
    <span class="k">return</span> <span class="n">Field</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;delta_&#39;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span><span class="n">value</span> <span class="o">=</span> <span class="n">val</span><span class="p">,</span><span class="n">grid</span> <span class="o">=</span> <span class="n">y_coord</span><span class="o">*</span><span class="bp">self</span><span class="p">,</span> <span class="n">units</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">units</span><span class="p">)</span> 

</div>
<div class="viewcode-block" id="XCoord.der"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.XCoord.der">[docs]</a>  <span class="k">def</span> <span class="nf">der</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span><span class="n">y_coord</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    XCoord derivative method on Field F. </span>

<span class="sd">    XCoord is cyclical, the first derivative element is not nan. </span>

<span class="sd">    Overrides Coord der method. Differs in that this method takes an extra y_coord argument, which is required for the calculation of cell distances.</span>

<span class="sd">    Args:</span>
<span class="sd">      F: (Field) Field to take derivative of</span>
<span class="sd">      y_coord: (YCoord) latitudinal Coord (usually component in grid context).</span>

<span class="sd">    Returns:</span>
<span class="sd">      Field on same grid containing the derivative.</span>

<span class="sd">    Raises:</span>
<span class="sd">      ValueError: when Coord (self) is not in F.grid (grid of Field).</span>

<span class="sd">    See also: </span>
<span class="sd">      d method </span>
<span class="sd">      delta_dist method</span>
<span class="sd">      dist method </span>
<span class="sd">      vol method      </span>
<span class="sd">    &quot;&quot;&quot;</span>


<span class="c"># Cyclical coords uses different method for ds: it takes the y_coord arg.</span>

    <span class="k">if</span> <span class="bp">self</span> <span class="ow">in</span> <span class="n">F</span><span class="o">.</span><span class="n">grid</span><span class="p">:</span>
      <span class="n">dF</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">trans</span><span class="p">(</span><span class="n">F</span><span class="p">)</span>
      <span class="n">ds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta_dist</span><span class="p">(</span><span class="n">y_coord</span><span class="p">)</span>

      <span class="k">return</span> <span class="n">dF</span><span class="o">/</span><span class="n">ds</span>

    <span class="k">else</span><span class="p">:</span>

      <span class="k">raise</span>  <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Field argument grid does not contain XCoord </span><span class="si">%s</span><span class="s">.&quot;</span><span class="o">%</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>


</div>
<div class="viewcode-block" id="XCoord.dist"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.XCoord.dist">[docs]</a>  <span class="k">def</span> <span class="nf">dist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y_coord</span><span class="p">,</span> <span class="n">fact</span> <span class="o">=</span> <span class="n">R</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Distance (signed) along XCoord (self) in only one direction (increasing index) from a fixed point.</span>

<span class="sd">    The fixed point is usually 0 longitude, but depends on the Coord.</span>

<span class="sd">    Overrides dist method of Coord class. Assumes self.value to be an array of longitudinal polar coord values in degrees.</span>


<span class="sd">    Args:</span>
<span class="sd">      y_coord: (YCoord) latitudinal Coord (usually component in grid context).</span>
<span class="sd">      fact: (float) factor by which to multiply result: this should be radius of sphere.</span>


<span class="sd">    Returns:</span>
<span class="sd">      Field: of shape (len(yt_coord),len(self)), defined on grid y_coord*self, containing the distances.</span>

<span class="sd">    See also: </span>
<span class="sd">      d method </span>
<span class="sd">      delta_dist method</span>
<span class="sd">      der method</span>
<span class="sd">      vol method      </span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">crdvals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span>
    
    <span class="k">return</span> <span class="n">Field</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;distance_&#39;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span><span class="n">value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span> <span class="n">fact</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">y</span><span class="p">))</span><span class="o">*</span><span class="n">crdvals</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">y_coord</span>  <span class="p">])</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mf">180.</span><span class="p">,</span><span class="n">grid</span> <span class="o">=</span> <span class="n">y_coord</span><span class="o">*</span><span class="bp">self</span><span class="p">,</span> <span class="n">units</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">units</span><span class="p">)</span> 



</div>
<div class="viewcode-block" id="XCoord.d"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.XCoord.d">[docs]</a>  <span class="k">def</span> <span class="nf">d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">y_coord</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates width of grid cell in direction of XCoord (self) using the dual of self (e.g. xt_edges). </span>

<span class="sd">    Yields grid cell widths. Can be used to compute volumes.</span>

<span class="sd">    Overides the d method of the Coord class.</span>

<span class="sd">    Calculates self.dual.delta_dist() where it is defined</span>

<span class="sd">   Args:</span>
<span class="sd">      y_coord: (YCoord) latitudinal coordinate positions (usually component in grid context).</span>
<span class="sd"> </span>
<span class="sd">    Returns:</span>
<span class="sd">      Field: of shape (len(yt_coord),len(self)), defined on grid y_coord*self, containing the distances between the adjacent coord cell edges.</span>

<span class="sd">    See also:</span>
<span class="sd">      delta_dist method</span>
<span class="sd">      der method</span>
<span class="sd">      dist method </span>
<span class="sd">      vol method      </span>

<span class="sd">    Examples:</span>

<span class="sd">    &gt;&gt;&gt; y_step=30;</span>
<span class="sd">    &gt;&gt;&gt; xcoord1 = sg.fieldcls.XCoord(name = &#39;testx&#39;,direction =&#39;X&#39;,value =np.arange(0.,360.,90.) )</span>
<span class="sd">    &gt;&gt;&gt; ycoord1 = sg.fieldcls.YCoord(name = &#39;testy&#39;,direction =&#39;Y&#39;,value =np.arange(-90.,90.+y_step,y_step) )</span>
<span class="sd">    &gt;&gt;&gt; xcoord1_edges = sg.fieldcls.XCoord(name = &#39;testx_edges&#39;,direction =&#39;X&#39;,value = np.arange(0.,360+45.,90.) -45. , dual = xcoord1  )</span>
<span class="sd">    &gt;&gt;&gt; K = xcoord1.d(ycoord1)</span>
<span class="sd">    &gt;&gt;&gt; K.shape</span>
<span class="sd">    (7, 4)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c"># This d method overides the standard d method of the Coord class.</span>
    <span class="c"># It takes the y coordinate object in argument y_coord.</span>
    <span class="c"># When constructing classes derived from the Coord class, use</span>
    <span class="c"># this naming convention for Coord arguments: name argument</span>
    <span class="c"># {x,y,z}_coord to take {x,y,z}coord object. This can then be</span>
    <span class="c"># used to determine volume elements in grid objects (using the inspect module).</span>


    <span class="n">ret_Field</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dual</span><span class="o">.</span><span class="n">delta_dist</span><span class="p">(</span><span class="n">y_coord</span><span class="p">)</span>
    <span class="n">ret_Field</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">ret_Field</span><span class="o">.</span><span class="n">value</span><span class="p">[:,</span><span class="mi">1</span><span class="p">:]</span> <span class="c"># truncate field value</span>
    <span class="n">ret_Field</span><span class="o">.</span><span class="n">grid</span> <span class="o">=</span> <span class="n">y_coord</span><span class="o">*</span><span class="bp">self</span>
    <span class="n">ret_Field</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">ret_Field</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">()</span> <span class="c"># we have truncated the field value, so recalc</span>

    <span class="k">return</span> <span class="n">ret_Field</span>


<span class="c"># --&gt; belongs to XCoord</span>
</div>
<div class="viewcode-block" id="XCoord.vol"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.XCoord.vol">[docs]</a>  <span class="k">def</span> <span class="nf">vol</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">gr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generalized volume method related to d method of XCoord: yields self.d(y_coord) if self and a y-coord y_coord in gr, None otherwise.</span>

<span class="sd">    Determines widths (1D &quot;volumes&quot;) of cells along self Coord. grid argument acts as filter: aborts if self not in grid. The grid argument is more critical in derived classes (e.g. x_coord), where auxhiliary coordinates are picked from Gr and need to be present.</span>

<span class="sd">    Overrides vol method of Coord.</span>

<span class="sd">    Picks auxiliary coordinate (as when x-widths depend on y) from grid argument gr (y grid is chosen on the same grid as x-coord) depending on what inspect module finds in d method interface</span>
<span class="sd">.</span>

<span class="sd">    Args:</span>
<span class="sd">      gr: (Gr) grid to test against.</span>

<span class="sd">    Returns:</span>
<span class="sd">      Field or None: self.d() if self in gr, None otherwise.</span>

<span class="sd">    Raises:</span>
<span class="sd">      RuntimeError if no matching (e.g. y_coord) Coord can be found for d method argument.</span>

<span class="sd">    See also:</span>
<span class="sd">      d method </span>
<span class="sd">      delta_dist method</span>
<span class="sd">      der method</span>
<span class="sd">      dist method </span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c"># Depends on the use of {x,y,z}_coord convention in arguments to d() method of classes derived from Coord class (e.g. XCoord takes y_coord argument).</span>

    <span class="k">if</span> <span class="bp">self</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">gr</span><span class="p">:</span>
      <span class="k">print</span> <span class="s">&#39;Coord must be in grid argument, returning None.&#39;</span>
      <span class="k">return</span>


    <span class="n">coord_types</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;x_coord&#39;</span><span class="p">:</span><span class="n">XCoord</span><span class="p">,</span><span class="s">&#39;y_coord&#39;</span><span class="p">:</span><span class="n">YCoord</span><span class="p">,</span><span class="s">&#39;z_coord&#39;</span><span class="p">:</span><span class="n">Coord</span><span class="p">}</span>

    <span class="n">coord_store</span> <span class="o">=</span> <span class="p">{}</span>
<span class="c"># Determine the type of each coord in self</span>
    <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">gr</span><span class="p">:</span>
      <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">coord_types</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">coord_types</span><span class="p">[</span><span class="n">i</span><span class="p">]):</span>
          <span class="n">coord_store</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span>

   
      <span class="c"># get the Coord-derived objects that need to be passed to each d method of Coord (e.g. xt.d(yt))</span>

    <span class="k">try</span><span class="p">:</span>
      <span class="n">coords</span> <span class="o">=</span> <span class="p">[</span><span class="n">coord_store</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">inspect</span><span class="o">.</span><span class="n">getargspec</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">c</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&#39;x_coord&#39;</span><span class="p">,</span><span class="s">&#39;y_coord&#39;</span><span class="p">,</span><span class="s">&#39;z_coord&#39;</span><span class="p">]]</span>
    <span class="k">except</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s">&#39;Error in Coord argument matching for </span><span class="si">%s</span><span class="s">. Required Coord likely absent in grid argument </span><span class="si">%s</span><span class="s">.&#39;</span><span class="o">%</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span><span class="n">gr</span><span class="p">))</span>
     

    <span class="c"># Use splat operator * to pass coords list on as argument. Create Field dV.</span>
    <span class="c"># usually this is just the YCoord element of grid.  </span>
    <span class="n">dV</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">(</span><span class="o">*</span><span class="n">coords</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">dV</span>     
  

</div></div>
<div class="viewcode-block" id="YCoord"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.YCoord">[docs]</a><span class="k">class</span> <span class="nc">YCoord</span><span class="p">(</span><span class="n">Coord</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Specialized Coord class for representing latitudinal direction in spherical coordinates. See Coord.</span>

<span class="sd">  The YCoord class contains methods related to distances, with dependencies identical to Coord (as opposed to XCoord). dist is overriden, working through into der, delta_dist, d and vol (even though these affected methods are inherited from Coord).  &quot;&quot;&quot;</span>

<div class="viewcode-block" id="YCoord.dist"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.YCoord.dist">[docs]</a>  <span class="k">def</span> <span class="nf">dist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fact</span> <span class="o">=</span> <span class="n">R</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Distance (signed) along YCoord (self) in only one direction (increasing index) from a fixed point.</span>

<span class="sd">    That fixed point is usually 0 latitude (yielding positive and negative distances), but depends on the Coord.</span>

<span class="sd">    Overrides dist method of Coord class. Assumes self.value to be an array of latitudinal polar coord values in degrees. This affects the Coord (parent) methods that depend on it: der, delta_dist, d and vol.</span>


<span class="sd">    Args:</span>
<span class="sd">      fact: (float) factor by which to multiply result: this should be radius of sphere.</span>


<span class="sd">    Returns:</span>
<span class="sd">      Field: of shape (len(self),), defined on 1D grid self**2, containing the distances.</span>

<span class="sd">    See also: </span>
<span class="sd">      d method </span>
<span class="sd">      delta_dist method</span>
<span class="sd">      der method</span>
<span class="sd">      dist method </span>
<span class="sd">      vol method      </span>
<span class="sd">    &quot;&quot;&quot;</span>


    <span class="k">return</span> <span class="n">Field</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;distance_&#39;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span><span class="n">value</span> <span class="o">=</span> <span class="n">fact</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mf">180.</span><span class="p">,</span><span class="n">grid</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span> <span class="n">units</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">units</span><span class="p">)</span> 



<span class="c"># -------- Ax  definition ----------</span>


</div></div>
<div class="viewcode-block" id="Ax"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Ax">[docs]</a><span class="k">class</span> <span class="nc">Ax</span><span class="p">(</span><span class="n">Directional</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Axis. Represents direction: e.g. the longitudinal direction, X, or the vertical, Z.</span>

<span class="sd">  Coord objects have an attribute that points to an Ax object, representing its direction.</span>

<span class="sd">  An abstract equivalence relationship is inherited from the Directional class, where two objects are equivalent when they have the same &#39;associative&#39; attribute (pointing to an Associative object). This relationship is generally used to indicate whether two Directional objects have the same direction (e.g. X,Y), but could represent other relationships depending on the user. This means that a Coord object can be equivalent to an Ax object. The usual meaning of this is that both point in the same direction.</span>


<span class="sd">  Attributes: (identical to Directional parent class)</span>
<span class="sd">      name: (str) name of Object</span>
<span class="sd">      direction: (str) name of direction in which object points</span>
<span class="sd">      long_name: (str) longer description (e.g. for display or in Netcdf)</span>
<span class="sd">  &quot;&quot;&quot;</span>
 


<div class="viewcode-block" id="Ax.vcumsum"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Ax.vcumsum">[docs]</a>  <span class="k">def</span> <span class="nf">vcumsum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">,</span> <span class="n">upward</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calls the Coord cumsum method by picking the right Coord from other.grid.</span>

<span class="sd">    Fails if Ax not in other.grid Ax objects.</span>

<span class="sd">    See Coord.cumsum</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c"># The product picks the Coord. e.g. X*(xt, yt) is xt </span>
    <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">*</span><span class="n">other</span><span class="o">.</span><span class="n">grid</span><span class="p">)</span><span class="o">.</span><span class="n">vcumsum</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">upward</span><span class="o">=</span><span class="n">upward</span><span class="p">)</span>

<span class="c"># --&gt; belongs to Ax    </span>

</div>
  <span class="nd">@_field2cumsum</span>
  <span class="k">def</span> <span class="nf">__or__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Shorthand calling make_equiv (to register equivalence with other Directional object). </span>

<span class="sd">    Args:</span>
<span class="sd">      other: (Ax)</span>

<span class="sd">    Returns:</span>
<span class="sd">      None</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">make_equiv</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>


  <span class="k">def</span> <span class="nf">__xor__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    If argument is a Coord, this method tests for equivalence. e.g. xt ~ xu</span>
<span class="sd">    If argument is a Field, this method takes the derivative along self Coord axis.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">Coord</span><span class="p">)</span> <span class="o">|</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">Ax</span><span class="p">):</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">other</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">equivs</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="bp">self</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">equivs</span><span class="p">):</span>

        <span class="k">return</span> <span class="bp">True</span>
      
      <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">False</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">Field</span><span class="p">):</span>
<span class="c">#      return (self*(other.grid)).der(other)</span>
      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">der</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">VField</span><span class="p">):</span>
      <span class="k">return</span> <span class="n">VField</span><span class="p">(</span> <span class="p">[</span><span class="bp">self</span><span class="o">^</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">other</span> <span class="p">]</span> <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;Ax error in </span><span class="si">%s</span><span class="s">^</span><span class="si">%s</span><span class="s"> with Ax </span><span class="si">%s</span><span class="s">. Provide Coord, Ax or Field for right member (now </span><span class="si">%s</span><span class="s">).&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">,</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">)</span> <span class="p">)</span>
      <span class="k">return</span>

<div class="viewcode-block" id="Ax.der"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Ax.der">[docs]</a>  <span class="k">def</span> <span class="nf">der</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">F</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Derivative method of Ax. Uses entire grid, in case some coords depend on other coords, as with x-coord. e.g. x-differentiation requires knowledge of y-position due to nature of polar coords.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">grid</span><span class="p">)</span><span class="o">.</span><span class="n">der</span><span class="p">(</span><span class="n">crd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">*</span><span class="n">F</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span> <span class="n">F</span> <span class="o">=</span> <span class="n">F</span><span class="p">)</span>      


<span class="c"># --&gt; belongs to Ax </span></div>
  <span class="k">def</span> <span class="nf">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Ax multiplication method.</span>

<span class="sd">    Yields for arg.:</span>
<span class="sd">      Ax/ AxGr: AxGr according to same is_equiv-based rules as Coord </span>
<span class="sd">      Gr: Coord if it is in Gr object and has attribute equal to self, None otherwise.</span>
<span class="sd">      Field: calls the Gr.vsum method.</span>
<span class="sd"> </span>
<span class="sd">    Examples:</span>

<span class="sd">    &gt;&gt;&gt; X*(X*Y) </span>
<span class="sd">    X*Y</span>
<span class="sd">    &gt;&gt;&gt; X*(latitude*longitude)</span>
<span class="sd">    longitude</span>
<span class="sd">    &quot;&quot;&quot;</span>


    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">Ax</span><span class="p">):</span>   
      <span class="c"># --&gt; multiplication with Ax object: behaves as Coord multiplication.</span>
      <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">is_equiv</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">AxGr</span><span class="p">((</span><span class="bp">self</span><span class="p">,))</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">AxGr</span><span class="p">((</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">))</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">Gr</span><span class="p">):</span>   
      <span class="c"># --&gt; multiplication with Gr object: yields equivalent Coord in Gr or None.</span>
      <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">eq_in</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="k">return</span> <span class="n">other</span><span class="p">[</span><span class="n">other</span><span class="o">.</span><span class="n">eq_index</span><span class="p">(</span><span class="bp">self</span><span class="p">)]</span>

      <span class="k">else</span><span class="p">:</span>
<span class="c">#        raise Exception(&#39;Axis not in Coord grid.&#39;)</span>
        <span class="k">return</span> <span class="bp">None</span> 
        
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">AxGr</span><span class="p">):</span>
      <span class="k">if</span> <span class="bp">self</span> <span class="ow">in</span> <span class="n">other</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">other</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">AxGr</span><span class="p">([</span><span class="bp">self</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="p">)</span>


    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">Field</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">VField</span><span class="p">):</span>
      <span class="c"># --&gt; multiplication with Field object: yields grid method on Field, which is vsum</span>
      <span class="c"># reduce to Coord via multiplication and then to grid method via power of 2:</span>
      <span class="k">return</span> <span class="p">((</span><span class="bp">self</span><span class="o">*</span><span class="n">other</span><span class="o">.</span><span class="n">grid</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">vsum</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;Ax error in </span><span class="si">%s</span><span class="s">*</span><span class="si">%s</span><span class="s"> with Ax </span><span class="si">%s</span><span class="s">: provide Coord, Gr or Field object as right multiplicant (now </span><span class="si">%s</span><span class="s">). If multiplicant appears to be a Coord of other multiplicant Field, check whether it is stale --&gt; update from Exper Coord stack to be synchronous with the grid of that Field. &#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">,</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">))</span>




<span class="c"># -------- End Ax  definition ----------</span>

</div>
<div class="viewcode-block" id="AxGr"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.AxGr">[docs]</a><span class="k">class</span> <span class="nc">AxGr</span><span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="n">Membered</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Same as Gr, but containing Ax objects instead of Coord.</span>

<span class="sd">  Difference is mainly in the multiplication methods.</span>

<span class="sd">  Example: (X,Y )  </span>
<span class="sd">  &quot;&quot;&quot;</span>

  <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>    
    <span class="n">rp</span> <span class="o">=</span> <span class="s">&#39;(&#39;</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
      <span class="n">rp</span> <span class="o">+=</span> <span class="n">i</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span><span class="s">&#39;,&#39;</span>
    
    <span class="k">return</span> <span class="n">rp</span><span class="o">+</span><span class="s">&#39;)&#39;</span>




  <span class="k">def</span> <span class="nf">__div__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Division of AxGr. Same rules as Gr: E.g. xt*yt*zt/yt yields xt*zt</span>

<span class="sd">    Examples:</span>

<span class="sd">    &gt;&gt;&gt; (X*Y)/Z</span>
<span class="sd">    (X,Y,)</span>
<span class="sd">    &gt;&gt;&gt; (X*Y)/X</span>
<span class="sd">    (Y,)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">Ax</span><span class="p">):</span>
      <span class="n">other</span> <span class="o">=</span> <span class="n">AxGr</span><span class="p">((</span><span class="n">other</span><span class="p">,))</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">Coord</span><span class="p">):</span>
      <span class="n">other</span> <span class="o">=</span> <span class="n">Gr</span><span class="p">((</span><span class="n">other</span><span class="p">,))</span>

    <span class="n">result</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
      <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">eq_in</span><span class="p">(</span><span class="n">it</span><span class="p">):</span>
        <span class="n">result</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">AxGr</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>




  <span class="k">def</span> <span class="nf">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Multiplication of Ax grids.</span>


<span class="sd">    Multiplication can take other arguments than just Ax grids. If a Field is provided as right multiplicant, the Field is summed over the left multiplicant grid, weighted with grid cell widths (the equivalence of integration over the grid space). If the right multiplicant is a Coord object, it is converted to a single-element grid (gr) object before multiplication. </span>

<span class="sd">    if right multiplicant is Gr object, operation picks elements from right multiplicant that are equivalent with Ax objects in AxGr object left multiplicant and yields a product in the order of the left multiplicant.</span>

<span class="sd">    Raises:</span>
<span class="sd">      TypeError: when inapparopriate type is used.</span>
<span class="sd">  </span>

<span class="sd">    Examples:</span>

<span class="sd">    &gt;&gt;&gt; (X*Z)*(zt*yt*xu)   # note the order of the output elements</span>
<span class="sd">    (xu, zt)</span>
<span class="sd">    &quot;&quot;&quot;</span>


    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">Coord</span><span class="p">):</span>

      <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">eq_in</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">other</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> 

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">Ax</span><span class="p">):</span>
      <span class="c"># multiplication between Gr Ax and Ax objects</span>
      <span class="k">if</span> <span class="n">other</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">AxGr</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="n">other</span><span class="p">])</span>


      <span class="k">return</span> <span class="n">other</span><span class="o">*</span><span class="bp">self</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">AxGr</span><span class="p">):</span>

      <span class="k">return</span> <span class="nb">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">:</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span> <span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">other</span><span class="p">))</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">Gr</span><span class="p">):</span>
      <span class="c"># if right multiplicant is Gr object, operation picks elements from right multiplicant that are equivalent with Ax objects in AxGr object left multiplicant and yields a product in the order of the left multiplicant.</span>
      <span class="n">L</span> <span class="o">=</span> <span class="p">[]</span>

      <span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">eq_in</span><span class="p">(</span><span class="n">it</span><span class="p">):</span>
          <span class="n">L</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">other</span><span class="p">[</span><span class="n">other</span><span class="o">.</span><span class="n">eq_index</span><span class="p">(</span><span class="n">it</span><span class="p">)])</span>

      <span class="k">return</span> <span class="n">Gr</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>    

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">Field</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">VField</span><span class="p">):</span>
     
      <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">*</span><span class="n">other</span><span class="o">.</span><span class="n">grid</span><span class="p">)</span><span class="o">.</span><span class="n">vsum</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;gr type error </span><span class="si">%s</span><span class="s">*</span><span class="si">%s</span><span class="s"> with Gr </span><span class="si">%s</span><span class="s"> (grid): provide Field, Gr or Coord object or np array as right multiplicant (now </span><span class="si">%s</span><span class="s">).&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">,</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">)</span> <span class="p">)</span>



<span class="c">#------------------------- end Ax and AxGr  -------------------------------</span>


<span class="c"># -------------- grid  --------------------------</span>

</div>
<div class="viewcode-block" id="Gr"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Gr">[docs]</a><span class="k">class</span> <span class="nc">Gr</span><span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="n">Membered</span><span class="p">):</span>

  <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  The Gr (grid) class represents Coord grids. A Gr object consists of a tuple of Coord objects, with additional Membered and other methods. </span>
<span class="sd">  </span>
<span class="sd">  Gr object behave like tuples of Coord objects, and indexing is done as in tuples: if g = Gr((coord1,coord2)), then g[0] is coord1 etc.</span>

<span class="sd">  The multiplication methods of Coord and Gr objects are such that Gr objects can be built via multiplication as follows: coord1*coord2 yields Gr((coord1,coord2)) etc. For instance, depth*latitude*longitude represents a 3 dimensional grid, and is essentially a Coord tuple of length 3 with extra methods.</span>

<span class="sd">  Gr objects g1 and g2 are considered weaksame, g1.weaksame(g2) yields True, when the individual Coord elements are weaksame.</span>
<span class="sd">  &quot;&quot;&quot;</span>



  <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Define &quot;==&quot; as array_equal of members and having equal length.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
      <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c"># empty grids are always equal (reduce will not work)</span>
        <span class="k">return</span> <span class="bp">True</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="ow">and</span> <span class="n">y</span><span class="p">,</span> <span class="p">[</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">other</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">e</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>  <span class="p">]</span> <span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
      <span class="k">return</span> <span class="bp">False</span>

  <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">,</span> <span class="n">method</span> <span class="o">=</span> <span class="s">&#39;linear&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Shorthand for regrid.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">regrid</span><span class="p">(</span><span class="n">other</span> <span class="o">=</span> <span class="n">other</span><span class="p">,</span> <span class="n">method</span> <span class="o">=</span> <span class="n">method</span><span class="p">)</span>

<div class="viewcode-block" id="Gr.regrid"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Gr.regrid">[docs]</a>  <span class="k">def</span> <span class="nf">regrid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">,</span> <span class="n">method</span> <span class="o">=</span> <span class="s">&#39;linear&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Takes another Gr object argument and yields a function F from ndarray to ndarray.</span>

<span class="sd">    The regrid method of a Gr object takes another Gr object, other, and yields a function F. This function F takes an array A and re-arranges the order of   the indices to match the input Gr object (other). If the length of the input object exceeds that of the calling object, F(A) also expands the array along the additional axes by creating copies of it along those axes (using the expand method). Note that the coords of the calling Gr object need to be a subset of the argument Gr object.</span>


<span class="sd">    Args: </span>
<span class="sd">      Other Gr object (grid). </span>
<span class="sd">    </span>

<span class="sd">    Returns: </span>
<span class="sd">      A transformation on fields going from self grid to other grid.</span>

<span class="sd">    E.g. xt*yt(yt*xt) yields a tranpose operation on an array</span>
<span class="sd">    xt*yt(xu*yu) yields an interpolation acting on fields.</span>

<span class="sd">    yt*xt(zt*yt*xt) yields a functions transforming a 2D array corresponding to the values of a Field defined on yt*xt to a 3D array constant in the zt direction.</span>
<span class="sd">    </span>
<span class="sd">    If self is longer than other, calling will lead to a reduction. E.g.</span>

<span class="sd">    R=(zt*yt*xt)((yt**2))(A) where A.shape = (len(zt),len(yt),len(xt))</span>
<span class="sd">    Leads to a list of length len(yt) containing arrays of dimension len(zt) by len(xt).</span>
<span class="sd">    Then for S=array(R) we get S.shape is (len(yt), len(zt), len(xt))</span>
<span class="sd">    </span>
<span class="sd">    For R=(zt*yt*xt)((xt*yt))(A) we get a list of lists and S.shape is (len(xt), len(yt), len(zt))</span>
<span class="sd">    Note that yt,xt appear in different order in self and other.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<span class="c"># might expand other to other*self in future code.</span>
    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>    
<span class="c"># *** CASE 1 ************************</span>

      <span class="c"># in this case both grids span the same space</span>

      <span class="c"># check if a permutation of Coord objects exists, i.e. whether the elements of either can be rearranged to yield the other: </span>
      <span class="n">pm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">perm</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">verbose</span> <span class="o">=</span> <span class="bp">False</span><span class="p">)</span>

      <span class="k">if</span> <span class="n">pm</span><span class="p">:</span>
        <span class="c"># CASE 1a ***</span>

        <span class="c"># if so, a function is returned that attempts to transpose any np array according to the permutation required to go from self to other.</span>
        <span class="c"># If A is a np array defined consistent with self ( A.shape is self.shape() ), then self(other)(A) is a np array consistent with other</span>
        <span class="k">return</span> <span class="k">lambda</span> <span class="n">A</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">pm</span><span class="p">)</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="c"># if no such direct permutation exists, check for a weaker conditions:</span>
        <span class="n">pm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eq_perm</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="c"># if there is a permutation of the coords up to equivalence (case 1b below), pm is that permutation and after permuting array A, the result needs to be interpolated from the permuted self (namely self.rearrange(pm)) to other.</span>
        <span class="c"># Here, &quot;up to equivalence&quot; means &quot;equivalent Coord objects being considered identical in considering whether a permutation exists&quot;.</span>
        <span class="c">#If A is a np array defined consistent with self, then self(other)(A) is a np array consistent with other, is interpolated onto the other.</span>

        <span class="k">if</span> <span class="n">pm</span><span class="p">:</span>
          <span class="c"># CASE 1b ***</span>
          <span class="k">return</span> <span class="k">lambda</span> <span class="n">A</span><span class="p">:</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rearrange</span><span class="p">(</span><span class="n">pm</span><span class="p">))</span><span class="o">.</span><span class="n">_smart_interp</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">pm</span><span class="p">),</span><span class="n">other</span><span class="p">,</span> <span class="n">method</span> <span class="o">=</span> <span class="n">method</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="c"># CASE 1c ***</span>
          <span class="c"># No luck.</span>
          <span class="k">print</span> <span class="s">&quot;grid </span><span class="si">%s</span><span class="s"> not equivalent to </span><span class="si">%s</span><span class="s">.&quot;</span><span class="o">%</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">)</span>
          <span class="k">return</span>

    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>  

<span class="c"># *** CASE 2 ************************</span>

      <span class="c"># A grid is called on a higher dimensional grid.</span>

      <span class="c"># inflate self grid by left multiplying with non-self elements</span>
      <span class="c"># don&#39;t do deepcopy, it copies the individual Coord elements too!</span>
      <span class="c"># instead, use the identity Coord:</span>

      <span class="c"># re-arrange Coord terms in accordance with expand method (the non-self elements of the other Gr are appended on the LEFT, and in the order of other).</span>
      <span class="c"># e.g. R=(yt*xt)(xt*yt*zw) yields a function yielding an array defined on the grid zw*yt*xt</span>
      <span class="c"># the order of the Coord elements in self_expanded is arranged so as to perform the expansion more easily (namely, adding axes at the beginning).</span>

      <span class="c"># if A is an ndarray consistent with self, then self.expand(A,other) is an ndarray consistent with the Gr self_expanded created here:</span>
      <span class="n">self_expanded</span> <span class="o">=</span> <span class="p">(</span><span class="n">other</span><span class="o">/</span><span class="bp">self</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span>

      <span class="c"># we now have a grid of equal length to other.</span>

      <span class="c"># the expanded left argument is not always in the same order as other (or even fully comprising of identical elements)</span>
      <span class="n">pm</span> <span class="o">=</span> <span class="n">self_expanded</span><span class="o">.</span><span class="n">perm</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">verbose</span> <span class="o">=</span> <span class="bp">False</span><span class="p">)</span>
     
      <span class="k">if</span> <span class="n">pm</span><span class="p">:</span>
        <span class="c"># case 2a</span>
        
        <span class="c"># In this case other contains only Coord elements from self_expanded.</span>
        <span class="c"># return function that takes ndarray A consistent with self and returns A expanded to other (yielding array of same dimension as other) and then transposed to be consistent with other.</span>
        <span class="c"># this should yield the same result as using other as argument for expand</span>
        <span class="k">return</span> <span class="k">lambda</span> <span class="n">A</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">self_expanded</span><span class="p">),</span><span class="n">pm</span><span class="p">)</span>

      <span class="k">else</span><span class="p">:</span>
        <span class="n">pm</span> <span class="o">=</span> <span class="n">self_expanded</span><span class="o">.</span><span class="n">eq_perm</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">verbose</span> <span class="o">=</span> <span class="bp">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">pm</span><span class="p">:</span>
          <span class="c"># case 2b</span>

          <span class="c"># line up the equivalent Coord elements in the same order for interpolation.</span>
          <span class="k">return</span> <span class="k">lambda</span> <span class="n">A</span><span class="p">:</span> <span class="p">(</span><span class="n">self_expanded</span><span class="o">.</span><span class="n">rearrange</span><span class="p">(</span><span class="n">pm</span><span class="p">))</span><span class="o">.</span><span class="n">_smart_interp</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">self_expanded</span><span class="p">),</span><span class="n">pm</span><span class="p">),</span><span class="n">other</span><span class="p">,</span> <span class="n">method</span> <span class="o">=</span> <span class="n">method</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="c"># case 2c</span>
          <span class="k">print</span> <span class="s">&quot;grids not equivalent&quot;</span>
          <span class="k">return</span>

      <span class="k">return</span> 

    <span class="k">else</span><span class="p">:</span>
<span class="c">#**** CASE 3 ************************</span>

      <span class="c"># This is the case where len(other) &lt; len(self) =&gt; reduce method. This yields a function that slices along the Gr provided in the argument, and a permutation among those axes if they appear in different order in self and other.</span>

<span class="c"># To illustrate this functionality:</span>

<span class="c">#If V is an ndarray consistent with zt*yt*xt</span>
<span class="c"># and we do R = np.array((zt*yt*xt)(yt*xt)(V));R = R.reshape((yt*xt*zt).shape())</span>
<span class="c"># Then We get V back, but transposed onto yt*xt*zt. This is because the index grid L = yt*xt is put first by (zt*yt*xt)(yt*xt)</span>


      <span class="c"># create target_grid of same dimension as self, and with other Coord elements first</span>
      <span class="n">target_grid</span> <span class="o">=</span> <span class="n">other</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">/</span><span class="n">other</span><span class="p">)</span>
      
      <span class="n">pm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">perm</span><span class="p">(</span><span class="n">target_grid</span><span class="p">,</span> <span class="n">verbose</span> <span class="o">=</span> <span class="bp">False</span><span class="p">)</span>      
     
      <span class="c"># Using reduce method. Note that reduce has the arguments the other way around. reduce is called as method of other!</span>
      <span class="k">if</span> <span class="n">pm</span><span class="p">:</span>
        <span class="c"># case 3a</span>
        <span class="k">return</span> <span class="k">lambda</span> <span class="n">A</span><span class="p">:</span> <span class="n">other</span><span class="o">.</span><span class="n">to_slices</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">pm</span><span class="p">),</span><span class="n">target_grid</span><span class="p">)</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="n">pm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eq_perm</span><span class="p">(</span><span class="n">target_grid</span><span class="p">,</span> <span class="n">verbose</span> <span class="o">=</span> <span class="bp">False</span><span class="p">)</span> 
        <span class="k">if</span> <span class="n">pm</span><span class="p">:</span>
          <span class="c"># case 3b</span>
          <span class="k">return</span> <span class="k">lambda</span> <span class="n">A</span><span class="p">:</span> <span class="n">other</span><span class="o">.</span><span class="n">to_slices</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">rearrange</span><span class="p">(</span><span class="n">pm</span><span class="p">))</span><span class="o">.</span><span class="n">_smart_interp</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">pm</span><span class="p">),</span><span class="n">target_grid</span><span class="p">,</span> <span class="n">method</span> <span class="o">=</span> <span class="n">method</span><span class="p">),</span><span class="n">target_grid</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
          <span class="c"># case 3c</span>
          <span class="k">print</span> <span class="s">&#39;Nope&#39;</span>
          <span class="k">return</span>
     
    <span class="k">return</span>

</div>
<div class="viewcode-block" id="Gr.squeeze"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Gr.squeeze">[docs]</a>  <span class="k">def</span> <span class="nf">squeeze</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Remove Coord members of length 1 and return them as a Gr.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">tosqueeze</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">([</span><span class="n">crd</span> <span class="k">for</span> <span class="n">crd</span> <span class="ow">in</span> <span class="bp">self</span> <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">crd</span><span class="o">.</span><span class="n">value</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">])</span>

    <span class="k">return</span> <span class="bp">self</span><span class="o">/</span><span class="n">tosqueeze</span><span class="p">,</span> <span class="n">tosqueeze</span>
</div>
<div class="viewcode-block" id="Gr.sliced"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Gr.sliced">[docs]</a>  <span class="k">def</span> <span class="nf">sliced</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">slices</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Create new sliced Gr object. </span>

<span class="sd">    Calls sliced methods on each Coord member using slice object arguments.</span>

<span class="sd">    Arguments can be of the form e.g. (slice(1,None,None),slice(1,None,None)slice(1,None,None)) or (X,slice(1,None,None)) etc.</span>

<span class="sd">    Args:</span>
<span class="sd">      slices: (tuple or list of) Coord, Ax or slice objects. </span>

<span class="sd">    Returns:</span>
<span class="sd">      A Gr object with sliced Coord members</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">slices</span> <span class="o">=</span> <span class="n">interpret_slices</span><span class="p">(</span><span class="n">slices</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">([</span><span class="n">crd</span><span class="o">.</span><span class="n">sliced</span><span class="p">(</span><span class="n">slices</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">crd</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="p">]</span> <span class="p">)</span>

</div>
<div class="viewcode-block" id="Gr.function"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Gr.function">[docs]</a>  <span class="k">def</span> <span class="nf">function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">func</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a Field containing the values of function argument func on the grid points defined in this grid. </span>

<span class="sd">    Args:</span>
<span class="sd">      func: (function) function defined on domain of same dimension as grid (self).</span>

<span class="sd">    Returns:</span>
<span class="sd">      Field: Evaulated function. The Field name is the name of the function.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">vfunc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="n">value</span> <span class="o">=</span> <span class="n">vfunc</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">inflate</span><span class="p">())</span>
 
    <span class="k">return</span> <span class="n">Field</span><span class="p">(</span><span class="n">name</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">func_name</span><span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="p">,</span> <span class="n">grid</span> <span class="o">=</span> <span class="bp">self</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Gr.array_equal"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Gr.array_equal">[docs]</a>  <span class="k">def</span> <span class="nf">array_equal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Grid component-wise test whether the Coord objects contain the same grid point location values. Input another grid.</span>

<span class="sd">    Args:</span>
<span class="sd">      other: (Gr) grid to compare with.</span>

<span class="sd">    Returns:</span>
<span class="sd">      List. List element corresponds to Coord in Gr and is True if Coord.array_equal True, False otherwise.</span>

<span class="sd">    Raises:</span>
<span class="sd">      ValueError if Gr objects not defined along same axes. E.g. (X,Y ) vs (Y,Z )</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">()</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">axis</span><span class="p">():</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Provide grids defined along same axes.&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">[</span><span class="n">e</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">other</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">e</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>   <span class="p">]</span>
        
</div>
<div class="viewcode-block" id="Gr.axis"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Gr.axis">[docs]</a>  <span class="k">def</span> <span class="nf">axis</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns an AxGr object containing the axis properties of the Coord elements of this grid.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">:</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">,[</span><span class="n">e</span><span class="o">.</span><span class="n">axis</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">])</span>


</div>
<div class="viewcode-block" id="Gr.nbytes"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Gr.nbytes">[docs]</a>  <span class="k">def</span> <span class="nf">nbytes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute and return memory usage by this object.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">:</span><span class="n">x</span><span class="o">.</span><span class="n">nbytes</span><span class="o">+</span><span class="n">y</span><span class="o">.</span><span class="n">nbytes</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>



<span class="c"># ------------------------------------------</span>
<span class="c"># Lower level methods:</span>
</div>
<div class="viewcode-block" id="Gr.to_slices"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Gr.to_slices">[docs]</a>  <span class="k">def</span> <span class="nf">to_slices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">A</span><span class="p">,</span><span class="n">other</span><span class="p">):</span>        
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    yields a list of slices along the coords defined in self. </span>

<span class="sd">    E.g.</span>
<span class="sd">    zt(zt*yt*xt) = [A[0,:,:],A[1,:,:],...] where A.shape is (zt*yt*xt).shape()</span>

<span class="sd">    Expects self coords to be subset of other, and appearing in same order in both.</span>
<span class="sd">    other must appear in the left side of self (i.e. self is self*(other/self)  ).</span>
<span class="sd">    For instance, zt*yt(zt*yt*xt) is valid,  yt*xt(zt*yt*xt) and zt(yt*xt) are not.</span>
<span class="sd">    The indexing in the output list (as list of lists) is of opposite order to the Coord elements in self.</span>

<span class="sd">    No checks are done on consistency between A or other or self and other.</span>

<span class="sd">    The opposite of expand. Used by call method of fields on Gr objects of lower dimension that the Field.</span>

<span class="sd">    Args: </span>
<span class="sd">      A: (ndarray) to be sliced. Has shape other.shape()</span>
<span class="sd">      other: (Gr) another larger grid containing self (self members are subset of other)</span>

<span class="sd">    Returns:</span>
<span class="sd">      A list of nparrays being slices of input A along the self Gr.</span>

<span class="sd">    Note that argument is longer than self. This is opposite to __call__ method, where a longer self leads to a reduction.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c"># This method works with recursion. If len(self)&gt;1, a list is built using this method on the smaller elements and indexing by the first dimension.</span>
    <span class="c"># if B = self.to_slices(A,other) and A is an array, then array(B) has the same shape and values as A.</span>
    <span class="c"># calling say (zt*yt).to_slices(A,zt*yt*xt) yields a list of lists. Each of those lists then contains a 1D array.</span>



<span class="c"># the following code is made slightly difficult due to recursion:</span>
<span class="c">#    if (force == False) and ( other != self*(other/self) ):</span>
<span class="c">#      warnings.warn(&#39;Calling Gr %s on Gr %s. other must equal self*(other/self).&#39;%(str(self),str(other) ) )</span>

 
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
      <span class="c"># single Coord Gr called on Gr. Endpoint of recursion.</span>
    
      <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span> 
      <span class="n">coord</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
      <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="nb">list</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">coord</span><span class="p">)):</span>
        <span class="c"># Numpy note: the colon here in A can represent several dimensions.</span>
          <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>   
       
      <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">coord</span><span class="p">)):</span>
  
        <span class="c"># Numpy note: the colon here in A can represent several dimensions.</span>
          <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,:])</span>   

      <span class="k">return</span> <span class="n">result</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="c"># multiple coord Gr called on Gr. Recursion until single coord Gr called on Gr.</span>

      <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
      <span class="n">subself</span> <span class="o">=</span> <span class="n">Gr</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

      <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">subself</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">coord</span> <span class="o">=</span> <span class="n">subself</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">subself</span> <span class="o">=</span> <span class="n">subself</span><span class="o">/</span><span class="p">(</span><span class="n">coord</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="nb">list</span><span class="p">):</span>
          <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">coord</span><span class="p">)):</span>
            <span class="n">result</span> <span class="o">+=</span> <span class="p">(</span><span class="n">subself</span><span class="o">.</span><span class="n">to_slices</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">other</span><span class="p">))</span>

        <span class="k">else</span><span class="p">:</span>
          <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">coord</span><span class="p">)):</span>
            <span class="n">result</span> <span class="o">+=</span> <span class="p">(</span><span class="n">subself</span><span class="o">.</span><span class="n">to_slices</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,:],</span><span class="n">other</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">result</span>
        

</div>
<div class="viewcode-block" id="Gr.expand"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Gr.expand">[docs]</a>  <span class="k">def</span> <span class="nf">expand</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">A</span><span class="p">,</span><span class="n">other</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Adds dimensions specified in Gr other at the beginning of array A</span>

<span class="sd">    Args: </span>
<span class="sd">      A: (ndarray) of shape consistent with self</span>
<span class="sd">      other: (Gr) grid to expand over</span>

<span class="sd">    Returns: </span>
<span class="sd">      An ndarray of shape (other/self)*self containing identical copies of A along other/self</span>

<span class="sd">    Example.</span>

<span class="sd">    SAT = P[&#39;DPO&#39;][&#39;A_sat&#39;]</span>
<span class="sd">    SAT.shape is (100,100)</span>
<span class="sd">    W=SAT.grid.expand(SAT[:],depth**2)</span>
<span class="sd">    W.shape is (19,100,100)</span>
<span class="sd">    W contains 19 identical copies (slices) of SAT[:] </span>

<span class="sd">    Note that the other grid is appended on the left side.</span>

<span class="sd">    Example 2.</span>

<span class="sd">    (zt*yt*xt).shape() is (46, 110, 200)</span>

<span class="sd">    A = np.ones((xt**2).shape())</span>

<span class="sd">    K=(xt**2).expand(A,zt*yu*xt  )</span>
<span class="sd">    K.shape is (46, 110, 200)</span>

<span class="sd">    K=(xt**2).expand(A,zt*xt*yt  )</span>
<span class="sd">    K.shape is (46, 110, 200)</span>

<span class="sd">    Warning: method requires Gr argument, do not use coord argument. Instead, for a single coord (e.g.) xt, use xt**2.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c"># only use those coord elements that are in the other gr but not the self gr.</span>
    <span class="n">new_coords</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">other</span><span class="o">/</span><span class="bp">self</span><span class="p">)</span>
    <span class="n">new_coords</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">new_coords</span><span class="p">:</span>
      <span class="c"># initialize L for each coord with the A from argument, or just built below</span>
      <span class="n">L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">A</span><span class="p">],)</span>
      <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">coord</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="c"># grow the dimensions with identical copies of A</span>
        <span class="n">L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">L</span><span class="p">,[</span><span class="n">A</span><span class="p">,],</span><span class="mi">0</span><span class="p">)</span>
      <span class="n">A</span> <span class="o">=</span> <span class="n">L</span> 

    <span class="k">return</span> <span class="n">L</span>



</div>
<div class="viewcode-block" id="Gr.inflate"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Gr.inflate">[docs]</a>  <span class="k">def</span> <span class="nf">inflate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span> <span class="o">=</span> <span class="s">&#39;array&#39;</span><span class="p">,</span> <span class="n">force</span> <span class="o">=</span> <span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Broadcast members onto (self) grid using their cast method and return list of results.</span>

<span class="sd">    This method can return the result in two formats: a list of Field objects or of ndarrays. Default behaviour caches values.</span>

<span class="sd">    Each element in the list corresponds to a Coord member object in the called grid, where the array equals the content of the Coord along the array index corresponding to that Coord, and is constant otherwise.</span>

<span class="sd">    Args:</span>
<span class="sd">      type: (str) desired output type. -&#39;array&#39; in arguments will return a list of arrays. -&#39;Field&#39; in arguments will return a list of fields.</span>
<span class="sd">      force: (Boolean) do not use cached value if True. </span>

<span class="sd">    Returns: </span>
<span class="sd">      A list of arrays or fields of the dimension of the grid being called.</span>
<span class="sd">    </span>

<span class="sd">    For example, a grid defined by (yt,xt) (equal to yt*xt) yields [YT,XT] where YT = yt(yt*xt) and XT = XT(yt*xt). We refer to XT as the inflated version of xt. Here, the Coord object has been called on the grid object: this yields an array defined on the argument grid and constant in all Coord axes other than the calling Coord. The array equals the value of the calling Coord object along that axis.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span>  <span class="ow">not</span><span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s">&#39;inflated&#39;</span><span class="p">))</span> <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">inflated</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">force</span> <span class="o">==</span> <span class="bp">True</span><span class="p">):</span>
      <span class="c"># compute values and store as arrays.</span>
        
        <span class="c"># This yields a list of arrays, corresponding to the inflated Coord objects.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inflated</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">value</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">]</span>
        
    <span class="k">if</span> <span class="nb">type</span> <span class="o">==</span> <span class="s">&#39;array&#39;</span><span class="p">:</span>
      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">inflated</span>
    <span class="k">elif</span> <span class="nb">type</span> <span class="o">==</span><span class="s">&#39;Field&#39;</span><span class="p">:</span>
      <span class="k">return</span> <span class="p">[</span><span class="n">Field</span><span class="p">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">&#39;inflated_&#39;</span><span class="o">+</span><span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="p">,</span><span class="n">value</span> <span class="o">=</span> <span class="n">e</span><span class="p">,</span> <span class="n">grid</span> <span class="o">=</span> <span class="bp">self</span> <span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inflated</span> <span class="p">)</span> <span class="p">]</span>

</div>
  <span class="k">def</span> <span class="nf">_smart_interp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">A</span><span class="p">,</span><span class="n">other</span><span class="p">,</span> <span class="n">method</span> <span class="o">=</span> <span class="s">&#39;linear&#39;</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Smart interpolation of array A, using griddata interpolation only along Coord axes that are not equal (but must be equivalent).</span>

<span class="sd">    !!!Arguments must be in the right order: order(left) = order(right)!!!</span>

<span class="sd">    Args: </span>
<span class="sd">      A: (ndarray) of the shape corresponding to self.</span>
<span class="sd">      other: (Gr) destination grid onto which to interpolate.</span>
<span class="sd">      method: (str) interpolation method to use.</span>

<span class="sd">    Returns: </span>
<span class="sd">      An array containing A interpolated from the self grid to the destination grid.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<span class="c"># belongs to grid object.</span>

<span class="c"># it is the left element. Coord elements of self and other (grids) may be up to equivalence, but need to be in same order. The common (equal) elements will be stored in L</span>


    <span class="n">L</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">it</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="k">if</span> <span class="n">it</span> <span class="o">==</span> <span class="n">other</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
        <span class="n">L</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">it</span><span class="o">.</span><span class="n">is_equiv</span><span class="p">(</span><span class="n">other</span><span class="p">[</span><span class="n">i</span><span class="p">])):</span>
          <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;Ordered equivalence wrong, aborting with None!&quot;</span><span class="p">)</span>
          <span class="k">return</span>

    <span class="k">if</span> <span class="n">L</span><span class="p">:</span>
      <span class="c"># In this case, the source and destination grid have Coord elements in common. This means we need to interpolate only along the axes they do not have in common.</span>

      <span class="c"># check first whether source and destination grids are equal, in which case we can simply return A.</span>
      <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">L</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">A</span>

      <span class="c"># In this case, source and dest grids are not equal, and contain both equal and equivalent-only Coord elements:</span>
      <span class="n">L</span> <span class="o">=</span> <span class="n">Gr</span><span class="p">(</span><span class="n">L</span><span class="p">);</span>
      
      <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c"># Take slices into a list</span>
      <span class="n">B</span><span class="o">=</span><span class="bp">self</span><span class="p">(</span><span class="n">L</span><span class="p">)(</span><span class="n">A</span><span class="p">)</span>      
  
<span class="c">#    B is a (often long) list containing the slices to be interpolated.</span>
<span class="c"># array(B) will yield shape (len(coord1)*len(coord2)*...  , shape(array)) for coordi in L and array the slices to be interpolated</span>
<span class="c"># This should be reshaped to list(L.shape()) + shape(array)</span>
<span class="c"># where shape(array) = (self/L).shape()</span>

      <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">b</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">B</span><span class="p">):</span>
      <span class="c"># perform interpolation on array b from self/L to other/L on each slice.</span>
        <span class="n">srcgrid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">/</span><span class="n">L</span>
        <span class="n">destgrid</span> <span class="o">=</span> <span class="n">other</span><span class="o">/</span><span class="n">L</span>

        <span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">srcgrid</span><span class="o">.</span><span class="n">_interp</span><span class="p">(</span><span class="n">destgrid</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
     
<span class="c"># B has now been interpolated.</span>
      <span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>

<span class="c"># some commented out diagnostic prints</span>
<span class="c">#      print L</span>
<span class="c">#      print self/L</span>

<span class="c">#      print list(L.shape())</span>
<span class="c">#      print list((self/L).shape())</span>

<span class="c">#      print B.shape</span>

      <span class="n">B</span> <span class="o">=</span> <span class="n">B</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">shape</span><span class="p">())</span> <span class="o">+</span> <span class="nb">list</span><span class="p">((</span><span class="n">other</span><span class="o">/</span><span class="n">L</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span><span class="p">())</span> <span class="p">)</span>

      <span class="n">pm</span> <span class="o">=</span> <span class="p">(</span><span class="n">L</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">/</span><span class="n">L</span><span class="p">))</span><span class="o">.</span><span class="n">perm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verbose</span> <span class="o">=</span> <span class="bp">False</span><span class="p">)</span>
      <span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">B</span><span class="p">,</span><span class="n">pm</span><span class="p">)</span>

      <span class="k">return</span> <span class="n">B</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_interp</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">method</span> <span class="o">=</span> <span class="n">method</span><span class="p">)</span>

<span class="c"># methods belong to Gr </span>


<span class="c"># it is assumed that self.is_equiv(other) is True and that the shape of array A corresponds to the lenghts of the Coord elements of self (and therefore other).</span>

  <span class="nd">@check_equiv</span>
  <span class="k">def</span> <span class="nf">_interp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">,</span><span class="n">A</span><span class="p">,</span> <span class="n">method</span> <span class="o">=</span> <span class="s">&#39;linear&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Interpolation function calling griddata function.</span>

<span class="sd">    Args:</span>
<span class="sd">      other: (Gr) target grid (must be equivalent to self)</span>
<span class="sd">      A: (ndarray) array to be interpolated.</span>
<span class="sd">      method: (str) interpolation method (fed to griddata).</span>

<span class="sd">    Returns:</span>
<span class="sd">      ndarray: the interpolated array.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
    
      <span class="n">L</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">value</span>
      <span class="n">R</span> <span class="o">=</span> <span class="n">other</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">value</span>

      <span class="k">if</span> <span class="n">L</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">&lt;</span><span class="n">L</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
        <span class="c"># in case it&#39;s a negative scale, as in depth</span>
        <span class="n">L</span> <span class="o">=</span> <span class="o">-</span><span class="n">L</span>
        <span class="n">R</span> <span class="o">=</span> <span class="o">-</span><span class="n">R</span>
       
      <span class="n">IA</span> <span class="o">=</span> <span class="n">griddata</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">A</span><span class="p">,</span><span class="n">R</span><span class="p">,</span> <span class="n">method</span> <span class="o">=</span> <span class="n">method</span><span class="p">)</span>
      
    
      <span class="k">return</span> <span class="n">IA</span>
     
    <span class="k">else</span><span class="p">:</span>
  
      <span class="n">L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span> <span class="n">e</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">inflate</span><span class="p">()</span> <span class="p">])</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
      <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span> <span class="n">e</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">inflate</span><span class="p">()</span> <span class="p">])</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>  

      <span class="n">IA</span> <span class="o">=</span> <span class="n">griddata</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">A</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span><span class="n">R</span><span class="p">,</span> <span class="n">method</span> <span class="o">=</span> <span class="n">method</span><span class="p">)</span>
      <span class="n">IA</span><span class="o">=</span><span class="n">IA</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">shape</span><span class="p">())</span>
    
      <span class="k">return</span> <span class="n">IA</span>



  <span class="k">def</span> <span class="nf">__div__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Division of grids. E.g. xt*yt*zt/yt = xt*zt</span>


<span class="sd">    Returns:</span>
<span class="sd">      Resulting Gr object </span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">Coord</span><span class="p">):</span>
      <span class="n">other</span> <span class="o">=</span> <span class="n">Gr</span><span class="p">((</span><span class="n">other</span><span class="p">,))</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">Ax</span><span class="p">):</span>
      <span class="n">other</span> <span class="o">=</span> <span class="n">AxGr</span><span class="p">((</span><span class="n">other</span><span class="p">,))</span>

    <span class="c"># From here, we know other is a Gr</span>

    <span class="n">result</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
      <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">eq_in</span><span class="p">(</span><span class="n">it</span><span class="p">):</span>
        <span class="n">result</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Gr</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>


  <span class="k">def</span> <span class="nf">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Multiplication of grids.</span>

<span class="sd">    At the moment, xu*zt*xt*yt = (xu,zt,yt,) whereas xu*(zt*xt*yt) = (zt,xu,yt,)</span>

<span class="sd">    Multiplication can take other arguments than just grids. If a Field is provided as right multiplicant, the Field is summed over the left multiplicant grid, weighted with grid cell widths (the equivalence of integration over the grid space). If the right multiplicant is a Coord object, it is converted to a single-element grid (Gr) object before multiplication. </span>


<span class="sd">    Raises:</span>
<span class="sd">      Exception, TypeError.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
      <span class="c"># multiplication with an array yields a Field if the sizes match.</span>
      <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">()</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Field</span><span class="p">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">&#39;&#39;</span><span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="n">other</span><span class="p">,</span> <span class="n">grid</span> <span class="o">=</span> <span class="bp">self</span><span class="p">)</span>
      <span class="k">else</span><span class="p">:</span> 
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;Gr shape error </span><span class="si">%s</span><span class="s">*</span><span class="si">%s</span><span class="s"> with Gr </span><span class="si">%s</span><span class="s">: provide correct shape np array.&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span> <span class="p">)</span>
        <span class="k">return</span>   
 
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">Field</span><span class="p">):</span>
      <span class="sd">&quot;&quot;&quot; Gr multiplication with Field is a shorthand for vsum method.</span>
<span class="sd">      &quot;&quot;&quot;</span>
      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">vsum</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>


    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">Coord</span><span class="p">):</span>
      <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s">&#39;scalar&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">eq_in</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
          <span class="k">return</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="k">return</span> <span class="n">Gr</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="n">other</span><span class="p">]</span> <span class="p">)</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">VField</span><span class="p">):</span>
      <span class="c"># multiplication of grid object with vector Field.</span>
      <span class="c"># this commutes:</span>
      <span class="k">return</span> <span class="n">other</span><span class="o">*</span><span class="bp">self</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">Ax</span><span class="p">):</span>
      <span class="c"># multiplication between Gr and Ax objects is commutative</span>
      <span class="k">return</span> <span class="n">other</span><span class="o">*</span><span class="bp">self</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">Gr</span><span class="p">):</span>

      <span class="k">return</span> <span class="nb">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">:</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span> <span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">other</span><span class="p">))</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">AxGr</span><span class="p">):</span>
      <span class="c"># --&gt; multiplication between Gr and AxGr objects DOES NOT commute: in agreement with general rules, result retains Coord element order of left multiplicant.</span>
      
      <span class="n">L</span> <span class="o">=</span> <span class="p">[]</span>

      <span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">eq_in</span><span class="p">(</span><span class="n">it</span><span class="p">):</span>
          <span class="n">L</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>

      <span class="k">return</span> <span class="n">Gr</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>    


    <span class="k">else</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;Gr type error </span><span class="si">%s</span><span class="s">*</span><span class="si">%s</span><span class="s"> with Gr </span><span class="si">%s</span><span class="s"> (grid): provide Field, Gr or Coord object or np array as right multiplicant.&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span> <span class="p">)</span>


<span class="c"># belongs to grid </span>

<div class="viewcode-block" id="Gr.shape"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Gr.shape">[docs]</a>  <span class="k">def</span> <span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Determines shape of grid by calculating Coord member lengths.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sh</span> <span class="o">=</span> <span class="p">[];</span>

    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
      <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">value</span><span class="p">,</span><span class="nb">str</span><span class="p">))</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">value</span><span class="p">,</span><span class="nb">unicode</span><span class="p">)):</span>
        <span class="n">sh</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="n">sh</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">sh</span><span class="p">)</span>
 </div>
  <span class="nd">@att2members</span>
<div class="viewcode-block" id="Gr.dual"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Gr.dual">[docs]</a>  <span class="k">def</span> <span class="nf">dual</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">pass</span>
</div>
<div class="viewcode-block" id="Gr.ones"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Gr.ones">[docs]</a>  <span class="k">def</span> <span class="nf">ones</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns Field with value np.nones of shape self.shape. </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">Field</span><span class="p">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">&#39;ones&#39;</span><span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">()</span> <span class="p">)</span> <span class="p">,</span><span class="n">grid</span> <span class="o">=</span> <span class="bp">self</span> <span class="p">)</span>

</div>
<div class="viewcode-block" id="Gr.vsum"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Gr.vsum">[docs]</a>  <span class="k">def</span> <span class="nf">vsum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">F</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Sum weighted with Coord grid cell widths (integration) over self grid. </span>

<span class="sd">    Args:</span>
<span class="sd">      F: (Field) to weight-sum over.</span>
<span class="sd">      </span>
<span class="sd">    Returns:</span>
<span class="sd">      Smaller dimensional Field, or float if result dim 0, containing the result.</span>


<span class="sd">    The returned Field has grid made up of remaining Coord objects or a float. E.g. if F.grid == (&#39;zt&#39;,&#39;yt&#39;,&#39;xt&#39;), (xt*yt).vsum(F) yields a Field defined on grid (&#39;zt&#39;,).</span>

<span class="sd">    </span>
<span class="sd">    Note that when Coord elements with direction attribute &#39;X&#39; and &#39;Y&#39; both appear in the Gr object, vsum will check whether the &#39;X&#39; Coord appears after the &#39;Y&#39; Coord. If so, they will be interchanged when performing the calculation as otherwise no y-coord is available when the x grid cell width is required. This is a small detail.</span>
<span class="sd">    &quot;&quot;&quot;</span>


    <span class="c"># If X and Y directions both occur in the averaging grid, need to make sure X appears before Y because X-direction Coord grid cell width depends on Y-direction Coord.</span>

    <span class="n">dirs</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span><span class="o">.</span><span class="n">direction</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">]</span>

    <span class="k">if</span> <span class="p">(</span><span class="s">&#39;X&#39;</span> <span class="ow">in</span> <span class="n">dirs</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="s">&#39;Y&#39;</span> <span class="ow">in</span> <span class="n">dirs</span><span class="p">):</span>
      <span class="n">i_X</span> <span class="o">=</span> <span class="n">dirs</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s">&#39;X&#39;</span><span class="p">)</span> 
      <span class="n">i_Y</span> <span class="o">=</span> <span class="n">dirs</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s">&#39;Y&#39;</span><span class="p">)</span>

      <span class="k">if</span> <span class="n">i_X</span> <span class="o">&gt;</span> <span class="n">i_Y</span><span class="p">:</span>
        <span class="n">new_gr</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>      
        <span class="n">tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">i_X</span><span class="p">]</span>
        <span class="n">new_gr</span><span class="p">[</span><span class="n">i_X</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">i_Y</span><span class="p">]</span>
        <span class="n">new_gr</span><span class="p">[</span><span class="n">i_Y</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span>
        <span class="k">del</span> <span class="n">tmp</span>
      
        <span class="k">return</span> <span class="nb">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">:</span> <span class="n">y</span><span class="o">.</span><span class="n">vsum</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="p">[</span><span class="n">new_gr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">vsum</span><span class="p">(</span><span class="n">F</span><span class="p">)]</span> <span class="o">+</span> <span class="n">new_gr</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="p">)</span>


    <span class="c"># Apply Coord vsum method of Coord objects in self to Field argument F, from left to right:</span>
    <span class="k">return</span> <span class="nb">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">:</span> <span class="n">y</span><span class="o">.</span><span class="n">vsum</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="p">[</span><span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">vsum</span><span class="p">(</span><span class="n">F</span><span class="p">)]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span> <span class="p">)</span>
</div>
<div class="viewcode-block" id="Gr.mean"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Gr.mean">[docs]</a>  <span class="k">def</span> <span class="nf">mean</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">F</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Determines mean of Field argument F weighted with grid cell width, returning Field.</span>

<span class="sd">    Uses vsum</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">vsum</span><span class="p">(</span><span class="n">F</span><span class="p">)</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">vsum</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">ones</span><span class="p">())</span>

<span class="c"># --&gt; belongs to Gr </span>

</div>
<div class="viewcode-block" id="Gr.der"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Gr.der">[docs]</a>  <span class="k">def</span> <span class="nf">der</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">crd</span><span class="p">,</span><span class="n">F</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Method of grid object. Often the wider context of the grid needs to be known to take the derivative along a Coord, hence a Gr method.</span>

<span class="sd">    Finds args to feed Coord member der methods, which is called on F.</span>

<span class="sd">    Args:</span>
<span class="sd">      crd: (Coord) along which to differentiate (e.g. latitude)</span>
<span class="sd">      F: (Field) to differentiate (e.g. temperature)</span>

<span class="sd">    Returns:</span>
<span class="sd">      Field containing the result.</span>

<span class="sd">    Raises:</span>
<span class="sd">      ValueError: when crd not in (self) grid.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">coord_types</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;x_coord&#39;</span><span class="p">:</span><span class="n">XCoord</span><span class="p">,</span><span class="s">&#39;y_coord&#39;</span><span class="p">:</span><span class="n">YCoord</span><span class="p">,</span><span class="s">&#39;z_coord&#39;</span><span class="p">:</span><span class="n">Coord</span><span class="p">}</span>
 
    <span class="k">if</span> <span class="n">crd</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
      <span class="n">C</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_args_coord</span><span class="p">(</span><span class="n">method_name</span> <span class="o">=</span> <span class="s">&#39;der&#39;</span><span class="p">,</span> <span class="n">coord_types</span> <span class="o">=</span> <span class="n">coord_types</span><span class="p">)</span>    
      <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">crd</span><span class="p">)</span>  

      <span class="k">return</span> <span class="n">crd</span><span class="o">.</span><span class="n">der</span><span class="p">(</span><span class="n">F</span><span class="p">,</span><span class="o">*</span><span class="n">C</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

    <span class="k">else</span><span class="p">:</span>

      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Gr derivative method der: </span><span class="si">%s</span><span class="s"> must be in grid </span><span class="si">%s</span><span class="s">&#39;</span><span class="o">%</span> <span class="p">(</span><span class="n">crd</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span> <span class="p">)</span>

    </div>
<div class="viewcode-block" id="Gr.vol"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Gr.vol">[docs]</a>  <span class="k">def</span> <span class="nf">vol</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Determines volumes (areas/ lengths) of grid members, returns Field.</span>

<span class="sd">    Calls Coord member d method. </span>

<span class="sd">    Returns:</span>
<span class="sd">      Field defined on same (self) grid (therefore of same dimension) containing value ndarray of individual cell volumes.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># Depends on the use of {x,y,z}_coord convention in arguments to d() method of classes derived from Coord  (e.g. XCoord takes y_coord argument).</span>

    <span class="n">coord_types</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;x_coord&#39;</span><span class="p">:</span><span class="n">XCoord</span><span class="p">,</span><span class="s">&#39;y_coord&#39;</span><span class="p">:</span><span class="n">YCoord</span><span class="p">,</span><span class="s">&#39;z_coord&#39;</span><span class="p">:</span><span class="n">Coord</span><span class="p">}</span>

    <span class="c"># obtain arguments to Coord.d method from the grid (self) context:</span>
    <span class="n">C</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_args_coord</span><span class="p">(</span><span class="n">coord_types</span><span class="p">)</span>

   
    <span class="c"># Use splat operator * to pass coords list on as argument</span>
    <span class="c"># cycle through coords, the list of Coord elements required as arguments for each Coord, </span>

    <span class="k">return</span> <span class="nb">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="p">:</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">,</span> <span class="p">[</span><span class="n">coord</span><span class="o">.</span><span class="n">d</span><span class="p">(</span><span class="o">*</span><span class="n">C</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">coord</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">)]</span>  <span class="p">)</span>     
  </div>
  <span class="k">def</span> <span class="nf">_find_args_coord</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">coord_types</span><span class="p">,</span> <span class="n">method_name</span> <span class="o">=</span> <span class="s">&#39;d&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find arguments to feed method (default d) for each Coord member.</span>

<span class="sd">    Needed to determine what other Coord objects to feed the overriden Coord.d method. For example, xt.d(F,yt) as opposed to zt.d(). Uses inspect on method. Used by der and vol.</span>

<span class="sd">    Because this is a Gr method, the grid provides the context in which to find the argument Coord. Therefore, Gr is natural for this method.</span>

<span class="sd">    Args:</span>
<span class="sd">      coord_types: (dictionary of str:Coord/ Coord-derived) Coord types to choose from.</span>
<span class="sd">      method_name: (str) method name to find arguments for.</span>

<span class="sd">    Returns: </span>
<span class="sd">      List of arguments to feed to method, each entry corresponding to a Coord member (of self).</span>

<span class="sd">    Examples:</span>

<span class="sd">    &gt;&gt;&gt; (latitude*longitude)._find_args_coord({&#39;x_coord&#39;:sg.XCoord,&#39;y_coord&#39;:sg.YCoord,&#39;z_coord&#39;:sg.Coord})</span>
<span class="sd">    [[], [latitude]]</span>
<span class="sd">    &gt;&gt;&gt; (longitude*latitude)._find_args_coord({&#39;x_coord&#39;:sg.XCoord,&#39;y_coord&#39;:sg.YCoord,&#39;z_coord&#39;:sg.Coord})</span>
<span class="sd">    [[latitude], []]</span>

<span class="sd">    This is because longitude.d takes a YCoord argument, and latitude doesn&#39;t.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">coord_store</span> <span class="o">=</span> <span class="p">{}</span>
<span class="c"># Determine the type of each Coord in self</span>
    <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
      <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">coord_types</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">coord_types</span><span class="p">[</span><span class="n">i</span><span class="p">]):</span>
          <span class="n">coord_store</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span>

    <span class="n">L</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
      <span class="c"># get the Coord-derived objects that need to be passed to each d method of Coord (e.g. xt.d(yt))</span>
      <span class="k">exec</span> <span class="s">&#39;method = r.&#39;</span> <span class="o">+</span> <span class="n">method_name</span>
      <span class="n">coords</span> <span class="o">=</span> <span class="p">[</span><span class="n">coord_store</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">inspect</span><span class="o">.</span><span class="n">getargspec</span><span class="p">(</span><span class="n">method</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">coord_types</span><span class="o">.</span><span class="n">keys</span><span class="p">()]</span>

      <span class="n">L</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>       

    <span class="k">return</span> <span class="n">L</span>

<span class="c"># ---------------- end Gr  ----------------</span>





<span class="c"># -------------- Field  --------------------------</span>


  </div>
<div class="viewcode-block" id="Field"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Field">[docs]</a><span class="k">class</span> <span class="nc">Field</span><span class="p">(</span><span class="n">Valued</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Represents a dataset defined on a grid. </span>

<span class="sd">  Field objects contain a grid (a Gr object) attribute and a ndarray value attribute of data defined on that grid.</span>

<span class="sd">  The call method allows fields to act as function defined on grid objects.</span>
<span class="sd">  For a 2D scalar corresponding to Field T, say defined on grid yt*xt, T(dy*dx) yields a 2D array of the scalar values.</span>

<span class="sd">  If Field T is naturally defined on grid yt*xt, then T(zt*yt*xt) yields a 3D array b such that b[k,:,:] = T(yt*xt) for all possible k.</span>


<span class="sd">  If g is a Gr (grid) or Coord object, left or right multiplication of a Field  object F with Gr Coord results in the grid-cell width weighted summing of the Field over the coords in the multiplicant g (integration, via g.vsum method), resulting in a smaller dimension Field.</span>

<span class="sd">  If g is a Coord object, g.der(F) yields the derivative of F along g. g.vcumsum(F) yields the grid cell width-weight cumulative sum of F over g.</span>

<span class="sd">  Shortcuts: if g is a Coord object, g^F yields the derivative of F along g (via g.der method). g|F yields the grid cell width-weight cumulative sum of F over g (primitive, via g.vcumsum).</span>

<span class="sd">  two fields F1, F2 are considered weakly the same, F1.weaksame(F2) yields True, when their name, value (an numpy array) and Gr (grid) attribute are equal, unless they contain nan values.</span>

<span class="sd">  NOTE: multiplication works a bit different from addition at the moment. Addition will go ahead even when coords in the grids are differently named (or have other non-value attributes differ) as long as the value (the coord points) are the same: then the (left and right) coords are considered equal. Multiplication treats them as different coords in this case.</span>
<span class="sd">  &quot;&quot;&quot;</span>

  <span class="k">global</span> <span class="n">ID</span>

  <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>

  <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">name</span><span class="p">,</span><span class="n">value</span><span class="p">,</span><span class="n">grid</span><span class="p">,</span><span class="n">units</span> <span class="o">=</span> <span class="s">&#39;?&#39;</span><span class="p">,</span><span class="n">direction</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">strict_v</span> <span class="o">=</span> <span class="n">strict_vector</span><span class="p">,</span><span class="n">long_name</span><span class="o">=</span><span class="s">&#39;?&#39;</span><span class="p">,</span><span class="n">metadata</span><span class="o">=</span><span class="p">{}</span> <span class="p">,</span> <span class="n">squeezed_dims</span> <span class="o">=</span><span class="n">Gr</span><span class="p">(</span> <span class="p">()</span>  <span class="p">)):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Initialise a Field. </span>

<span class="sd">    Args: </span>
<span class="sd">      name: (str) the name of the Field (e.g. temperature). Displayed in console</span>
<span class="sd">      value:(ndarray) the numpy array containing the Field data</span>
<span class="sd">      grid: (Gr) the grid Gr object associated with the data</span>
<span class="sd">      units: (str) data units (if known)</span>
<span class="sd">      direction: (Ax) scalar or, if vector Field component, axis direction (e.g. X)</span>
<span class="sd">      strict_v: (boolean) if True (default), addition of directional fields leads to vector fields.</span>
<span class="sd">      long_name: (str) description of Field, corresponds to long_name Netcdf metadata.</span>

<span class="sd">    Returns:</span>
<span class="sd">      the created Field on success, None on failure.</span>

<span class="sd">    Raises:</span>
<span class="sd">      Exception if inconsistencies found (e.g. grid does not match ndarray value).</span>
<span class="sd">    &quot;&quot;&quot;</span>


    <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">direction</span><span class="p">):</span>
      <span class="n">direction</span> <span class="o">=</span> <span class="n">ID</span><span class="p">()</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
      <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span><span class="n">Gr</span><span class="p">):</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">()</span>

        <span class="c"># Check for shape consistency between grid and value to avoid creation of inconsistent Field objects:</span>
        <span class="k">if</span> <span class="n">shape</span> <span class="o">==</span> <span class="n">value</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
          <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
          <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>
          <span class="bp">self</span><span class="o">.</span><span class="n">grid</span> <span class="o">=</span> <span class="n">grid</span>
          <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">shape</span>
          <span class="bp">self</span><span class="o">.</span><span class="n">units</span> <span class="o">=</span> <span class="n">units</span> 
          <span class="bp">self</span><span class="o">.</span><span class="n">direction</span> <span class="o">=</span> <span class="n">direction</span> 
          <span class="bp">self</span><span class="o">.</span><span class="n">strict_v</span> <span class="o">=</span> <span class="n">strict_v</span>
          <span class="bp">self</span><span class="o">.</span><span class="n">long_name</span> <span class="o">=</span> <span class="n">long_name</span>
          <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span> <span class="o">=</span> <span class="n">metadata</span>
          <span class="bp">self</span><span class="o">.</span><span class="n">nbytes</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">nbytes</span>

          <span class="bp">self</span><span class="o">.</span><span class="n">squeezed_dims</span> <span class="o">=</span> <span class="n">squeezed_dims</span>

        <span class="k">else</span><span class="p">:</span>

          <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;Error in Field creation </span><span class="si">%s</span><span class="s"> using grid </span><span class="si">%s</span><span class="s">: value array argument must have same shape as grid argument! Gr shape </span><span class="si">%s</span><span class="s"> while Field value shape </span><span class="si">%s</span><span class="s"> &#39;</span> <span class="o">%</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="n">grid</span><span class="p">,</span><span class="nb">str</span><span class="p">(</span><span class="n">shape</span><span class="p">),</span><span class="nb">str</span><span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="p">)</span> <span class="p">)</span>
          <span class="k">return</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;Error in Field creation </span><span class="si">%s</span><span class="s">: argument grid </span><span class="si">%s</span><span class="s"> must be a Gr object!&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">grid</span><span class="p">))</span>
        <span class="k">return</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;Error in Field creation </span><span class="si">%s</span><span class="s">: argument value must be an ndarray!&#39;</span> <span class="o">%</span> <span class="n">name</span> <span class="p">)</span>
      <span class="k">return</span>

<div class="viewcode-block" id="Field.weaksame"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Field.weaksame">[docs]</a>  <span class="k">def</span> <span class="nf">weaksame</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Tests whether fields contain equal name, value and grid. At the moment, if the value contains nan, this function will return false.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">name</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">,</span><span class="n">other</span><span class="o">.</span><span class="n">value</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">weaksame</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">grid</span><span class="p">):</span>
      <span class="k">return</span> <span class="bp">True</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">return</span> <span class="bp">False</span>

</div>
  <span class="k">def</span> <span class="nf">_cdf_insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">file_handle</span><span class="p">,</span> <span class="n">insert_dual</span> <span class="o">=</span> <span class="bp">True</span><span class="p">,</span> <span class="n">force_squeeze</span> <span class="o">=</span> <span class="bp">False</span><span class="p">,</span> <span class="n">miss_default</span> <span class="o">=</span> <span class="mf">9.96921e+36</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Inserts Field into Netcdf file on disk.</span>

<span class="sd">    Writes Field to already opened file referred to with file_handle argument, along with the Coord members of the grid. Also inserts their dual Coord objects (edges) depending on flag.</span>

<span class="sd">    Args:</span>
<span class="sd">      file_handle: the file handle of the opened file.</span>
<span class="sd">      insert_dual: (Boolean) insert the dual Coord objects as well if True</span>
<span class="sd">      force_squeeze: (Boolean) do not call unsqueeze method if True</span>
<span class="sd">      miss_default: (float) default for missing values.</span>
<span class="sd">    &quot;&quot;&quot;</span>


    <span class="c"># handle the squeeze dimensions</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">force_squeeze</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">squeezed_dims</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">unsqueeze</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_cdf_insert</span><span class="p">(</span><span class="n">file_handle</span> <span class="o">=</span> <span class="n">file_handle</span><span class="p">,</span> <span class="n">insert_dual</span> <span class="o">=</span> <span class="n">insert_dual</span><span class="p">)</span>    

    <span class="c"># insert the coords in own grid</span>
    <span class="k">for</span> <span class="n">crd</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">:</span>
      <span class="k">if</span> <span class="ow">not</span> <span class="n">crd</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="n">file_handle</span><span class="o">.</span><span class="n">variables</span><span class="p">:</span>
        <span class="n">crd</span><span class="o">.</span><span class="n">_cdf_insert</span><span class="p">(</span><span class="n">file_handle</span><span class="p">)</span>
    
        <span class="k">if</span> <span class="n">insert_dual</span> <span class="ow">and</span> <span class="p">(</span><span class="n">crd</span><span class="o">.</span><span class="n">dual</span> <span class="o">!=</span> <span class="n">crd</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">crd</span><span class="o">.</span><span class="n">dual</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="n">file_handle</span><span class="o">.</span><span class="n">variables</span><span class="p">):</span>
          <span class="n">crd</span><span class="o">.</span><span class="n">dual</span><span class="o">.</span><span class="n">_cdf_insert</span><span class="p">(</span><span class="n">file_handle</span><span class="p">)</span>         

    <span class="c"># This could bloat memory. Redo in a new way.</span>
    <span class="n">value</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>

    <span class="n">miss_val</span> <span class="o">=</span> <span class="n">miss_default</span>
    <span class="k">if</span> <span class="s">&#39;FillValue&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">:</span>
      <span class="n">miss_val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s">&#39;FillValue&#39;</span><span class="p">]</span>
    <span class="k">elif</span> <span class="s">&#39;missing_value&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">:</span>
      <span class="n">miss_val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s">&#39;missing_value&#39;</span><span class="p">]</span>

    <span class="k">try</span><span class="p">:</span>
      <span class="n">value</span><span class="p">[</span>  <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span> <span class="n">value</span>  <span class="p">)</span> <span class="o">==</span> <span class="bp">True</span>   <span class="p">]</span> <span class="o">=</span> <span class="n">miss_val</span>
      
    <span class="k">except</span><span class="p">:</span>
      <span class="k">try</span><span class="p">:</span>
        <span class="n">value</span><span class="p">[</span>  <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span> <span class="n">value</span>  <span class="p">)</span> <span class="o">==</span> <span class="bp">True</span>   <span class="p">]</span> <span class="o">=</span> <span class="n">miss_default</span>

      <span class="k">except</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&#39;Could not set missing value for Field </span><span class="si">%s</span><span class="s">.&#39;</span><span class="o">%</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

    <span class="c"># Create the actual variable corresponding to Field.value</span>
    <span class="n">var_cdf</span> <span class="o">=</span> <span class="n">file_handle</span><span class="o">.</span><span class="n">createVariable</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">char</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span> <span class="p">[</span><span class="n">crd</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">crd</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">]</span> <span class="p">)</span>   <span class="p">)</span>
    <span class="n">var_cdf</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">value</span>


    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">:</span>
      <span class="nb">setattr</span><span class="p">(</span><span class="n">var_cdf</span><span class="p">,</span><span class="n">k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> 

    <span class="k">return</span> <span class="n">file_handle</span>


<div class="viewcode-block" id="Field.write"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Field.write">[docs]</a>  <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">name</span> <span class="o">=</span> <span class="bp">None</span> <span class="p">,</span> <span class="n">history</span> <span class="o">=</span> <span class="s">&#39;Created from Spacegrids &#39;</span> <span class="p">,</span> <span class="n">insert_dual</span> <span class="o">=</span> <span class="bp">True</span><span class="p">,</span> <span class="n">force_squeeze</span> <span class="o">=</span> <span class="bp">False</span> <span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Write method of Field .</span>

<span class="sd">    Creates Netcdf file and writes Field to it, along with its Coord objects.</span>

<span class="sd">    Fields are unsqueezed before saving, along Coord objects of single length to be saved as well (override with force_squeeze = True).</span>

<span class="sd">    If path and name are not specified, the file will be located in the working directory.</span>
<span class="sd">    If only name is specified, the file will be in the wd under that name</span>
<span class="sd">    If path is specified, the wd is replaced by the path in the above 2 scenarios.</span>

<span class="sd">    insert_dual determines whether the edges of a the Coord objects are saved as well (the default).</span>


<span class="sd">    Args:</span>
<span class="sd">      path: (str) path to the directory containing the file.</span>
<span class="sd">      name: (str) filename, to be joined with path.</span>
<span class="sd">      history: (str) description of file.</span>
<span class="sd">      insert_dual: (Boolean) insert the dual Coord objects as well if True</span>
<span class="sd">      force_squeeze: (Boolean) do not call unsqueeze method if True</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
      <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;.&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&#39;nc&#39;</span><span class="p">,</span><span class="s">&#39;cdf&#39;</span><span class="p">]:</span>
      <span class="n">name</span> <span class="o">=</span> <span class="n">name</span> <span class="o">+</span><span class="s">&#39;.nc&#39;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">path</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
      <span class="n">name</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span> <span class="n">path</span> <span class="p">,</span> <span class="n">name</span> <span class="p">)</span> 
   
    

    <span class="k">print</span> <span class="s">&#39;Writing Field to file </span><span class="si">%s</span><span class="s">&#39;</span><span class="o">%</span><span class="n">name</span>
    <span class="k">try</span><span class="p">:</span>
      <span class="n">file_handle</span> <span class="o">=</span> <span class="n">netcdf_file</span><span class="p">(</span><span class="n">name</span> <span class="p">,</span> <span class="s">&#39;w&#39;</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">IOError</span><span class="p">:</span>
      <span class="k">print</span> <span class="s">&#39;Cannot write &#39;</span><span class="p">,</span> <span class="n">name</span>
    <span class="k">else</span><span class="p">:</span>

      <span class="n">file_handle</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cdf_insert</span><span class="p">(</span><span class="n">file_handle</span><span class="p">,</span> <span class="n">insert_dual</span> <span class="o">=</span> <span class="n">insert_dual</span> <span class="p">,</span> <span class="n">force_squeeze</span> <span class="o">=</span> <span class="n">force_squeeze</span><span class="p">)</span>

      <span class="n">file_handle</span><span class="o">.</span><span class="n">history</span> <span class="o">=</span> <span class="n">history</span> <span class="o">+</span> <span class="s">&#39;</span><span class="si">%s</span><span class="s">&#39;</span><span class="o">%</span><span class="nb">str</span><span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">())</span>
 
<span class="c">#    var_cdf.units = self.units</span>

      <span class="n">file_handle</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Field.cat"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Field.cat">[docs]</a>  <span class="k">def</span> <span class="nf">cat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">,</span><span class="n">ax</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">name_suffix</span> <span class="o">=</span> <span class="s">&#39;_cat&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Concatenate with another Field along specified axis. </span>

<span class="sd">    If ax is None, concatenation takes place along the first encountered common axis with non-equal values.</span>
<span class="sd">    Grids must be orient along same axes and in same axis order.</span>

<span class="sd">    Concatenation along direction with same Coord values for both fields leads to the right (other) Field being returned (don&#39;t use this).</span>

<span class="sd">    Args:</span>
<span class="sd">      other: (Field) to concatenate with</span>
<span class="sd">      ax: (Ax) axis to concatenate along.</span>
<span class="sd">      name_suffix: (str) suffix to use in new name.</span>

<span class="sd">    Returns:</span>
<span class="sd">      the concatenated Field.</span>

<span class="sd">    Raises:</span>
<span class="sd">      ValueError: if Field objects not on grids pointing in same directions,  pieces not of consistent dimensions.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c"># if no Ax object is given, an Ax is chosen where the grid Coord elements are not array equal.</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span><span class="n">Coord</span><span class="p">):</span>
      <span class="n">ax</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">axis</span>

    <span class="n">self_axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">axis</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">self_axis</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">axis</span><span class="p">():</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Error: provide fields defined on the same grid directions.&#39;</span><span class="p">)</span>


    <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
      
      <span class="n">i_ax</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">grid</span><span class="p">))</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
      <span class="n">ax</span> <span class="o">=</span> <span class="n">self_axis</span><span class="p">[</span><span class="n">i_ax</span><span class="p">]</span>
    
    <span class="n">cat_coord_self</span> <span class="o">=</span> <span class="n">ax</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span>
    
    <span class="c"># Two checks</span>
    <span class="k">if</span> <span class="n">cat_coord_self</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
      <span class="c"># in this case concat is done along an axis not in the self grid</span>
 
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Axis not in grid.&#39;</span><span class="p">)</span>


    <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">/</span><span class="n">ax</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span><span class="p">()</span> <span class="o">!=</span> <span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">grid</span><span class="o">/</span><span class="n">ax</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span><span class="p">():</span>

      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Field concat error </span><span class="si">%s</span><span class="s"> and </span><span class="si">%s</span><span class="s">. Provide pieces of right dimensions. (now </span><span class="si">%s</span><span class="s"> and </span><span class="si">%s</span><span class="s">)&#39;</span><span class="o">%</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span><span class="n">other</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="nb">str</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">/</span><span class="n">ax</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span><span class="p">())</span>  <span class="p">,</span> <span class="nb">str</span><span class="p">(</span> <span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">grid</span><span class="o">/</span><span class="n">ax</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span><span class="p">())</span>   <span class="p">)</span> <span class="p">)</span>

    <span class="c"># We now know that cat_coord_self in grid and pieces of compatible dimension</span>
    <span class="c"># Next, obtain the index of the axis in the grid along which to concatenate.</span>
    <span class="c"># why do we need eq_index here instead of index? because it is an Ax object.</span>
    <span class="n">ax_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">eq_index</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span>

    <span class="c"># combine the two halves as dictionaries of slices of what is to be the new Coord first</span>
 
    <span class="c"># pick the Coord specified by the ax argument by multiplying the grids: </span>
    <span class="n">left_coord</span> <span class="o">=</span> <span class="p">(</span><span class="n">ax</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">)</span>
    <span class="n">right_coord</span> <span class="o">=</span> <span class="p">(</span><span class="n">ax</span><span class="o">*</span><span class="n">other</span><span class="o">.</span><span class="n">grid</span><span class="p">)</span>
    <span class="c"># e here is a point in the relevant Coord: </span>
    <span class="n">Dleft</span> <span class="o">=</span> <span class="p">{</span><span class="n">e</span><span class="p">:</span><span class="bp">self</span><span class="p">[</span><span class="n">ax</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span> <span class="n">left_coord</span><span class="o">.</span><span class="n">value</span> <span class="p">)</span> <span class="p">}</span>
    <span class="n">Dright</span> <span class="o">=</span> <span class="p">{</span><span class="n">e</span><span class="p">:</span><span class="n">other</span><span class="p">[</span><span class="n">ax</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span>  <span class="nb">enumerate</span><span class="p">(</span> <span class="n">right_coord</span><span class="o">.</span><span class="n">value</span> <span class="p">)</span> <span class="p">}</span>

    <span class="c"># if one or both coords have no strings attribute set, don&#39;t give the new Coord a string attribute either.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">left_coord</span><span class="o">.</span><span class="n">strings</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">right_coord</span><span class="o">.</span><span class="n">strings</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">):</span>
      <span class="n">stringsleft</span> <span class="o">=</span> <span class="p">{</span><span class="n">e</span><span class="p">:</span><span class="n">left_coord</span><span class="o">.</span><span class="n">strings</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span> <span class="n">left_coord</span><span class="o">.</span><span class="n">value</span> <span class="p">)</span> <span class="p">}</span>    
      <span class="n">stringsright</span> <span class="o">=</span> <span class="p">{</span><span class="n">e</span><span class="p">:</span><span class="n">right_coord</span><span class="o">.</span><span class="n">strings</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span> <span class="n">right_coord</span><span class="o">.</span><span class="n">value</span> <span class="p">)</span> <span class="p">}</span>    
      <span class="n">stringscomb</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">stringsleft</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="o">+</span> <span class="n">stringsright</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>

      <span class="n">stringscomb</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="n">Dcomb</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">Dleft</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="o">+</span> <span class="n">Dright</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="p">)</span>

      <span class="c"># each unravelled piece needs to have the right shape for np concatenation.</span>
    <span class="n">piece_shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">piece_shape</span><span class="p">[</span><span class="n">ax_index</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

      <span class="c"># use combined keys to construct ordered values of new concatenated Coord object.</span>
    <span class="n">cat_coord_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">Dcomb</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="n">cat_coord_value</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>

      <span class="c"># create the new concatenated Coord object using the combined ordered sequence of values.</span>
    <span class="k">if</span> <span class="n">stringscomb</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
      <span class="n">new_strings</span> <span class="o">=</span> <span class="p">[</span><span class="n">stringscomb</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">cat_coord_value</span><span class="p">]</span>

      <span class="n">new_coord</span> <span class="o">=</span> <span class="n">cat_coord_self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">name</span> <span class="o">=</span> <span class="n">affix</span><span class="p">(</span><span class="n">cat_coord_self</span><span class="o">.</span><span class="n">name</span> <span class="p">,</span><span class="n">name_suffix</span><span class="p">,</span> <span class="s">&#39;suffix&#39;</span><span class="p">),</span>   <span class="n">value</span> <span class="o">=</span> <span class="n">cat_coord_value</span><span class="p">,</span> <span class="n">strings</span> <span class="o">=</span> <span class="n">new_strings</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
      <span class="n">new_coord</span> <span class="o">=</span> <span class="n">cat_coord_self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">name</span> <span class="o">=</span> <span class="n">affix</span><span class="p">(</span><span class="n">cat_coord_self</span><span class="o">.</span><span class="n">name</span> <span class="p">,</span><span class="n">name_suffix</span><span class="p">,</span> <span class="s">&#39;suffix&#39;</span><span class="p">),</span>   <span class="n">value</span> <span class="o">=</span> <span class="n">cat_coord_value</span><span class="p">,</span> <span class="n">strings</span> <span class="o">=</span> <span class="bp">None</span><span class="p">)</span>



    <span class="n">new_coord</span><span class="o">.</span><span class="n">make_equiv</span><span class="p">(</span><span class="n">cat_coord_self</span><span class="p">)</span>
      <span class="c"># construct combined Field values. Reshape is needed for np.concatenate function.</span>
    <span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="n">Dcomb</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">piece_shape</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">cat_coord_value</span><span class="p">]</span>
   
    <span class="n">new_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">values</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="n">ax_index</span><span class="p">)</span>

      <span class="c"># construct the grid of the combined object by replacing the old partial Coord with the new combined Coord in the self grid. Recall that replacement is done with left multiplication.</span>
    <span class="n">new_grid</span> <span class="o">=</span> <span class="n">new_coord</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span>
       
<span class="c">#      new_value = new_value.reshape(new_grid.shape())</span>

    
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">value</span> <span class="o">=</span> <span class="n">new_value</span><span class="p">,</span><span class="n">grid</span> <span class="o">=</span> <span class="n">new_grid</span> <span class="p">)</span>
</div>
<div class="viewcode-block" id="Field.der"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Field.der">[docs]</a>  <span class="k">def</span> <span class="nf">der</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ax</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calls Ax.der on self.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ax</span><span class="o">.</span><span class="n">der</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="Field.roll"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Field.roll">[docs]</a>  <span class="k">def</span> <span class="nf">roll</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shift</span><span class="p">,</span> <span class="n">crd</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Rolls Field along Coord.</span>

<span class="sd">    Call roll function on self.</span>

<span class="sd">    Args:</span>
<span class="sd">      shift: (int) number of index points to roll by</span>
<span class="sd">      crd: (Coord) coord to shift on</span>

<span class="sd">    Returns:</span>
<span class="sd">      Field: containing the shifted value and grid.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">roll</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shift</span> <span class="o">=</span> <span class="n">shift</span><span class="p">,</span><span class="n">coord</span> <span class="o">=</span> <span class="n">crd</span><span class="p">)</span>
</div>
  <span class="k">def</span> <span class="nf">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Field addition F + G. </span>

<span class="sd">    Proceeds only when fields are defined on the same grid. To add fields defined on different grids, use something like F + G(F.grid) or other, depending on the space spanned by the grids.</span>
<span class="sd">    If the strict_v attribute of F is set to True (a default), and the direction attributes of F,G differ and are not scalar, addition leads to the formation of a vector Field F*G = (F,G).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">L</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span>
    
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">Field</span><span class="p">):</span>
      <span class="n">R</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">value</span>
      <span class="k">if</span> <span class="n">L</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">R</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">grid</span><span class="p">):</span>
          <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">same</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">grid</span><span class="p">):</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&#39;grids contain same data points but different other attributes (e.g. name). Proceeding.&#39;</span><span class="p">)</span>

          <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">strict_v</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">direction</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">direction</span><span class="p">:</span>
              <span class="k">return</span> <span class="n">Field</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="n">L</span><span class="o">+</span><span class="n">R</span><span class="p">,</span><span class="n">grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span> <span class="n">units</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">units</span><span class="p">,</span> <span class="n">direction</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">direction</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span> 
              <span class="k">return</span> <span class="bp">self</span><span class="o">*</span><span class="n">other</span>

          <span class="k">else</span><span class="p">:</span>

            <span class="k">return</span> <span class="n">Field</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="n">L</span><span class="o">+</span><span class="n">R</span><span class="p">,</span><span class="n">grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span> <span class="n">units</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">units</span><span class="p">,</span> <span class="n">direction</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">direction</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;Field grid error in </span><span class="si">%s</span><span class="s"> + </span><span class="si">%s</span><span class="s"> with Field </span><span class="si">%s</span><span class="s">: Field grids must be equal. Try F + G(F.grid).&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span> <span class="p">)</span>
          
      <span class="k">else</span><span class="p">:</span>  
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;Field shape error in </span><span class="si">%s</span><span class="s"> + </span><span class="si">%s</span><span class="s"> with Field </span><span class="si">%s</span><span class="s">: shapes must match. Try F + G(F.grid).&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span> <span class="p">)</span>
       

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="nb">int</span><span class="p">):</span>
      <span class="k">return</span> <span class="bp">self</span><span class="o">+</span><span class="nb">float</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="nb">float</span><span class="p">):</span>
      <span class="k">return</span> <span class="n">Field</span><span class="p">(</span><span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span><span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">+</span> <span class="n">other</span><span class="p">,</span><span class="n">grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span> <span class="n">units</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">units</span><span class="p">,</span> <span class="n">direction</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">direction</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;Field type error </span><span class="si">%s</span><span class="s"> + </span><span class="si">%s</span><span class="s"> with Field </span><span class="si">%s</span><span class="s">: right factor must be Field, int or float.&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span> <span class="p">)</span>
        

<span class="c"># --&gt; belongs to Field </span>

  <span class="k">def</span> <span class="nf">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">):</span>
    <span class="n">L</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span>
    
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">Field</span><span class="p">):</span>
      <span class="n">R</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">value</span>
      <span class="k">if</span> <span class="n">L</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">R</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">grid</span><span class="p">):</span>

          <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">same</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">grid</span><span class="p">):</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&#39;grids contain same data points but different other attributes (e.g. name). Proceeding.&#39;</span><span class="p">)</span>

          <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">strict_v</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">direction</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">direction</span><span class="p">:</span>

<span class="c"># should these Field creation statements be replaced with self.copy?</span>

              <span class="k">return</span> <span class="n">Field</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="n">L</span> <span class="o">-</span> <span class="n">R</span><span class="p">,</span><span class="n">grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span> <span class="n">units</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">units</span><span class="p">,</span> <span class="n">direction</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">direction</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span> 
              <span class="k">return</span> <span class="bp">self</span><span class="o">*</span><span class="n">other</span>

          <span class="k">else</span><span class="p">:</span>

            <span class="k">return</span> <span class="n">Field</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="n">L</span> <span class="o">-</span> <span class="n">R</span><span class="p">,</span><span class="n">grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span> <span class="n">units</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">units</span><span class="p">,</span> <span class="n">direction</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">direction</span><span class="p">)</span>


        <span class="k">else</span><span class="p">:</span>
          <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;Field grid error in </span><span class="si">%s</span><span class="s">-</span><span class="si">%s</span><span class="s"> with Field </span><span class="si">%s</span><span class="s">: grids must be equal. Try F - G(F.grid) or F(G.grid) - G.&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span> <span class="p">)</span>
          
      <span class="k">else</span><span class="p">:</span>  
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;Field shape error in </span><span class="si">%s</span><span class="s">-</span><span class="si">%s</span><span class="s"> with Field </span><span class="si">%s</span><span class="s">: shapes must match. Try F - G(F.grid) or F(G.grid) - G.&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span>  <span class="p">)</span>
      

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="nb">int</span><span class="p">):</span>
      <span class="k">return</span> <span class="bp">self</span> <span class="o">-</span> <span class="nb">float</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="nb">float</span><span class="p">):</span>
      <span class="k">return</span> <span class="n">Field</span><span class="p">(</span><span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span><span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">-</span> <span class="n">other</span><span class="p">,</span><span class="n">grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span> <span class="n">units</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">units</span><span class="p">,</span> <span class="n">direction</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">direction</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;Field type error in </span><span class="si">%s</span><span class="s"> - </span><span class="si">%s</span><span class="s"> with Field </span><span class="si">%s</span><span class="s">: right factor must be Field, int or float.&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span>  <span class="p">)</span>





  <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_value</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">L</span><span class="p">):</span>
    
    <span class="sd">&quot;&quot;&quot;getitem of Field.</span>
<span class="sd">    </span>
<span class="sd">    Returns a new field containing the sliced content of self if argument consists only of slice objects. Returns value if argument is :</span>
<span class="sd">    If argument is of form: (crd0,1,crd2,1:) etc for crd0,crd1 Coord objects, slicing will take place along each Coord using the slice object or integer following each crd argument as the slice object. A new Field will be returned and new associated Coord objects and a corresponding grid will be produced for the return Field.</span>

<span class="sd">    The argument may also contain Ax objects X,Y,Z,T. In this case, the argument will be converted to the corresponding Coord object from the Field grid self.grid via multiplication.</span>


<span class="sd">    Raises:</span>
<span class="sd">      ValueError, RuntimeError</span>
<span class="sd">    &quot;&quot;&quot;</span> 

    <span class="k">if</span> <span class="n">L</span> <span class="o">==</span> <span class="nb">slice</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span><span class="bp">None</span><span class="p">,</span><span class="bp">None</span><span class="p">):</span>
      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_value</span><span class="p">()</span>

    <span class="n">standard_slices</span> <span class="o">=</span> <span class="n">interpret_slices</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">)</span>

    <span class="n">new_name</span> <span class="o">=</span> <span class="n">affix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="s">&#39;_sliced&#39;</span><span class="p">)</span>
    <span class="n">new_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_value</span><span class="p">()[</span><span class="n">standard_slices</span><span class="p">]</span>
    <span class="n">new_grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">sliced</span><span class="p">(</span><span class="n">standard_slices</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">new_value</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">))</span> <span class="o">|</span> <span class="p">(</span><span class="n">new_value</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)):</span>    
      <span class="c"># For single valued slices, do not return a Field</span>
      <span class="n">return_value</span> <span class="o">=</span> <span class="n">new_value</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">new_value</span> <span class="o">=</span> <span class="n">new_value</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">new_grid</span><span class="o">.</span><span class="n">shape</span><span class="p">())</span>
      <span class="n">return_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">name</span> <span class="o">=</span> <span class="n">new_name</span><span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="n">new_value</span><span class="p">,</span> <span class="n">grid</span> <span class="o">=</span> <span class="n">new_grid</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">return_value</span>

<div class="viewcode-block" id="Field.set_value"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Field.set_value">[docs]</a>  <span class="k">def</span> <span class="nf">set_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
    <span class="k">return</span>
</div>
<div class="viewcode-block" id="Field.get_value"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Field.get_value">[docs]</a>  <span class="k">def</span> <span class="nf">get_value</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;Obtain value of Field.</span>
<span class="sd">    &quot;&quot;&quot;</span> 

    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span>

</div>
  <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">grid</span><span class="p">,</span> <span class="n">method</span> <span class="o">=</span> <span class="s">&#39;linear&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Shorthand for regrid method.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">regrid</span><span class="p">(</span><span class="n">grid</span> <span class="o">=</span> <span class="n">grid</span><span class="p">,</span> <span class="n">method</span> <span class="o">=</span> <span class="n">method</span><span class="p">)</span>


<div class="viewcode-block" id="Field.regrid"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Field.regrid">[docs]</a>  <span class="k">def</span> <span class="nf">regrid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">grid</span><span class="p">,</span> <span class="n">method</span> <span class="o">=</span> <span class="s">&#39;linear&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Regrid (interpolate) Field (self) to grid.</span>

<span class="sd">    Args:</span>
<span class="sd">      grid: (Gr) grid to regrid to.</span>
<span class="sd">      method: (str) interpolation method to use.</span>

<span class="sd">    Returns:</span>
<span class="sd">      Interpolated Field defined on grid from argument.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<span class="c"># this method is very important. </span>
<span class="c"># If Field T is naturally defined on grid yt*xt, then T(zt*yt*xt) yields a Field with value a 3D array b such that b[k,:,:] = T(yt*xt) for all possible k.</span>

    <span class="n">value</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">method</span> <span class="o">=</span> <span class="n">method</span><span class="p">))(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span><span class="nb">list</span><span class="p">):</span>
<span class="c"># in this case the grid argument is a subspace of self.grid so that the grid of the elements is self.grid/grid due to the way self.grid(grid) has been constructed (see call method for grid objects).</span>
      <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
      <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">e</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
        <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Field</span><span class="p">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">&#39;slice_&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">grid</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span> <span class="p">)</span><span class="o">+</span><span class="s">&#39;_&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">,</span><span class="n">value</span> <span class="o">=</span> <span class="n">e</span><span class="p">,</span> <span class="n">grid</span> <span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">/</span><span class="n">grid</span><span class="p">))</span>
      <span class="k">return</span> <span class="n">result</span>
     
    <span class="k">else</span><span class="p">:</span>
<span class="c"># the element is probably a numpy array. If not, Field init will throw an error.</span>
      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="p">,</span> <span class="n">grid</span> <span class="o">=</span><span class="n">grid</span><span class="p">)</span>
</div>
  <span class="k">def</span> <span class="nf">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Multiplies two Fields.</span>

<span class="sd">    For Fields T1,T2. If T1 is defined on gr1 and T2 on gr2, then T1*T2 is defined on gr1*gr2</span>

<span class="sd">    Takes multiple type argument: under multiplication Fields commute with Gr and AxGr (Coord is transformed to Gr). Multiplication with int and float leads to multiplication of the ndarray in the value attribute.</span>

<span class="sd">    Args:</span>
<span class="sd">      other: (int, float,Gr, AxGr, Coord, Field) right multiplicant (with self)</span>

<span class="sd">    Returns: </span>
<span class="sd">      Field.</span>

<span class="sd">    Raises:</span>
<span class="sd">      typeError if argument of the wrong type.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="nb">int</span><span class="p">):</span>
      <span class="k">return</span> <span class="bp">self</span><span class="o">*</span><span class="nb">float</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
    
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="nb">float</span><span class="p">):</span>
      <span class="k">return</span> <span class="n">Field</span><span class="p">(</span><span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="p">,</span><span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="o">*</span><span class="n">other</span><span class="p">,</span><span class="n">grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span> <span class="n">units</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">units</span> <span class="p">,</span><span class="n">direction</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">direction</span><span class="p">)</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">Gr</span><span class="p">):</span>
      <span class="c"># fields commute with Gr objects</span>
      <span class="k">return</span> <span class="n">other</span><span class="o">*</span><span class="bp">self</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">AxGr</span><span class="p">):</span>
      <span class="c"># fields commute with AxGr objects</span>
      <span class="k">return</span> <span class="n">other</span><span class="o">*</span><span class="bp">self</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">Coord</span><span class="p">)</span> <span class="o">|</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">Ax</span><span class="p">):</span>
<span class="c">#      print &#39;Warning (benign): converting right multiplicant to Gr from Coord object.&#39;</span>
      <span class="k">return</span> <span class="bp">self</span><span class="o">*</span><span class="p">(</span><span class="n">other</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">Field</span><span class="p">):</span>
      <span class="c"># both multiplicants are fields</span>
  
      <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">direction</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">direction</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">direction</span> <span class="o">==</span> <span class="n">ID</span><span class="p">())</span> <span class="o">|</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">direction</span> <span class="o">==</span> <span class="n">ID</span><span class="p">()):</span>
        <span class="c"># in this case, at least one of the multiplicants is a scalar (interacting with all directions), or both multiplicants are along the same direction.</span>

    <span class="c"># Note that this multiplication yields precedence for the order of the left multiplicant (self). E.g. (zt*yt*xt)*(xt*yt) = zt*yt*xt</span>
        <span class="n">common_gr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">*</span><span class="n">other</span><span class="o">.</span><span class="n">grid</span>
 
    <span class="c"># This multiplication inflates the values of self and other (arrays) onto the common grid. </span>
    <span class="c"># In case the grids contain Coord elements that are equivalent but not equal, grid multiplication dictates that common_gr will contain the elements of the left multiplicant (i.e. again a precedence for the left multiplicant). This implies that the right Field will then be interpolated on the left latice</span>
    
        
        <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s">&#39;&#39;</span><span class="p">:</span>
          <span class="n">new_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s">&#39;&#39;</span><span class="p">:</span>
          <span class="n">new_name</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">name</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="n">new_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span><span class="s">&#39;_times_&#39;</span><span class="o">+</span><span class="n">other</span><span class="o">.</span><span class="n">name</span>
 
        <span class="n">new_direction</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">direction</span><span class="o">*</span><span class="n">other</span><span class="o">.</span><span class="n">direction</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">new_direction</span><span class="p">,</span><span class="n">AxGr</span><span class="p">):</span>
          <span class="n">new_direction</span> <span class="o">=</span> <span class="n">new_direction</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">Field</span><span class="p">(</span><span class="n">name</span> <span class="o">=</span> <span class="n">new_name</span> <span class="p">,</span><span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="n">common_gr</span><span class="p">)(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">)</span><span class="o">*</span><span class="n">other</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="n">common_gr</span><span class="p">)(</span><span class="n">other</span><span class="o">.</span><span class="n">value</span><span class="p">),</span><span class="n">grid</span> <span class="o">=</span> <span class="n">common_gr</span><span class="p">,</span> <span class="n">units</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">units</span> <span class="o">+</span> <span class="n">other</span><span class="o">.</span><span class="n">units</span><span class="p">,</span> <span class="n">direction</span> <span class="o">=</span> <span class="n">new_direction</span><span class="p">)</span>

      <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">grid</span><span class="p">:</span>
          <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">weaksame</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">grid</span><span class="p">):</span>

            <span class="c"># If multiplicants are defined on grids that have the same values but are different objects, a duplicate grid is discovered and housekeeping is done. Duplicate grids commonly arise from earlier slicing.</span>
            <span class="k">print</span> <span class="s">&#39;Duplicate grids. FYI: replacing right gr.&#39;</span>
            <span class="k">del</span> <span class="n">other</span><span class="o">.</span><span class="n">grid</span>
            <span class="n">other</span><span class="o">.</span><span class="n">grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span>
          <span class="k">else</span><span class="p">:</span>
            <span class="c"># if grids are different and not duplicates, the resulting vectorfield is likely to be ill defined. Creation proceeds nonetheless, but with a warning.</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span> <span class="s">&#39;(severe) VField components defined on different grids.&#39;</span><span class="p">,</span> <span class="ne">RuntimeWarning</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">VField</span><span class="p">((</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">))</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">VField</span><span class="p">):</span>
      <span class="c"># the right multiplicant is a vector Field.</span>

      <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">direction</span> <span class="o">==</span> <span class="n">ID</span><span class="p">():</span>
        <span class="n">new_vfield</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">*</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">other</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">VField</span><span class="p">(</span><span class="n">new_vfield</span><span class="p">)</span>       
        
     
      <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">direction</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">direction</span><span class="p">():</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">direction</span><span class="p">()</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">direction</span><span class="p">)</span>

        <span class="n">new_vfield</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="n">new_vfield</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">*</span><span class="n">new_vfield</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">VField</span><span class="p">(</span><span class="n">new_vfield</span><span class="p">)</span>       

      <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">VField</span><span class="p">([</span><span class="bp">self</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="p">)</span>


    <span class="k">else</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;Field error in </span><span class="si">%s</span><span class="s">*</span><span class="si">%s</span><span class="s"> with Field </span><span class="si">%s</span><span class="s">. Provide Field,Gr or Coord objects or int or double for right multiplicant. Hint: common mistake is when multiplying a Field F and a Coord c, and c appears to be in F.grid, c may be stale: check whether they are identical. If not, update c from Exper Coord stack. &#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span> <span class="p">)</span>
     

<span class="c"># --&gt; belongs to  Field.</span>
  <span class="k">def</span> <span class="nf">__div__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Divides two Fields. </span>
<span class="sd"> </span>
<span class="sd">    See __mult__</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="nb">int</span><span class="p">):</span>
      <span class="k">return</span> <span class="bp">self</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
    
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="nb">float</span><span class="p">):</span>
      <span class="k">return</span> <span class="n">Field</span><span class="p">(</span><span class="n">name</span> <span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="p">,</span><span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="o">/</span><span class="n">other</span><span class="p">,</span><span class="n">grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span> <span class="n">direction</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">direction</span><span class="p">)</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">Gr</span><span class="p">):</span>
      <span class="k">return</span> <span class="n">other</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">AxGr</span><span class="p">)</span> <span class="o">|</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">Ax</span><span class="p">):</span>
      <span class="k">return</span> <span class="bp">self</span><span class="o">/</span><span class="p">(</span><span class="n">other</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">)</span>
 
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">Coord</span><span class="p">):</span>
<span class="c">#      print &#39;Warning: (benign) converting right multiplicant to Gr from Coord object.&#39;</span>
      <span class="k">return</span> <span class="bp">self</span><span class="o">/</span><span class="p">(</span><span class="n">other</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">Field</span><span class="p">):</span>

      <span class="n">new_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
      <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s">&#39;&#39;</span><span class="p">:</span>
        <span class="n">new_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
      <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s">&#39;&#39;</span><span class="p">:</span>
        <span class="n">new_name</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">name</span>


    <span class="c"># Note that this multiplication yields precedence for the order of the left multiplicant (self). E.g. (zt*yt*xt)*(xt*yt) = zt*yt*xt</span>
      <span class="n">common_gr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">*</span><span class="n">other</span><span class="o">.</span><span class="n">grid</span>
 
    <span class="c"># This multiplication inflates the values of self and other (arrays) onto the common grid. </span>
    <span class="c"># In case the grids contain Coord elements that are equivalent but not equal, grid multiplication dictates that common_gr will contain the elements of the left multiplicant (i.e. again a precedence for the left multiplicant). This implies that the right Field will then be interpolated on the left latice</span>

      <span class="k">return</span> <span class="n">Field</span><span class="p">(</span><span class="n">name</span> <span class="o">=</span> <span class="n">new_name</span> <span class="p">,</span><span class="n">value</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="n">common_gr</span><span class="p">)(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">))</span><span class="o">/</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="n">common_gr</span><span class="p">)(</span><span class="n">other</span><span class="o">.</span><span class="n">value</span><span class="p">)),</span><span class="n">grid</span> <span class="o">=</span> <span class="n">common_gr</span><span class="p">,</span> <span class="n">direction</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">direction</span><span class="p">)</span>


    <span class="k">else</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;Field error in </span><span class="si">%s</span><span class="s">/</span><span class="si">%s</span><span class="s"> with Field </span><span class="si">%s</span><span class="s">. Provide Field,gr or Coord objects or int or double for denominator. (Or check staleness of objects.)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span> <span class="p">)</span>
     
<span class="c"># --&gt; belongs to  Field.</span>

<div class="viewcode-block" id="Field.vcumsum"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Field.vcumsum">[docs]</a>  <span class="k">def</span> <span class="nf">vcumsum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">coord</span><span class="p">,</span> <span class="n">upward</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Apply vcumsum method of coord on Field.</span>

<span class="sd">    See Coord.vcumsum</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="n">coord</span><span class="o">.</span><span class="n">vcumsum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">upward</span><span class="o">=</span><span class="n">upward</span><span class="p">)</span> 


<span class="c"># IS THIS SUM METHOD BEING CALLED??? IF NOT, REMOVE AND REPLACE WITH COORD BASED METHODS:</span>
<span class="c"># --&gt; method belongs to Field.</span></div>
<div class="viewcode-block" id="Field.sum"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Field.sum">[docs]</a>  <span class="k">def</span> <span class="nf">sum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">grid</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes sum of Field over grid using masked array (nan is not counted). </span>

<span class="sd">    Args:</span>
<span class="sd">      grid: (Gr) grid to sum over. None means the entire Field grid.</span>

<span class="sd">    Returns:</span>
<span class="sd">      Field containing values summed over grid of smaller dimension, or float if grid is self.grid.</span>

<span class="sd">    Say self.gr is zt*yt*xt and grid is yt*xt.</span>

<span class="sd">    Examples:</span>

<span class="sd">    &gt;&gt;&gt; K.grid # take a 2D field</span>
<span class="sd">    (latitude, longitude)</span>
<span class="sd">    &gt;&gt;&gt; KS = K.sum(latitude**2) # sum on subgrid latitude**2 (**2 yields grid)</span>
<span class="sd">    &gt;&gt;&gt; KS.grid # the result is a series of sums along longitude.</span>
<span class="sd">    (longitude)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">grid</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">perm</span><span class="p">(</span><span class="n">grid</span><span class="p">):</span>
<span class="c"># in this case no grid argument is given, or the full grid is given (up to a permutation).</span>
      <span class="n">R</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">masked_array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">))</span>
      <span class="k">return</span> <span class="n">ma</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">R</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
<span class="c"># in this case, it is assumed the user wants to take sums along a certain set of axes, where that grid object is a subspace of self.grid  </span>

<span class="c"># obtain the dual vectorspace axes of grid argument, due to the way the call method of grid objects works.   </span>
      <span class="n">F</span> <span class="o">=</span> <span class="bp">self</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">/</span><span class="n">grid</span><span class="p">)</span>
      
<span class="c"># we assume that F is now a list of fields.</span>
<span class="c"># each element has to be summed.</span>
    
      <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
      <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">F</span><span class="p">:</span>
        <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>

      <span class="n">new_grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">/</span><span class="n">grid</span> 
           
      <span class="k">return</span> <span class="n">Field</span><span class="p">(</span><span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">result</span><span class="p">))</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">new_grid</span><span class="o">.</span><span class="n">shape</span><span class="p">())</span> <span class="p">,</span><span class="n">grid</span> <span class="o">=</span> <span class="n">new_grid</span><span class="p">)</span>


</div>
<div class="viewcode-block" id="Field.ones"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Field.ones">[docs]</a>  <span class="k">def</span> <span class="nf">ones</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nan_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns Field containing domain of this Field: values are 1 in grid locations where Field is defined, nan otherwise. This can be useful for mask creation and the like.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">new_fld</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">ones</span><span class="p">()</span>
    <span class="n">new_fld</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">)]</span> <span class="o">=</span> <span class="n">nan_val</span>

    <span class="k">return</span> <span class="n">new_fld</span>

<span class="c"># --&gt; method belongs to Field.</span></div>
<div class="viewcode-block" id="Field.dV"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Field.dV">[docs]</a>  <span class="k">def</span> <span class="nf">dV</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Returns Field of same dimension containing ndarray of grid cell volumes, with field nan values (often representing land) set to nan.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ones</span><span class="p">()</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">vol</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Field.vol"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Field.vol">[docs]</a>  <span class="k">def</span> <span class="nf">vol</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grid</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute total volume (area/ length) of non-nan grid cells. </span>

<span class="sd">    Uses sum method, see sum.</span>

<span class="sd">    Args:</span>
<span class="sd">      grid: (Gr) to use in sum method.  None means the entire Field grid.</span>

<span class="sd">    Returns:</span>
<span class="sd">      float: the total volume.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dV</span><span class="p">())</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>
    </div>
<div class="viewcode-block" id="Field.vsum"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Field.vsum">[docs]</a>  <span class="k">def</span> <span class="nf">vsum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">grid</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Compute grid cell volume-weighted sum of Field.</span>

<span class="sd">    Calls sum. Method sum uses masked arrays. See sum.</span>

<span class="sd">    Args:</span>
<span class="sd">      grid: (Gr) grid to sum over.  None means the entire Field grid.</span>

<span class="sd">    Returns:</span>
<span class="sd">      Field containing values summed over grid of smaller dimension, or float if grid is self.grid.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dV</span><span class="p">()</span><span class="o">*</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Field.mean"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Field.mean">[docs]</a>  <span class="k">def</span> <span class="nf">mean</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">grid</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate grid cell volumes-weighted mean.</span>

<span class="sd">    Calls sum method with grid argument and dV method.</span>

<span class="sd">    Args:</span>
<span class="sd">      grid: (Gr) to calculate means over.</span>

<span class="sd">    Returns:</span>
<span class="sd">      Lower dim Field if grid subgrid of self.grid or float if equal.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dV</span><span class="p">()</span><span class="o">*</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dV</span><span class="p">())</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>

  


</div>
<div class="viewcode-block" id="Field.slice_by"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Field.slice_by">[docs]</a>  <span class="k">def</span> <span class="nf">slice_by</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sl_coord</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span><span class="n">slice_obj</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="bp">None</span><span class="p">,</span><span class="bp">None</span><span class="p">)):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Slice along Coord (e.g. xt) using slice_obj as slice, e.g. slice(1,None,None).</span>
<span class="sd">    &quot;&quot;&quot;</span>
  
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sl_coord</span><span class="p">,</span><span class="n">Coord</span><span class="p">):</span>
     
      <span class="n">sl</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="bp">None</span><span class="p">,))</span>
      
      <span class="n">L</span> <span class="o">=</span> <span class="p">[]</span>
      <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">:</span>
        
        <span class="k">if</span> <span class="n">sl_coord</span> <span class="ow">is</span> <span class="n">e</span><span class="p">:</span>
          <span class="n">L</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">slice_obj</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="n">L</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sl</span><span class="p">)</span>    
     
      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="n">L</span><span class="p">]</span>
</div>
<div class="viewcode-block" id="Field.draw"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Field.draw">[docs]</a>  <span class="k">def</span> <span class="nf">draw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">colorbar</span> <span class="o">=</span> <span class="bp">True</span><span class="p">,</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Quick plot of this Field using the most obvious layout etc.</span>

<span class="sd">    Args:</span>
<span class="sd">      colorbar: (Boolean) add colorbar if True</span>
<span class="sd">      index: (int) index value at which to slice if Field dim &gt; 2</span>
<span class="sd">      **kwargs: further kwargs to be passed on</span>

<span class="sd">    Returns:</span>
<span class="sd">      h, cb: handles to figure and colorbar</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
      <span class="n">h</span><span class="o">=</span> <span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
      <span class="n">cb</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
   
      <span class="n">h</span> <span class="o">=</span> <span class="n">contourf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
      <span class="k">if</span> <span class="n">colorbar</span><span class="p">:</span>
        <span class="n">cb</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">()</span>
      <span class="n">cb</span><span class="o">.</span><span class="n">set_label</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">units</span><span class="p">)</span>

    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
      <span class="c"># 3D Field objects need to be sliced. Find an obvious Coord to slice at.</span>

      <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">e</span><span class="p">,</span><span class="s">&#39;axis&#39;</span><span class="p">):</span>
          <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">axis</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s">&#39;Z&#39;</span><span class="p">:</span>
            <span class="c"># Slicing at a vertical Coord always good</span>
            <span class="k">break</span>       
      <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">axis</span><span class="o">.</span><span class="n">name</span> <span class="o">!=</span> <span class="s">&#39;Z&#39;</span><span class="p">:</span>
        <span class="c"># if we didn&#39;t find a Coord, use the first one.</span>
        <span class="n">e</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

      <span class="c"># Slice at index along guessed Coord</span>
      <span class="n">h</span> <span class="o">=</span> <span class="n">contourf</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">e</span><span class="p">,</span> <span class="n">index</span><span class="p">])</span>
      <span class="k">if</span> <span class="n">colorbar</span><span class="p">:</span>
        <span class="n">cb</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">()</span>
      <span class="n">cb</span><span class="o">.</span><span class="n">set_label</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">units</span><span class="p">)</span>

    
    <span class="k">return</span> <span class="n">h</span><span class="p">,</span> <span class="n">cb</span>




<span class="c"># ------------------ end Field  definition ----------------</span>


</div></div>
<div class="viewcode-block" id="VField"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.VField">[docs]</a><span class="k">class</span> <span class="nc">VField</span><span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="n">Membered</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  vector Field. A tuple of fields with extra rules. Allows multiplication.</span>
<span class="sd">  &quot;&quot;&quot;</span>

  <span class="k">def</span> <span class="nf">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Vector field multiplication.</span>

<span class="sd">    Behaviour depends on direction attribute of Field members. </span>

<span class="sd">    If other (right multiplicant) is Field or 1D VField, multiplication is:</span>
<span class="sd">      - distributive on self members if other.direction is scalar</span>
<span class="sd">      - works on matching direction member if found</span>
<span class="sd">      - yields a higher dimensional VField if self.direction not in members directions. </span>

<span class="sd">    Otherwise, the result is the product of self and the individual members from left to right.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">Field</span><span class="p">):</span>
      
        <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">direction</span> <span class="o">==</span> <span class="n">ID</span><span class="p">():</span>
          <span class="c"># scalar Field multiplication works on all individual member fields: distributive.</span>
          <span class="k">return</span> <span class="n">VField</span><span class="p">([</span><span class="n">e</span><span class="o">*</span><span class="n">other</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">])</span>

        <span class="k">elif</span> <span class="n">other</span><span class="o">.</span><span class="n">direction</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">direction</span><span class="p">():</span>
          <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">direction</span><span class="p">()</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">direction</span><span class="p">)</span>
          <span class="n">new_vfield</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
          <span class="n">new_vfield</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_vfield</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">other</span>
          <span class="k">return</span> <span class="n">VField</span><span class="p">(</span><span class="n">new_vfield</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
          
          <span class="n">new_vfield</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
          <span class="k">if</span> <span class="n">new_vfield</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">grid</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&#39;VField components defined on different grids.&#39;</span><span class="p">,</span><span class="ne">RuntimeWarning</span><span class="p">)</span> 

        <span class="k">return</span> <span class="n">VField</span><span class="p">(</span><span class="n">new_vfield</span> <span class="o">+</span> <span class="p">[</span><span class="n">other</span><span class="p">])</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">VField</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
          <span class="k">return</span> <span class="n">VField</span><span class="p">(</span> <span class="nb">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">:</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="o">*</span><span class="n">other</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">+</span><span class="nb">list</span><span class="p">(</span><span class="n">other</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span> <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="k">return</span> <span class="bp">self</span><span class="o">*</span><span class="n">other</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">else</span><span class="p">:</span>
       <span class="c"># all other types will work on the individual fields. Error messages will be generated from individual multiplication.</span>

       <span class="k">return</span> <span class="n">VField</span><span class="p">([</span><span class="n">e</span><span class="o">*</span><span class="n">other</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">])</span>


  <span class="k">def</span> <span class="nf">__div__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Vectorfield division.</span>

<span class="sd">    Similar to multiplication.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">Field</span><span class="p">):</span>
      
        <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">direction</span> <span class="o">==</span> <span class="n">ID</span><span class="p">():</span>
          <span class="c"># scalar Field multiplication works on individual member fields.</span>
          <span class="k">return</span> <span class="n">VField</span><span class="p">([</span><span class="n">e</span><span class="o">/</span><span class="n">other</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">])</span>

        <span class="k">elif</span> <span class="n">other</span><span class="o">.</span><span class="n">direction</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">direction</span><span class="p">():</span>
          <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">direction</span><span class="p">()</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">direction</span><span class="p">)</span>
          <span class="n">new_vfield</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
          <span class="n">new_vfield</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_vfield</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="n">other</span>
          <span class="k">return</span> <span class="n">VField</span><span class="p">(</span><span class="n">new_vfield</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="n">new_vfield</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">VField</span><span class="p">(</span><span class="n">new_vfield</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">other</span><span class="o">**-</span><span class="mi">1</span><span class="p">))</span>


    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">VField</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
          <span class="k">return</span> <span class="n">VField</span><span class="p">(</span> <span class="nb">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">:</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="o">*</span><span class="n">other</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">+</span><span class="nb">list</span><span class="p">(</span><span class="n">other</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span> <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="k">return</span> <span class="bp">self</span><span class="o">*</span><span class="n">other</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">else</span><span class="p">:</span>
       <span class="c"># all other types will work on the individual fields. Error messages will be generated from individual multiplication.</span>

       <span class="k">return</span> <span class="n">VField</span><span class="p">([</span><span class="n">e</span><span class="o">/</span><span class="n">other</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">])</span>

  <span class="nd">@method2members</span>
<div class="viewcode-block" id="VField.der"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.VField.der">[docs]</a>  <span class="k">def</span> <span class="nf">der</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ax</span><span class="p">):</span>
    <span class="k">pass</span>
</div>
  <span class="nd">@method2members</span>
  <span class="k">def</span> <span class="nf">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">):</span>
    <span class="k">pass</span>

  <span class="k">def</span> <span class="nf">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Adding two vector fields.</span>

<span class="sd">    Raises:</span>
<span class="sd">      ValueError</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">VField</span><span class="p">):</span>

      <span class="n">L_l</span> <span class="o">=</span> <span class="p">[]</span>
      <span class="n">L_r</span> <span class="o">=</span> <span class="p">[]</span>

      <span class="k">for</span> <span class="n">lft</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">rgt</span> <span class="ow">in</span> <span class="n">other</span><span class="p">:</span>
          <span class="k">if</span> <span class="n">lft</span><span class="o">.</span><span class="n">direction</span> <span class="o">==</span> <span class="n">rgt</span><span class="o">.</span><span class="n">direction</span><span class="p">:</span>
            <span class="n">L_l</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lft</span><span class="p">)</span>
            <span class="n">L_r</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rgt</span><span class="p">)</span>

      <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">L_l</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">L_r</span><span class="p">):</span>
        <span class="n">L</span> <span class="o">=</span><span class="p">[]</span>    
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">it</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">L_l</span><span class="p">):</span>
          <span class="n">sum_fld</span> <span class="o">=</span> <span class="n">it</span> <span class="o">+</span> <span class="n">L_r</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
          <span class="c"># direction must be assigned, as summing fields does not retain direction.</span>
          <span class="n">sum_fld</span><span class="o">.</span><span class="n">direction</span> <span class="o">=</span> <span class="n">it</span><span class="o">.</span><span class="n">direction</span>
          <span class="n">L</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sum_fld</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">VField</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Error in VField addition </span><span class="si">%s</span><span class="s"> + </span><span class="si">%s</span><span class="s">. Provide equal length&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">))</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">Field</span><span class="p">):</span>
      <span class="c"># sum a Field to a VField. the Field is added to all members.  </span>
<span class="c">#      if other.direction == ID():</span>
   
      <span class="n">L</span> <span class="o">=</span> <span class="p">[]</span>
      <span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
        <span class="n">sum_fld</span> <span class="o">=</span> <span class="n">it</span> <span class="o">+</span> <span class="n">other</span>
        <span class="n">sum_fld</span><span class="o">.</span><span class="n">direction</span> <span class="o">=</span> <span class="n">it</span><span class="o">.</span><span class="n">direction</span>
        <span class="n">L</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sum_fld</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">VField</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>

    <span class="k">return</span>

  <span class="nd">@method2members</span>
<div class="viewcode-block" id="VField.vcumsum"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.VField.vcumsum">[docs]</a>  <span class="k">def</span> <span class="nf">vcumsum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">coord</span><span class="p">,</span> <span class="n">upward</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="k">pass</span>
</div>
  <span class="nd">@method2members</span>
<div class="viewcode-block" id="VField.vsum"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.VField.vsum">[docs]</a>  <span class="k">def</span> <span class="nf">vsum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">coord</span><span class="p">):</span>
    <span class="k">pass</span>



</div>
<div class="viewcode-block" id="VField.innersum"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.VField.innersum">[docs]</a>  <span class="k">def</span> <span class="nf">innersum</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return sum of all members</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">:</span> <span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="VField.direction"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.VField.direction">[docs]</a>  <span class="k">def</span> <span class="nf">direction</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; </span>
<span class="sd">    Method that returns a tuple of the directions of the tuple components of this vector Field by examining these components.</span>

<span class="sd">    For example, if U.direction is X and V.direction is Y, then (U*V).direction is X*Y</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">:</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">,</span> <span class="p">[</span><span class="n">e</span><span class="o">.</span><span class="n">direction</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">])</span>

</div>
<div class="viewcode-block" id="VField.draw"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.VField.draw">[docs]</a>  <span class="k">def</span> <span class="nf">draw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Quick and easy plotting of this object. Only 2D VFields.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">direction</span><span class="p">())</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
      <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>

        <span class="c"># insert quiver plot here.</span>
        <span class="n">quiver</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
      <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>

        <span class="k">pass</span>
    <span class="k">else</span><span class="p">:</span>

      <span class="k">print</span> <span class="s">&quot;Refused. Only plotting 2D fields.&quot;</span>



<span class="c"># ------------ end of VField  --------------------</span>







<span class="c"># Field related functions:</span>



</div></div>
<div class="viewcode-block" id="concatenate"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.concatenate">[docs]</a><span class="k">def</span> <span class="nf">concatenate</span><span class="p">(</span><span class="n">fields</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">name_suffix</span><span class="o">=</span><span class="s">&#39;_cat&#39;</span><span class="p">,</span> <span class="n">new_coord_name</span> <span class="o">=</span> <span class="s">&#39;gamma&#39;</span><span class="p">,</span> <span class="n">new_coord</span><span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">strings</span> <span class="o">=</span> <span class="bp">None</span> <span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Joins a sequence of Field objects together.</span>

<span class="sd">  concatenate((a1,a2,...),ax=None)</span>
<span class="sd">       </span>
<span class="sd">  The Field value ndarrays must have the same shape, except in the direction of concatenation if present in the grid.</span>
<span class="sd">  Default behaviour (CASE A0) when ax = None picks the concatenation direction as the first direction with unequal Coord point values (indicating pieces of a dimension). For instance, SAT1.shape is (50,100) and SAT2.shape is (50,100) would concatenate to shape (100,100) by concatenating along index 0. </span>

<span class="sd">  If ax is already in grid directions (in Field.grid.axis(), CASE A1 ), and Field grids have equal Coord member in that direction, as per Field.cat method, the last Field is returned: don&#39;t use this.</span>

<span class="sd">  A new Coord is created (CASE A2) if new_coord argument is None and if none of the grid members axis point in the direction of the ax argument (e.g. X,Y vs Z). Then, &quot;new_coord_name&quot; is used. </span>
<span class="sd">  The above behaviour is overridden if the &quot;new_coord&quot; argument is given (CASE B). This is a Coord object that will be used to construct one Field from the fields list argument. The list elements become slices (at single Coord values) and the new_coord values are the corresponding coordinates.</span>

<span class="sd">  Args:</span>
<span class="sd">    fields: (container of Field objects, e.g. list) Field objects to concat.</span>
<span class="sd">    ax: (Gr) axis along which to concatenate, optional.</span>
<span class="sd">    name_suffix: (str) suffix to use for returned Field object name</span>
<span class="sd">    new_coord_name: (str) name to be used for creation of new Coord in case ax not in Field grid</span>
<span class="sd">    new_coord: (Coord) overrides default behaviour if set by concatenating along that new Coord.</span>
<span class="sd">    strings: (container of strings) used as strings argument in Coord creation with new_coord_name</span>

<span class="sd">  Returns:</span>
<span class="sd">    The concatenated Field.</span>

<span class="sd">  Raises:</span>
<span class="sd">    ValueError if Field sequence is empty or, if new_coord is not None, if the Field list is of unequal length to new_coord. </span>

<span class="sd">  Examples:</span>
<span class="sd">  </span>
<span class="sd">  Obtain X,Y,.. for project P via:</span>

<span class="sd">  &gt;&gt;&gt; for c in P[&#39;DPO&#39;].axes:</span>
<span class="sd">  &gt;&gt;&gt; exec c.name + &#39; = c&#39;</span>

<span class="sd">  CASE A0:</span>

<span class="sd">  &gt;&gt;&gt; SAT = P[&#39;DPO&#39;][&#39;A_sat&#39;]</span>
<span class="sd">  &gt;&gt;&gt; SAT1 = SAT[Y,:50]</span>
<span class="sd">  &gt;&gt;&gt; SAT2 = SAT[Y,50:]</span>
<span class="sd">  &gt;&gt;&gt; SAT_combined = sg.concatenate([SAT1,SAT2 ] )</span>
<span class="sd">  &gt;&gt;&gt; SAT_combined.shape # we get the old Field back via automatic Y-concatenation</span>
<span class="sd">  (100, 100)</span>

<span class="sd">  CASE A2: ax not in grid.axis(), a new Coord will be created</span>

<span class="sd">  &gt;&gt;&gt; SAT = P[&#39;DPO&#39;][&#39;A_sat&#39;]</span>
<span class="sd">  &gt;&gt;&gt; SAT1 = SAT[Y,:50]</span>
<span class="sd">  &gt;&gt;&gt; SAT2 = SAT[Y,50:]</span>
<span class="sd">  &gt;&gt;&gt; W = sg.Ax(&#39;W&#39;) # Create test Coord to concatenate along.</span>
<span class="sd">  &gt;&gt;&gt; SAT_combined = sg.concatenate([SAT1,SAT2 ], ax = W )</span>
<span class="sd">  &gt;&gt;&gt; SAT_combined.shape</span>
<span class="sd">  (2,50,100)</span>
<span class="sd">  &gt;&gt;&gt; SAT_combined.grid</span>
<span class="sd">  (gamma, latitude_sliced, longitude)</span>
<span class="sd">  &gt;&gt;&gt; SAT_combined.grid[0].value  # a new Coord has been created</span>
<span class="sd">  array([0, 1])</span>

<span class="sd">  CASE B: use new_coord to create new grid</span>

<span class="sd">  &gt;&gt;&gt; SAT = P[&#39;DPO&#39;][&#39;A_sat&#39;]</span>
<span class="sd">  &gt;&gt;&gt; SAT1 = SAT[Y,:50]</span>
<span class="sd">  &gt;&gt;&gt; SAT2 = SAT[Y,50:]</span>
<span class="sd">  &gt;&gt;&gt; W = sg.Ax(&#39;W&#39;) # Create test Coord to concatenate along.</span>
<span class="sd">  &gt;&gt;&gt; w = sg.Coord(&#39;w&#39; , axis = W, direction = &#39;W&#39;, value = np.array([0,1]))</span>
<span class="sd">  &gt;&gt;&gt; SAT_combined = sg.concatenate([SAT1,SAT2 ], new_coord = w )</span>
<span class="sd">  &gt;&gt;&gt; SAT_combined.shape</span>
<span class="sd">  (2,50,100)</span>
<span class="sd">  &gt;&gt;&gt; SAT_combined.grid</span>
<span class="sd">  (w, latitude_sliced, longitude)</span>
<span class="sd">  &gt;&gt;&gt; SAT_combined.grid[0].value  # we get the value of w</span>
<span class="sd">  array([0, 1])</span>
<span class="sd">  &quot;&quot;&quot;</span>

  <span class="c"># Preliminary checks </span>
  <span class="k">if</span> <span class="n">fields</span> <span class="o">==</span> <span class="p">[]:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Provide list of fields.&#39;</span><span class="p">)</span>

  <span class="c"># We will always check the first Field only for its grid as grids are assumed the same.</span>
  <span class="k">if</span> <span class="n">new_coord</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>

    <span class="c"># CASE B new_coord given</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">fields</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_coord</span><span class="p">):</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Provide fields and new_coord arguments of equal length if providing new_coord argument.&#39;</span><span class="p">)</span>

    <span class="c"># EXIT POINT</span>
    <span class="k">return</span> <span class="n">fields</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span> <span class="n">name</span> <span class="o">=</span> <span class="n">fields</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span><span class="n">name_suffix</span><span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span> <span class="p">[</span> <span class="n">F</span><span class="p">[:]</span> <span class="k">for</span> <span class="n">F</span> <span class="ow">in</span> <span class="n">fields</span> <span class="p">]</span> <span class="p">)</span> <span class="p">,</span> <span class="n">grid</span> <span class="o">=</span> <span class="n">new_coord</span><span class="o">*</span><span class="n">fields</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span> <span class="p">)</span>

  <span class="c"># CASE A &quot;new_coord&quot; arg not given</span>

  <span class="k">if</span> <span class="n">ax</span> <span class="ow">and</span> <span class="p">(</span><span class="n">ax</span><span class="o">*</span><span class="n">fields</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">):</span>
    <span class="c"># CASE A2</span>
    <span class="c"># the axis is given but is not in the grid of the first Field</span>
    <span class="c"># We will construct new Coord with new_coord_name and axis is ax</span>
    <span class="c"># Then, the regridded Field objects will always have the ax in their grid, and can be sent to the Field.cat method.</span>
    <span class="n">expanded_fields</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">if</span> <span class="n">strings</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>    
      <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">F</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">fields</span><span class="p">):</span>
        <span class="n">new_coord</span> <span class="o">=</span> <span class="n">Coord</span><span class="p">(</span><span class="n">name</span> <span class="o">=</span> <span class="n">new_coord_name</span><span class="p">,</span><span class="n">value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">float</span><span class="p">(</span><span class="n">i</span><span class="p">)]),</span> <span class="n">direction</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">name</span> <span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="n">ax</span> <span class="p">,</span> <span class="n">strings</span> <span class="o">=</span> <span class="p">[</span><span class="n">strings</span><span class="p">[</span><span class="n">i</span><span class="p">],],</span> <span class="n">associative</span> <span class="o">=</span> <span class="n">ax</span> <span class="p">)</span>
        <span class="n">expanded_fields</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">F</span><span class="o">.</span><span class="n">regrid</span><span class="p">(</span><span class="n">new_coord</span><span class="o">*</span><span class="n">F</span><span class="o">.</span><span class="n">grid</span><span class="p">)</span> <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
 
      <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">F</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">fields</span><span class="p">):</span>
        <span class="n">new_coord</span> <span class="o">=</span> <span class="n">Coord</span><span class="p">(</span><span class="n">name</span> <span class="o">=</span> <span class="n">new_coord_name</span><span class="p">,</span><span class="n">value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">i</span><span class="p">]),</span> <span class="n">direction</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">name</span> <span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="n">ax</span> <span class="p">,</span> <span class="n">associative</span> <span class="o">=</span> <span class="n">ax</span>  <span class="p">)</span>
        <span class="n">expanded_fields</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">F</span><span class="o">.</span><span class="n">regrid</span><span class="p">(</span><span class="n">new_coord</span><span class="o">*</span><span class="n">F</span><span class="o">.</span><span class="n">grid</span><span class="p">)</span> <span class="p">)</span>

    <span class="n">fields</span> <span class="o">=</span> <span class="n">expanded_fields</span>    
    <span class="n">name_suffix</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>

  <span class="c"># At this point, the Field grids will always have the ax argument direction in them, either because it was always there, or because we just added a newly created Coord.</span>
  <span class="c"># That means that here we have:</span>
  <span class="c">#  CASE A0: ax is None. Field.cat method will find natural Coord to cat </span>
  <span class="c">#  CASE A1: ax was already in grid.</span>
  <span class="c">#  CASE A2: ax was not in grid, but is now with newly constructed new_coord.</span>

  <span class="c"># EXIT POINT</span>
  <span class="k">return</span> <span class="nb">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">:</span><span class="n">x</span><span class="o">.</span><span class="n">cat</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">name_suffix</span> <span class="o">=</span> <span class="n">name_suffix</span><span class="p">),</span> <span class="n">fields</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="squeeze"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.squeeze">[docs]</a><span class="k">def</span> <span class="nf">squeeze</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">hard</span> <span class="o">=</span> <span class="bp">False</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Equivalent to Numpy squeeze method. Remove dimensions and associated coords in grid of length 1. Reversible operation as squeezed dimensions are stored in different attribute (squeezed_dims). Setting argument &quot;hard&quot; to True yields an irreversible squeeze where the squeezed dims are not recorded (and cannot be unsqueezed later). </span>

<span class="sd">  See also: Field.unsqueeze</span>
<span class="sd">  &quot;&quot;&quot;</span>


  <span class="k">if</span> <span class="n">hard</span><span class="p">:</span>
    <span class="n">new_grid</span><span class="p">,</span>  <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>    
    <span class="n">squeezed_grid</span> <span class="o">=</span> <span class="n">Gr</span><span class="p">()</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">new_grid</span><span class="p">,</span> <span class="n">squeezed_grid</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>

  <span class="n">body</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
 
  <span class="k">return</span> <span class="n">F</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="n">body</span><span class="p">,</span><span class="n">grid</span> <span class="o">=</span> <span class="n">new_grid</span> <span class="p">,</span> <span class="n">squeezed_dims</span> <span class="o">=</span>  <span class="n">squeezed_grid</span> <span class="p">)</span>
</div>
<div class="viewcode-block" id="unsqueeze"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.unsqueeze">[docs]</a><span class="k">def</span> <span class="nf">unsqueeze</span><span class="p">(</span><span class="n">F</span> <span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Opposite of squeeze. Uses the grid stored in squeezed_dims Field attribute to restore the unit-length dimensions (coords) of the Field. </span>
<span class="sd">  </span>
<span class="sd">  See also: Field.squeeze</span>
<span class="sd">  &quot;&quot;&quot;</span>

  <span class="n">gr_unsqueezed</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">squeezed_dims</span><span class="o">*</span><span class="n">F</span><span class="o">.</span><span class="n">grid</span>

  <span class="k">return</span> <span class="n">F</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span> <span class="n">value</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">gr_unsqueezed</span><span class="o">.</span><span class="n">shape</span><span class="p">()</span> <span class="p">)</span> <span class="p">,</span> <span class="n">grid</span> <span class="o">=</span> <span class="n">gr_unsqueezed</span><span class="p">,</span> <span class="n">squeezed_dims</span> <span class="o">=</span>  <span class="n">Gr</span><span class="p">(</span> <span class="p">()</span> <span class="p">)</span>  <span class="p">)</span>

 



</div>
<div class="viewcode-block" id="nugget"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.nugget">[docs]</a><span class="k">def</span> <span class="nf">nugget</span><span class="p">(</span><span class="n">path</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">name</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span><span class="n">fields</span> <span class="o">=</span> <span class="p">[]</span> <span class="p">,</span> <span class="n">history</span> <span class="o">=</span> <span class="s">&#39;Created from Spacegrids &#39;</span>  <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Creates Netcdf file and writes all loaded Field to it, along with their Coord objects.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
      <span class="n">name</span> <span class="o">=</span> <span class="s">&#39;nugget&#39;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;.&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&#39;nc&#39;</span><span class="p">,</span><span class="s">&#39;cdf&#39;</span><span class="p">]:</span>
      <span class="n">name</span> <span class="o">=</span> <span class="n">name</span> <span class="o">+</span><span class="s">&#39;.nc&#39;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">path</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
      <span class="n">name</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span> <span class="n">path</span> <span class="p">,</span> <span class="n">name</span> <span class="p">)</span> 
   
    

    <span class="k">print</span> <span class="s">&#39;Writing Field to file </span><span class="si">%s</span><span class="s">&#39;</span><span class="o">%</span><span class="n">name</span>

    <span class="k">try</span><span class="p">:</span>
      <span class="n">file_handle</span> <span class="o">=</span> <span class="n">netcdf_file</span><span class="p">(</span><span class="n">name</span> <span class="p">,</span> <span class="s">&#39;w&#39;</span><span class="p">)</span>

    <span class="k">except</span> <span class="ne">IOError</span><span class="p">:</span>
      <span class="k">print</span> <span class="s">&#39;Cannot open </span><span class="si">%s</span><span class="s">&#39;</span><span class="o">%</span><span class="n">name</span>

    <span class="k">else</span><span class="p">:</span>

      <span class="k">for</span> <span class="n">fld</span> <span class="ow">in</span> <span class="n">fields</span><span class="p">:</span>

        <span class="n">file_handle</span> <span class="o">=</span> <span class="n">fld</span><span class="o">.</span><span class="n">_cdf_insert</span><span class="p">(</span><span class="n">file_handle</span><span class="p">)</span>

      <span class="n">file_handle</span><span class="o">.</span><span class="n">history</span> <span class="o">=</span> <span class="n">history</span> <span class="o">+</span> <span class="s">&#39;</span><span class="si">%s</span><span class="s">&#39;</span><span class="o">%</span><span class="nb">str</span><span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">())</span>
 
<span class="c">#    var_cdf.units = self.units</span>

      <span class="n">file_handle</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>



</div>
<div class="viewcode-block" id="roll"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.roll">[docs]</a><span class="k">def</span> <span class="nf">roll</span><span class="p">(</span><span class="n">F</span><span class="p">,</span><span class="n">shift</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">coord</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">mask</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">keepgrid</span> <span class="o">=</span> <span class="bp">False</span><span class="p">,</span> <span class="n">nan_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Function that rolls a Field similar to np.roll on numpy arrays. </span>

<span class="sd">  sg.roll actually calls np.roll. Axis can be picked via coord name. If mask is True, the elements that rolled from the other side of the array are set to nan (appropriate for non re-entrant domains). The rolled coord element of the grid belonging to Field F is replaced by a new Coord object reflecting the roll operation. To disable this Coord replacement, use argument keepgrid = True</span>

<span class="sd">  Args:</span>
<span class="sd">    F: (Field) to roll</span>
<span class="sd">    shift: (int) to roll by</span>
<span class="sd">    coord: (Coord) to roll along (e.g. latitude)</span>
<span class="sd">    axis: (int) indicates np.array index to roll by: generally not set.</span>
<span class="sd">    mask: (Boolean) if True, handle exposed areas that need to be set to nan</span>
<span class="sd">    keepgrid: (Boolean) if True, keep the original Field grid (replaced with shifted by default)  </span>
<span class="sd">    nan_val: (np.nan) value to indicate nan</span>

<span class="sd">  Returns:</span>
<span class="sd">    Rolled Field.</span>
<span class="sd">  &quot;&quot;&quot;</span>

  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">coord</span><span class="p">,</span><span class="n">Ax</span><span class="p">):</span>
    <span class="n">coord</span> <span class="o">=</span> <span class="n">coord</span><span class="o">*</span><span class="n">F</span><span class="o">.</span><span class="n">grid</span>

  <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">F</span><span class="o">.</span><span class="n">grid</span><span class="p">:</span>
      
      <span class="n">axis</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">coord</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">print</span> <span class="s">&#39;coord not in Field grid&#39;</span>
      <span class="k">return</span> 

<span class="c"># avoid deepcopy for fields</span>
<span class="c"># Fr is the rolled Field.</span>

  <span class="k">if</span> <span class="n">keepgrid</span> <span class="ow">is</span> <span class="bp">True</span><span class="p">:</span>
    <span class="c"># keep the original grid of Field F</span>
    <span class="n">newgr</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">grid</span> 
  <span class="k">elif</span> <span class="n">keepgrid</span> <span class="ow">is</span> <span class="bp">False</span><span class="p">:</span>
    <span class="c"># replace the grid with one with rolled coord</span>
    <span class="n">newgr</span> <span class="o">=</span> <span class="n">coord</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">shift</span> <span class="o">=</span> <span class="n">shift</span><span class="p">)</span><span class="o">*</span><span class="n">F</span><span class="o">.</span><span class="n">grid</span> 
  <span class="k">else</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;Argument error in roll of Field </span><span class="si">%s</span><span class="s">. Provide True or False for keepgrid argument. &#39;</span><span class="p">)</span> <span class="o">%</span> <span class="n">F</span>


  <span class="n">Fr</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">value</span><span class="p">,</span><span class="n">shift</span><span class="o">=</span><span class="n">shift</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">),</span> <span class="n">grid</span> <span class="o">=</span> <span class="n">newgr</span> <span class="p">)</span>
  
  <span class="k">if</span> <span class="n">mask</span><span class="p">:</span>
    <span class="c"># handle the areas in the Field that need to be set to nan</span>
    <span class="n">sl</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="bp">None</span><span class="p">,))</span>
    
    <span class="k">if</span> <span class="n">shift</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
     
      <span class="n">sl_exposed</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">shift</span><span class="p">,</span><span class="bp">None</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">shift</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
<span class="c"># note that shift is negative here, indicating last elements of array.</span>
      <span class="n">sl_exposed</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">shift</span><span class="p">,</span><span class="bp">None</span><span class="p">,</span><span class="bp">None</span><span class="p">)</span>


    <span class="n">L</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">F</span><span class="o">.</span><span class="n">grid</span><span class="p">:</span>
      <span class="n">L</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sl</span><span class="p">)</span>
    <span class="n">L</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">sl_exposed</span>
    <span class="n">Fr</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="n">L</span><span class="p">]</span> <span class="o">=</span> <span class="n">nan_val</span>

  <span class="k">return</span> <span class="n">Fr</span>
</div>
<div class="viewcode-block" id="ones"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.ones">[docs]</a><span class="k">def</span> <span class="nf">ones</span><span class="p">(</span><span class="n">grid</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Returns a Field with value np.ones(grid.shape) and grid attribute grid.</span>

<span class="sd">  No nans.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="n">Field</span><span class="p">(</span><span class="s">&#39;ones&#39;</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">()),</span><span class="n">grid</span><span class="p">)</span>


</div>
<div class="viewcode-block" id="finer_field"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.finer_field">[docs]</a><span class="k">def</span> <span class="nf">finer_field</span><span class="p">(</span><span class="n">F</span><span class="p">,</span><span class="n">factor</span> <span class="o">=</span><span class="mf">5.</span><span class="p">):</span>

  <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  This is a more UVic specific function to prepare a Field containing the outline of the continents for horizontal plots.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  
  <span class="k">return</span> <span class="n">F</span><span class="p">(</span><span class="n">finer_grid</span><span class="p">(</span><span class="n">grid</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span><span class="n">factor</span> <span class="o">=</span> <span class="n">factor</span><span class="p">),</span><span class="n">method</span> <span class="o">=</span><span class="s">&#39;nearest&#39;</span><span class="p">)</span>






<span class="c"># ------------- some Coord related functions ----------------------</span>



<span class="c"># used in function cdfsniff</span></div>
<span class="n">cdf_axes</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;X&#39;</span><span class="p">:</span><span class="n">XCoord</span><span class="p">,</span><span class="s">&#39;Y&#39;</span><span class="p">:</span><span class="n">YCoord</span><span class="p">,</span><span class="s">&#39;Z&#39;</span><span class="p">:</span><span class="n">Coord</span><span class="p">,</span><span class="s">&#39;T&#39;</span><span class="p">:</span><span class="n">Coord</span><span class="p">,</span><span class="s">&#39;scalar&#39;</span><span class="p">:</span><span class="n">Coord</span><span class="p">}</span>



<div class="viewcode-block" id="make_dual"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.make_dual">[docs]</a><span class="k">def</span> <span class="nf">make_dual</span><span class="p">(</span><span class="n">crd</span><span class="p">,</span><span class="n">name</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span><span class="n">guess_append</span> <span class="o">=</span> <span class="bp">True</span><span class="p">,</span><span class="n">append_last</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">zero_boundary</span> <span class="o">=</span> <span class="bp">False</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Create a dual Coord by appending one entry, of which the width is guessed based on the adjacent cell width.</span>
<span class="sd">  &quot;&quot;&quot;</span>

  <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">crd</span><span class="o">.</span><span class="n">name</span>

  <span class="k">if</span> <span class="n">guess_append</span><span class="p">:</span>
    <span class="c"># Guesses according to CSIRO  model conventions</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">crd</span><span class="o">.</span><span class="n">direction</span> <span class="o">==</span> <span class="s">&#39;X&#39;</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">crd</span><span class="o">.</span><span class="n">direction</span> <span class="o">==</span> <span class="s">&#39;Y&#39;</span><span class="p">):</span>
      <span class="n">append_last</span> <span class="o">=</span> <span class="bp">False</span> 
    <span class="k">else</span><span class="p">:</span>
      <span class="n">append_last</span> <span class="o">=</span> <span class="bp">True</span>      

  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">crd</span><span class="o">.</span><span class="n">value</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">append_last</span><span class="p">:</span>
      <span class="n">value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">crd</span><span class="o">.</span><span class="n">value</span> <span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">crd</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">crd</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]))</span>

    <span class="k">else</span><span class="p">:</span>
  
      <span class="n">value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">crd</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">crd</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span><span class="n">crd</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>

  <span class="k">else</span><span class="p">:</span>
      <span class="n">value</span> <span class="o">=</span> <span class="n">crd</span><span class="o">.</span><span class="n">value</span><span class="p">[:]</span>
 
  <span class="k">return</span> <span class="n">crd</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span> <span class="o">+</span><span class="s">&#39;_edges&#39;</span><span class="p">,</span><span class="n">value</span><span class="o">=</span> <span class="n">value</span><span class="p">,</span> <span class="n">long_name</span> <span class="o">=</span> <span class="n">crd</span><span class="o">.</span><span class="n">long_name</span> <span class="o">+</span> <span class="s">&#39; as edges&#39;</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="find_set_dual"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.find_set_dual">[docs]</a><span class="k">def</span> <span class="nf">find_set_dual</span><span class="p">(</span><span class="n">cstack</span><span class="p">,</span> <span class="n">force</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  This function tries to find duals among a list cstack (argument) of Coord objects.</span>

<span class="sd">  Checks if duals have been defined before. If one such Coord is found, function is aborted (it is assumed it is not needed then). Override with argument force = True.</span>
<span class="sd">  &quot;&quot;&quot;</span>

  <span class="k">if</span> <span class="n">force</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
    <span class="c"># Check if duals have been defined before. If one such Coord is found, function is aborted (it is assumed it is not needed then).</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cstack</span><span class="p">:</span>
      <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">dual</span> <span class="o">!=</span> <span class="n">c</span><span class="p">:</span>
     
        <span class="k">return</span> <span class="n">cstack</span>

  <span class="c"># create grid, and therefore tuple, of all axis objects associated with Coord objects in list cstack.</span>
  <span class="n">axes_available</span> <span class="o">=</span> <span class="nb">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">:</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">,</span> <span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">axis</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cstack</span><span class="p">])</span>


  <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">axes_available</span><span class="p">:</span>
    <span class="c"># L is list of all Coord objects that have same axis.</span>
    <span class="n">L</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cstack</span> <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">axis</span> <span class="o">==</span> <span class="n">a</span><span class="p">]</span>
    
    <span class="c"># if this has two elements, these are considered duals.</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">L</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
  
    <span class="c"># only unique pairs with the same axis will be interpreted as duals.    </span>
      <span class="k">if</span> <span class="n">_guess_grid_type</span><span class="p">(</span><span class="n">L</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="s">&#39;ts_grid&#39;</span><span class="p">:</span>
        <span class="n">crd_dual</span> <span class="o">=</span> <span class="n">make_dual</span><span class="p">(</span><span class="n">L</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">name</span> <span class="o">=</span> <span class="n">L</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="p">)</span> 
        <span class="n">L</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dual</span> <span class="o">=</span> <span class="n">crd_dual</span>
      <span class="k">elif</span> <span class="n">_guess_grid_type</span><span class="p">(</span><span class="n">L</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="s">&#39;ts_grid&#39;</span><span class="p">:</span>
        <span class="n">crd_dual</span> <span class="o">=</span> <span class="n">make_dual</span><span class="p">(</span><span class="n">L</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">name</span> <span class="o">=</span> <span class="n">L</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="p">)</span> 
        <span class="n">L</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">dual</span> <span class="o">=</span> <span class="n">crd_dual</span>

    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">L</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
       
        <span class="n">crd_dual</span> <span class="o">=</span> <span class="n">make_dual</span><span class="p">(</span><span class="n">L</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">name</span> <span class="o">=</span> <span class="n">L</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="p">)</span> 
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">crd_dual</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
          <span class="n">L</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dual</span> <span class="o">=</span> <span class="n">crd_dual</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="c"># in this case, the Coord is made to be self-dual. this could happen for a time Coord with only 1 time slice. make_dual will return a length 1 dual for a Coord of length 1. Note that for UVic data this else clause is NOT needed to make the Coord self dual. </span>
          <span class="n">L</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dual</span> <span class="o">=</span> <span class="n">L</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        
  <span class="k">return</span> <span class="n">cstack</span>
      



</div>
<div class="viewcode-block" id="find_equal_axes"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.find_equal_axes">[docs]</a><span class="k">def</span> <span class="nf">find_equal_axes</span><span class="p">(</span><span class="n">lstack</span><span class="p">,</span><span class="n">rstack</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Expects two lists of Coord objects and determines which Coord objects are equal. </span>

<span class="sd">  This is needed when different Coord objects have identical attributes. Acts directly on the Coord stack arguments. This function is generally called before axis attributes are converted from str to Ax objects.</span>

<span class="sd">  Args:</span>
<span class="sd">    lstack: (list of Coord objects), the first Coord stack</span>
<span class="sd">    rstack: (list of Coord objects), the second Coord stack</span>
<span class="sd">  &quot;&quot;&quot;</span>

  <span class="k">for</span> <span class="n">lc</span> <span class="ow">in</span> <span class="n">lstack</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">rc</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">rstack</span><span class="p">):</span>

      <span class="c"># this == would have to become lc.axis.same(rc.axis) for Ax objects.</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">lc</span><span class="o">.</span><span class="n">axis</span> <span class="o">==</span> <span class="n">rc</span><span class="o">.</span><span class="n">axis</span><span class="p">):</span>
        <span class="c"># use Coord equality method &amp; (__and__):</span>
        <span class="k">if</span> <span class="n">lc</span><span class="o">.</span><span class="n">weaksame</span><span class="p">(</span><span class="n">rc</span><span class="p">):</span>
          <span class="c"># if all 3 attributes are equal values, replace right stack element with left stack element</span>
          <span class="n">rstack</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">lc</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="c"># in this case the Coord elements only have the same axis attribute, and are merely equivalent.</span>
          <span class="k">if</span> <span class="ow">not</span> <span class="n">rstack</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">is_equiv</span><span class="p">(</span><span class="n">lc</span><span class="p">):</span>
            <span class="n">rstack</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">make_equiv</span><span class="p">(</span><span class="n">lc</span><span class="p">)</span>


<span class="c">#  return rstack</span>




<span class="c"># -------- io related Coord functions --------------------</span>

</div>
<div class="viewcode-block" id="cdfsniff"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.cdfsniff">[docs]</a><span class="k">def</span> <span class="nf">cdfsniff</span><span class="p">(</span><span class="n">path_parent</span><span class="p">,</span> <span class="n">file_extensions</span> <span class="o">=</span> <span class="n">cdf_file_extensions</span><span class="p">,</span> <span class="n">verbose</span> <span class="o">=</span> <span class="bp">False</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Looks inside the path_parent path for Netcdf files and extracts Coord objects from the dim data.</span>

<span class="sd">  Path is to directory containing the Netcdf files, provided as argument.  </span>

<span class="sd">  Uses sg._cdfsniff_helper.</span>

<span class="sd">  Args:</span>
<span class="sd">    path_parent: (str) path to directory containing the Netcdf files</span>
<span class="sd">    file_extensions: (list of str) containing patterns to match Netcdf files</span>

<span class="sd">  Returns:</span>
<span class="sd">    List of all Coord objects that contain different data, to be used in the Coord stack cstack.</span>
<span class="sd">  &quot;&quot;&quot;</span>

  <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">path_parent</span><span class="p">):</span>
    <span class="c"># In this case, a file path is provided. This occurs when experiment object correspond to (Netcdf) files instead of directories containing Netcdf files.</span>
    <span class="k">return</span> <span class="n">rem_equivs</span><span class="p">(</span><span class="n">_cdfsniff_helper</span><span class="p">(</span> <span class="n">path_parent</span> <span class="p">,</span> <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span> <span class="p">))</span>

  <span class="c"># all files within path_parent</span>
  <span class="n">fnames</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">path_parent</span><span class="p">)</span>

  <span class="c"># cstack will contain all Coord objects constructed from dims in Netcdf </span>
  <span class="n">cstack</span> <span class="o">=</span> <span class="p">[]</span>

  <span class="c"># prepare glob patterns to look for Netcdf files</span>
  <span class="n">globfpaths</span> <span class="o">=</span> <span class="p">[</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path_parent</span> <span class="p">,</span> <span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">file_extensions</span><span class="p">]</span>

  <span class="n">cdf_filepaths</span> <span class="o">=</span> <span class="nb">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">,</span> <span class="p">[</span><span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">globfpaths</span>  <span class="p">]</span>  <span class="p">)</span>

  <span class="c"># construct combined cstack out of individual Netcdf files via _cdfsniff_helper: </span>
  <span class="k">for</span> <span class="n">cdf_filepath</span> <span class="ow">in</span> <span class="n">cdf_filepaths</span><span class="p">:</span>

    <span class="n">cstack</span> <span class="o">=</span> <span class="n">cstack</span> <span class="o">+</span> <span class="n">_cdfsniff_helper</span><span class="p">(</span> <span class="n">cdf_filepath</span> <span class="p">,</span> <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span> <span class="p">)</span>

  <span class="c"># remove equivalent Coord objects (containing the same data) and return    </span>
  <span class="k">return</span> <span class="n">rem_equivs</span><span class="p">(</span><span class="n">cstack</span><span class="p">)</span>

</div>
<span class="k">def</span> <span class="nf">_cdfsniff_helper</span><span class="p">(</span><span class="n">filepath</span><span class="p">,</span> <span class="n">verbose</span> <span class="o">=</span> <span class="bp">False</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Takes inventory of coords in netcdf file. </span>

<span class="sd">  Directions and therefore types of Coord objects (e.g. XCoord) are guessed from description and naming of Netcdf vars.</span>

<span class="sd">  Args:</span>
<span class="sd">    filepath	total file path the specific Netcdf file.</span>

<span class="sd">  Returns:</span>
<span class="sd">    A list of spacegrids Coord objects.</span>
<span class="sd">  &quot;&quot;&quot;</span>

<span class="c"># axis to the possible axes encountered in netcdf: X,Y,Z</span>
  <span class="k">global</span> <span class="n">cdf_axes</span>

  <span class="nb">file</span> <span class="o">=</span> <span class="n">netcdf_file</span><span class="p">(</span><span class="n">filepath</span><span class="p">,</span><span class="s">&#39;r&#39;</span><span class="p">)</span>

  <span class="n">coord_stack</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="n">dimensions</span> <span class="o">=</span> <span class="nb">file</span><span class="o">.</span><span class="n">dimensions</span>
 
  <span class="n">dimensions</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">dimensions</span> <span class="k">if</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">file</span><span class="o">.</span><span class="n">variables</span><span class="p">]</span>

  <span class="k">for</span> <span class="n">dim_name</span> <span class="ow">in</span> <span class="n">dimensions</span><span class="p">:</span>

    <span class="c"># guess which direction the Coord is pointing in, based on netcdf descriptions. The netcdf .axis attribute is included!</span>
    <span class="c"># leave directional_names wild card: no filter on general name (e.g. velocity).</span>

    <span class="c"># maybe rely more on this dictionary in future:</span>
    <span class="n">metadata</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span><span class="nb">file</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">dim_name</span><span class="p">]</span><span class="o">.</span><span class="n">__dict__</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">file</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">dim_name</span><span class="p">]</span><span class="o">.</span><span class="n">__dict__</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&#39;data&#39;</span><span class="p">,</span><span class="s">&#39;dimensions&#39;</span><span class="p">,</span><span class="s">&#39;_shape&#39;</span><span class="p">,</span><span class="s">&#39;_size&#39;</span><span class="p">]</span>  <span class="p">}</span>

    <span class="n">coord_name</span> <span class="o">=</span> <span class="n">dim_name</span>
    
    <span class="n">direction</span> <span class="o">=</span> <span class="n">guess_direction</span><span class="p">(</span><span class="nb">file</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">dim_name</span><span class="p">],</span>  <span class="n">name_atts</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;axis&#39;</span><span class="p">,</span><span class="s">&#39;long_name&#39;</span><span class="p">,</span><span class="s">&#39;standard_name&#39;</span><span class="p">]</span> <span class="p">,</span> <span class="n">x_dir_names</span> <span class="o">=</span> <span class="n">coord_dir_names</span><span class="p">[</span><span class="s">&#39;x_dir_names&#39;</span><span class="p">],</span> <span class="n">y_dir_names</span> <span class="o">=</span> <span class="n">coord_dir_names</span><span class="p">[</span><span class="s">&#39;y_dir_names&#39;</span><span class="p">],</span> <span class="n">z_dir_names</span> <span class="o">=</span> <span class="n">coord_dir_names</span><span class="p">[</span><span class="s">&#39;z_dir_names&#39;</span><span class="p">],</span><span class="n">t_dir_names</span> <span class="o">=</span> <span class="n">coord_dir_names</span><span class="p">[</span><span class="s">&#39;t_dir_names&#39;</span><span class="p">],</span><span class="n">directional_names</span> <span class="o">=</span> <span class="s">&#39;*&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">direction</span> <span class="o">==</span> <span class="s">&#39;scalar&#39;</span><span class="p">:</span>
      <span class="c"># double check that this Coord has no direction by looking at dim_name itself.</span>
      <span class="k">if</span> <span class="n">dim_name</span> <span class="ow">in</span> <span class="n">cdf_axes</span><span class="p">:</span>
        <span class="n">direction</span> <span class="o">=</span> <span class="n">dim_name</span>
        <span class="n">coord_name</span> <span class="o">=</span> <span class="n">dim_name</span> <span class="o">+</span> <span class="s">&#39;_crd&#39;</span>
        <span class="k">print</span> <span class="s">&#39;OK. Inferring direction from dimension name </span><span class="si">%s</span><span class="s"> itself. Renaming Coord to </span><span class="si">%s</span><span class="s">. &#39;</span><span class="o">%</span><span class="p">(</span><span class="n">dim_name</span><span class="p">,</span><span class="n">coord_name</span><span class="p">)</span>

      <span class="k">else</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&#39;No direction inferred for </span><span class="si">%s</span><span class="s">. Guessed direction is scalar.&#39;</span><span class="o">%</span><span class="n">dim_name</span><span class="p">)</span>


    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="nb">file</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">dim_name</span><span class="p">],</span><span class="s">&#39;units&#39;</span><span class="p">):</span>
      <span class="n">units</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="nb">file</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">dim_name</span><span class="p">]</span><span class="o">.</span><span class="n">units</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">units</span> <span class="o">=</span> <span class="s">&#39;?&#39;</span>
      <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&#39;(mild): no units assigned to </span><span class="si">%s</span><span class="s"> in cdfsniff&#39;</span><span class="o">%</span><span class="n">dim_name</span> <span class="p">)</span>

    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="nb">file</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">dim_name</span><span class="p">],</span><span class="s">&#39;long_name&#39;</span><span class="p">):</span>
      <span class="n">long_name</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="nb">file</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">dim_name</span><span class="p">]</span><span class="o">.</span><span class="n">long_name</span> <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">long_name</span> <span class="o">=</span> <span class="s">&#39;?&#39;</span>
      <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>

        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&#39;No long_name for </span><span class="si">%s</span><span class="s">. Assigning </span><span class="si">%s</span><span class="s">&#39;</span><span class="o">%</span><span class="p">(</span><span class="n">dim_name</span><span class="p">,</span> <span class="n">coord_name</span><span class="p">)</span> <span class="p">)</span>
      <span class="n">long_name</span> <span class="o">=</span> <span class="n">coord_name</span>

    <span class="c"># look only at the keys</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="nb">file</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">dim_name</span><span class="p">]</span> <span class="p">,</span> <span class="s">&#39;axis&#39;</span> <span class="p">):</span>
      <span class="c"># If the netcdf vatiable has an axis attribute, as in UVic, we look for edges to determine the dual and assign an axis attribute. </span>

      <span class="c"># only edges Coord objects do not have an axis attribute, so edges</span>
      <span class="c"># Coord objects need to be created simultaneously with their dual.</span>
      <span class="c"># note that time coords have axis attributes but not edges (self-dual).</span>

      <span class="c"># Get the netcdf name of the dual variable (the edges, or bounds). Failure signal is None.</span>
      <span class="n">dual_var_name</span> <span class="o">=</span> <span class="n">get_att</span><span class="p">(</span><span class="nb">file</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">dim_name</span><span class="p">],</span> <span class="n">edge_names</span><span class="p">,</span> <span class="n">fail_val</span> <span class="o">=</span> <span class="bp">None</span><span class="p">)</span>

      <span class="k">if</span> <span class="n">dual_var_name</span> <span class="o">!=</span> <span class="bp">None</span><span class="p">:</span>
        <span class="c"># if edges are defined, we create Coord and its dual in pairs</span>
        <span class="k">if</span> <span class="nb">file</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">dim_name</span><span class="p">]</span><span class="o">.</span><span class="n">axis</span> <span class="ow">in</span> <span class="n">cdf_axes</span><span class="p">:</span>

          <span class="c"># convert the netcdf name of the dual to an actual cdf variable</span>
          <span class="k">if</span> <span class="n">dual_var_name</span> <span class="ow">in</span> <span class="nb">file</span><span class="o">.</span><span class="n">variables</span><span class="p">:</span>
          
            <span class="n">dual_var</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="nb">file</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">dual_var_name</span><span class="p">][:]</span> <span class="p">)</span>
          <span class="k">else</span><span class="p">:</span>

<span class="c"># THIS IS A TEMPORARY FUDGE IN CASE A FILE HINTS AT COORD EDGES BUT DOESN&#39;T STORE THEM:</span>
             <span class="n">dual_var</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="nb">file</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">dim_name</span><span class="p">][:]</span> <span class="p">)</span>           
       
       
          <span class="c"># using call method of Coord object in cdf_axes global</span>

          <span class="n">this_coord</span> <span class="o">=</span> <span class="n">cdf_axes</span><span class="p">[</span><span class="n">direction</span><span class="p">](</span><span class="n">coord_name</span><span class="p">,</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span> <span class="nb">file</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">dim_name</span><span class="p">][:]</span> <span class="p">),</span> <span class="n">axis</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="nb">file</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">dim_name</span><span class="p">]</span><span class="o">.</span><span class="n">axis</span> <span class="p">),</span><span class="n">direction</span> <span class="o">=</span> <span class="n">direction</span><span class="p">,</span> <span class="n">units</span> <span class="o">=</span> <span class="n">units</span><span class="p">,</span> <span class="n">long_name</span> <span class="o">=</span> <span class="n">long_name</span> <span class="p">,</span> <span class="n">metadata</span> <span class="o">=</span> <span class="n">metadata</span><span class="p">)</span>  

          <span class="c">#this_coord = cdf_axes[file.variables[dim_name].axis](dim_name, file.variables[dim_name][:], axis = file.variables[dim_name].axis, units = units)  </span>
          <span class="n">dual_coord</span> <span class="o">=</span> <span class="n">cdf_axes</span><span class="p">[</span><span class="n">direction</span><span class="p">](</span><span class="n">dual_var_name</span><span class="p">,</span><span class="n">_prep_dual_array</span><span class="p">(</span><span class="n">dual_var</span><span class="p">),</span><span class="n">dual</span> <span class="o">=</span> <span class="n">this_coord</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="nb">file</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">dim_name</span><span class="p">]</span><span class="o">.</span><span class="n">axis</span> <span class="p">),</span> <span class="n">direction</span> <span class="o">=</span> <span class="n">direction</span><span class="p">,</span> <span class="n">units</span> <span class="o">=</span> <span class="n">units</span><span class="p">,</span> <span class="n">long_name</span> <span class="o">=</span> <span class="n">long_name</span><span class="p">,</span> <span class="n">metadata</span> <span class="o">=</span> <span class="n">metadata</span><span class="p">)</span>

          <span class="n">this_coord</span><span class="o">.</span><span class="n">dual</span> <span class="o">=</span> <span class="n">dual_coord</span>

          <span class="n">coord_stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">this_coord</span><span class="p">)</span>
          <span class="n">coord_stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dual_coord</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
          <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&#39;Unknown axis.&#39;</span><span class="p">,</span><span class="ne">RuntimeWarning</span><span class="p">)</span>

      <span class="k">else</span><span class="p">:</span>
        <span class="c"># this is the case of self-dual objects such as time, so only 1 object needs to be made</span>
        <span class="k">if</span> <span class="nb">file</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">dim_name</span><span class="p">]</span><span class="o">.</span><span class="n">axis</span> <span class="ow">in</span> <span class="n">cdf_axes</span><span class="p">:</span>
          <span class="n">coord_stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cdf_axes</span><span class="p">[</span><span class="n">direction</span><span class="p">](</span><span class="n">coord_name</span><span class="p">,</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="nb">file</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">dim_name</span><span class="p">][:]</span> <span class="p">),</span> <span class="n">axis</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="nb">file</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">dim_name</span><span class="p">]</span><span class="o">.</span><span class="n">axis</span> <span class="p">),</span><span class="n">direction</span> <span class="o">=</span> <span class="n">direction</span><span class="p">,</span> <span class="n">units</span> <span class="o">=</span> <span class="n">units</span><span class="p">,</span> <span class="n">long_name</span> <span class="o">=</span> <span class="n">long_name</span> <span class="p">,</span> <span class="n">metadata</span> <span class="o">=</span> <span class="n">metadata</span> <span class="p">))</span>

    <span class="k">else</span><span class="p">:</span>
    <span class="c"># In this case, no axis attribute has been detected.</span>
      <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="k">print</span> <span class="s">&#39;No Netcdf axis attribute detected. Creating attribute from direction guess.&#39;</span>

      <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="nb">file</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">dim_name</span><span class="p">]</span> <span class="p">,</span> <span class="s">&#39;edges&#39;</span> <span class="p">):</span>
        <span class="c"># if edges are defined, we create coord and its dual in pairs</span>
        <span class="k">if</span> <span class="n">direction</span> <span class="ow">in</span> <span class="n">cdf_axes</span><span class="p">:</span>
          <span class="n">dual_var</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="nb">file</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="nb">file</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">dim_name</span><span class="p">]</span><span class="o">.</span><span class="n">edges</span><span class="p">][:]</span> <span class="p">)</span>

          <span class="c"># using call method of Coord object in cdf_axes global</span>

          <span class="n">this_coord</span> <span class="o">=</span> <span class="n">cdf_axes</span><span class="p">[</span><span class="n">direction</span><span class="p">](</span><span class="n">coord_name</span><span class="p">,</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="nb">file</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">dim_name</span><span class="p">]</span> <span class="p">[:]</span> <span class="p">),</span> <span class="n">axis</span> <span class="o">=</span> <span class="nb">file</span><span class="o">.</span><span class="n">direction</span><span class="p">,</span><span class="n">direction</span> <span class="o">=</span> <span class="n">direction</span><span class="p">,</span> <span class="n">units</span> <span class="o">=</span> <span class="n">units</span><span class="p">,</span> <span class="n">long_name</span> <span class="o">=</span> <span class="n">long_name</span><span class="p">,</span> <span class="n">metadata</span> <span class="o">=</span> <span class="n">metadata</span><span class="p">)</span>  

          <span class="c">#this_coord = cdf_axes[file.variables[dim_name].axis](dim_name, file.variables[dim_name][:], axis = file.variables[dim_name].axis, units = units)  </span>
          <span class="n">dual_coord</span> <span class="o">=</span> <span class="n">cdf_axes</span><span class="p">[</span><span class="n">direction</span><span class="p">](</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span> <span class="nb">file</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">dim_name</span><span class="p">]</span><span class="o">.</span><span class="n">edges</span> <span class="p">),</span><span class="n">_prep_dual_array</span><span class="p">(</span><span class="n">dual_var</span><span class="p">),</span><span class="n">dual</span> <span class="o">=</span> <span class="n">this_coord</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="n">direction</span><span class="p">,</span> <span class="n">direction</span> <span class="o">=</span> <span class="n">direction</span><span class="p">,</span> <span class="n">units</span> <span class="o">=</span> <span class="n">units</span><span class="p">,</span> <span class="n">long_name</span> <span class="o">=</span> <span class="n">long_name</span><span class="p">,</span> <span class="n">metadata</span> <span class="o">=</span> <span class="n">metadata</span><span class="p">)</span>


          <span class="n">this_coord</span><span class="o">.</span><span class="n">dual</span> <span class="o">=</span> <span class="n">dual_coord</span>

          <span class="n">coord_stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">this_coord</span><span class="p">)</span>
          <span class="n">coord_stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dual_coord</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
          <span class="n">warnings</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s">&#39;guessed direction not in cdf_axes, strange!&#39;</span><span class="p">)</span>  
      <span class="k">else</span><span class="p">:</span>
        <span class="c"># this is the case of self-dual objects such as time, so only 1 object needs to be made</span>
        <span class="k">if</span> <span class="n">direction</span> <span class="ow">in</span> <span class="n">cdf_axes</span><span class="p">:</span>
          <span class="n">coord_stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cdf_axes</span><span class="p">[</span><span class="n">direction</span><span class="p">](</span><span class="n">coord_name</span><span class="p">,</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="nb">file</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">dim_name</span><span class="p">][:]</span> <span class="p">),</span> <span class="n">axis</span> <span class="o">=</span> <span class="n">direction</span><span class="p">,</span><span class="n">direction</span> <span class="o">=</span> <span class="n">direction</span><span class="p">,</span> <span class="n">units</span> <span class="o">=</span> <span class="n">units</span> <span class="p">,</span><span class="n">long_name</span> <span class="o">=</span><span class="n">long_name</span><span class="p">,</span> <span class="n">metadata</span> <span class="o">=</span> <span class="n">metadata</span><span class="p">))</span>

        <span class="k">else</span><span class="p">:</span>
          <span class="n">warnings</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s">&#39;guessed direction not in cdf_axes, strange!&#39;</span><span class="p">)</span>  
  
  <span class="k">if</span> <span class="n">coord_stack</span><span class="p">:</span>
    <span class="n">bins</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">cdf_axes</span><span class="p">:</span>
      <span class="n">bins</span><span class="p">[</span><span class="n">ax</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
      <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">cc</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">coord_stack</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">ax</span> <span class="o">==</span> <span class="n">cc</span><span class="o">.</span><span class="n">axis</span><span class="p">:</span>
          <span class="n">bins</span><span class="p">[</span><span class="n">ax</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
 
    <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">bins</span><span class="p">:</span>
      <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">[</span><span class="n">name</span><span class="p">])</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">coord_stack</span><span class="p">[</span><span class="n">bins</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="n">i</span><span class="p">]]</span><span class="o">.</span><span class="n">make_equiv</span><span class="p">(</span><span class="n">coord_stack</span><span class="p">[</span><span class="n">bins</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]])</span>

  <span class="nb">file</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

  <span class="c"># if no duals were defined above, the following function call will detect the absence of duals and try to guess them:</span>


  <span class="k">return</span> <span class="n">coord_stack</span>





<span class="k">def</span> <span class="nf">_guess_helper</span><span class="p">(</span><span class="n">desc</span><span class="p">,</span> <span class="n">guess_names</span><span class="p">,</span> <span class="n">true_val</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">false_val</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Helper function for guess_direction</span>
<span class="sd">  &quot;&quot;&quot;</span>

  <span class="n">denied_found</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="ow">in</span> <span class="n">desc</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">guess_names</span> <span class="k">if</span> <span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span><span class="s">&#39;!&#39;</span><span class="p">]</span>
  <span class="k">if</span> <span class="n">denied_found</span><span class="p">:</span>
    <span class="n">deny</span> <span class="o">=</span> <span class="nb">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">:</span> <span class="n">x</span><span class="o">|</span> <span class="n">y</span> <span class="p">,</span> <span class="n">denied_found</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">deny</span> <span class="o">=</span> <span class="bp">False</span>
  <span class="n">allowed_found</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span> <span class="ow">in</span> <span class="n">desc</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">guess_names</span> <span class="k">if</span> <span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span><span class="s">&#39;!&#39;</span><span class="p">]</span>
  <span class="k">if</span> <span class="n">allowed_found</span><span class="p">:</span>
    <span class="n">allow</span> <span class="o">=</span> <span class="nb">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">:</span> <span class="n">x</span><span class="o">|</span> <span class="n">y</span> <span class="p">,</span> <span class="n">allowed_found</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">allow</span> <span class="o">=</span> <span class="bp">False</span>

  <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">deny</span><span class="p">)</span> <span class="ow">and</span> <span class="n">allow</span><span class="p">:</span>  
    <span class="k">return</span> <span class="n">true_val</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">false_val</span>

<div class="viewcode-block" id="guess_direction"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.guess_direction">[docs]</a><span class="k">def</span> <span class="nf">guess_direction</span><span class="p">(</span><span class="n">cdf_var</span><span class="p">,</span>  <span class="n">name_atts</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;long_name&#39;</span><span class="p">,</span><span class="s">&#39;standard_name&#39;</span><span class="p">],</span> <span class="n">x_dir_names</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;eastward&#39;</span><span class="p">,</span><span class="s">&#39;Eastward&#39;</span><span class="p">,</span><span class="s">&#39;zonal&#39;</span><span class="p">,</span><span class="s">&#39;Zonal&#39;</span><span class="p">],</span> <span class="n">y_dir_names</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;northward&#39;</span><span class="p">,</span><span class="s">&#39;Northward&#39;</span><span class="p">,</span><span class="s">&#39;meridional&#39;</span><span class="p">,</span><span class="s">&#39;Meridional&#39;</span><span class="p">],</span> <span class="n">z_dir_names</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;upward&#39;</span><span class="p">,</span><span class="s">&#39;Upward&#39;</span><span class="p">,</span><span class="s">&#39;vertical&#39;</span><span class="p">,</span><span class="s">&#39;Vertical&#39;</span><span class="p">],</span><span class="n">t_dir_names</span> <span class="o">=</span> <span class="p">[],</span><span class="n">directional_names</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;velocity&#39;</span><span class="p">,</span><span class="s">&#39;stress&#39;</span><span class="p">,</span><span class="s">&#39;momentum flux&#39;</span><span class="p">,</span><span class="s">&#39;momentum_flux&#39;</span><span class="p">]):</span>

  <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Helper function for cdfread to guess, based on keywords in the netcdf data descriptions, whether a Field is a (space-) vector Field component and in what direction it points. </span>

<span class="sd">  The directional_names argument is a list of keywords that might show up in a description that indicates a vector component: e.g. the word velocity. If this list is empty, the function will not search for those keywords (less restrictive). The name_atts argument indicates the possible name of a descriptive attribute in a netcdf file. The {x,y,z}_dir_names correspond to keywords indicating that particular direction (x,y,z).</span>
<span class="sd">  &quot;&quot;&quot;</span>

 <span class="c"># the keywords in the description will indicate a direction Field.</span>
  <span class="c"># i.e. a vector Field component. If found, their direction attribute will be set in the appropriate direction. Otherwise, it is a scalar.</span>

 
  <span class="c"># loop through the possible names the attribute can have</span>

  <span class="k">for</span> <span class="n">na</span> <span class="ow">in</span> <span class="n">name_atts</span><span class="p">:</span>
 
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">cdf_var</span><span class="p">,</span><span class="n">na</span><span class="p">):</span>
    
      <span class="n">desc</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">cdf_var</span><span class="p">,</span><span class="n">na</span><span class="p">)</span>     
      
      <span class="k">if</span> <span class="nb">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">:</span> <span class="n">x</span><span class="o">|</span> <span class="n">y</span> <span class="p">,[</span><span class="n">e</span> <span class="ow">in</span> <span class="n">desc</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">directional_names</span><span class="p">])</span> <span class="o">|</span> <span class="p">(</span><span class="n">directional_names</span> <span class="o">==</span> <span class="s">&#39;*&#39;</span><span class="p">):</span>  
      <span class="c"># directional description found:</span>

        <span class="n">try_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;X&#39;</span><span class="p">:</span><span class="n">x_dir_names</span><span class="p">,</span> <span class="s">&#39;Y&#39;</span><span class="p">:</span><span class="n">y_dir_names</span><span class="p">,</span> <span class="s">&#39;Z&#39;</span><span class="p">:</span> <span class="n">z_dir_names</span><span class="p">,</span> <span class="s">&#39;T&#39;</span><span class="p">:</span><span class="n">t_dir_names</span><span class="p">}</span>

        <span class="k">for</span> <span class="n">XX</span> <span class="ow">in</span> <span class="n">try_dict</span><span class="p">:</span>

          <span class="n">try_dir</span> <span class="o">=</span> <span class="n">_guess_helper</span><span class="p">(</span><span class="n">desc</span><span class="p">,</span> <span class="n">try_dict</span><span class="p">[</span><span class="n">XX</span><span class="p">],</span> <span class="n">true_val</span> <span class="o">=</span> <span class="n">XX</span><span class="p">)</span>
        
          <span class="k">if</span> <span class="n">try_dir</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">try_dir</span>
       
 
  <span class="k">return</span> <span class="s">&#39;scalar&#39;</span>
</div>
<span class="k">def</span> <span class="nf">_read_data</span><span class="p">(</span><span class="n">var_cdf_ob</span><span class="p">,</span> <span class="n">slices</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Read data from Netcdf variable object into memory and return data as ndarray.</span>
<span class="sd">  &quot;&quot;&quot;</span>

  <span class="k">if</span> <span class="n">slices</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
    <span class="n">body</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">var_cdf_ob</span><span class="p">[:])</span>
  <span class="k">else</span><span class="p">:</span>
    
    <span class="n">body</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">var_cdf_ob</span><span class="p">[</span><span class="n">slices</span><span class="p">])</span>  

  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">body</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_array</span><span class="p">):</span>
    <span class="c"># The Netcdf4 module yields masked arrays. Convert to ndarray to work well with sg.</span>
    <span class="c"># fill_value is a standard attribute of masked arrays (no checks):</span>
    <span class="n">mis_val</span> <span class="o">=</span> <span class="n">body</span><span class="o">.</span><span class="n">fill_value</span>

    <span class="n">body</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">body</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">fvn</span> <span class="o">=</span> <span class="n">get_att</span><span class="p">(</span><span class="n">var_cdf_ob</span><span class="p">,</span> <span class="n">fval_names</span><span class="p">,</span><span class="n">fail_val</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">])</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fvn</span><span class="p">,</span><span class="nb">list</span><span class="p">):</span>  
      <span class="n">mis_val</span> <span class="o">=</span> <span class="n">fvn</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> 
    <span class="k">else</span><span class="p">:</span>
      <span class="n">mis_val</span> <span class="o">=</span> <span class="n">fvn</span>

  <span class="k">try</span><span class="p">:</span> 
    <span class="n">body</span><span class="p">[</span><span class="n">body</span> <span class="o">==</span> <span class="n">mis_val</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
  <span class="k">except</span><span class="p">:</span>
    
    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&#39;missing value not set to NaN.&#39;</span><span class="p">)</span>

  <span class="k">return</span> <span class="n">body</span>

<div class="viewcode-block" id="cdfread"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.cdfread">[docs]</a><span class="k">def</span> <span class="nf">cdfread</span><span class="p">(</span><span class="n">filepath</span><span class="p">,</span><span class="n">varname</span><span class="p">,</span><span class="n">coord_stack</span><span class="o">=</span><span class="p">[],</span> <span class="n">ax_stack</span> <span class="o">=</span> <span class="p">[],</span> <span class="n">verbose</span> <span class="o">=</span> <span class="bp">True</span><span class="p">,</span><span class="n">squeeze_Field</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">slices</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">slice_suffix</span><span class="o">=</span><span class="s">&#39;_sliced&#39;</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Reads data corresponding to variable name varname from netcdf file and returns Field. </span>

<span class="sd">  coord_stack is used to provide Field with grid object built from corresponding Coord objects according to information in netcdf.</span>

<span class="sd">  Args:</span>
<span class="sd">    filepath: (str) complete path pointing to file.</span>
<span class="sd">    varname: (str) variable name in Netcdf file</span>
<span class="sd">    coord_stack: (list of Coord) to use when reading</span>
<span class="sd">    ax_stack: (list of Ax) to use when reading</span>
<span class="sd">    squeeze_Field: (Boolean) if True, hard- squeeze the Field at this point of the reading process (fully removing the 1-dimensional dims). Generally not used.</span>
<span class="sd">    slices: (tuple of slice, Coord and Ax objects) slices to take. No slicing if None.</span>
<span class="sd">    slice_suffix: (str) suffix to add to variable name in case of slicing</span>

<span class="sd">  Returns: </span>
<span class="sd">    Field that was read. </span>
<span class="sd">  &quot;&quot;&quot;</span>

  <span class="nb">file</span> <span class="o">=</span> <span class="n">netcdf_file</span><span class="p">(</span><span class="n">filepath</span><span class="p">,</span><span class="s">&#39;r&#39;</span><span class="p">)</span>
 
  <span class="k">if</span> <span class="n">varname</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">file</span><span class="o">.</span><span class="n">variables</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
      <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&#39;(moderate) from cdfread: var name not in file.&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="bp">None</span>

  <span class="n">var_cdf_ob</span> <span class="o">=</span> <span class="nb">file</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">varname</span><span class="p">]</span>

  <span class="c"># in future we are going to use this metadata instead of below attributes. For now, it is used when fields are saved.</span>
  <span class="n">metadata</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span><span class="n">var_cdf_ob</span><span class="o">.</span><span class="n">__dict__</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">var_cdf_ob</span><span class="o">.</span><span class="n">__dict__</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&#39;data&#39;</span><span class="p">,</span><span class="s">&#39;dimensions&#39;</span><span class="p">,</span><span class="s">&#39;_shape&#39;</span><span class="p">,</span><span class="s">&#39;_size&#39;</span><span class="p">]</span>  <span class="p">}</span>

  <span class="n">dims</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">var_cdf_ob</span><span class="o">.</span><span class="n">dimensions</span><span class="p">)</span> 

 
  <span class="n">grid</span> <span class="o">=</span> <span class="p">[]</span>

  <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">dims</span><span class="p">:</span>
    <span class="n">dim_val</span> <span class="o">=</span> <span class="nb">file</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">dim</span><span class="p">][:]</span>
   
    <span class="k">for</span> <span class="n">crd</span> <span class="ow">in</span> <span class="n">coord_stack</span><span class="p">:</span>
   
      <span class="k">if</span> <span class="p">(</span><span class="n">dim</span> <span class="o">==</span> <span class="n">_dimname</span><span class="p">(</span><span class="n">crd</span><span class="p">)</span> <span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">dim_val</span> <span class="p">,</span> <span class="n">crd</span><span class="o">.</span><span class="n">value</span><span class="p">):</span>
     
        <span class="n">grid</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">crd</span><span class="p">)</span>
  
  <span class="n">grid</span><span class="o">=</span><span class="n">Gr</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">grid</span><span class="p">))</span>          
  <span class="k">if</span> <span class="n">slices</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>

    <span class="n">slices</span> <span class="o">=</span> <span class="n">interpret_slices</span><span class="p">(</span><span class="n">slices</span><span class="p">,</span><span class="n">grid</span> <span class="p">)</span>
    <span class="n">grid</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">sliced</span><span class="p">(</span><span class="n">slices</span> <span class="p">)</span>
    <span class="n">varname</span> <span class="o">=</span> <span class="n">affix</span><span class="p">(</span><span class="n">varname</span><span class="p">,</span> <span class="n">slice_suffix</span><span class="p">)</span>

 <span class="c"># VARIABLE DATA READ FROM FILE </span>
  <span class="n">body</span> <span class="o">=</span> <span class="n">_read_data</span><span class="p">(</span><span class="n">var_cdf_ob</span><span class="p">,</span> <span class="n">slices</span> <span class="o">=</span> <span class="n">slices</span><span class="p">)</span>

  <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">var_cdf_ob</span><span class="p">,</span><span class="s">&#39;units&#39;</span><span class="p">):</span>
    <span class="n">units</span> <span class="o">=</span> <span class="n">var_cdf_ob</span><span class="o">.</span><span class="n">units</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">units</span> <span class="o">=</span> <span class="s">&#39;?&#39;</span>

  <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">var_cdf_ob</span><span class="p">,</span><span class="s">&#39;long_name&#39;</span><span class="p">):</span>
    <span class="n">long_name</span> <span class="o">=</span> <span class="n">var_cdf_ob</span><span class="o">.</span><span class="n">long_name</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">long_name</span> <span class="o">=</span> <span class="n">varname</span>

<span class="c"># attempts at interpreting data by obtaining the string name of the direction. these names are a convention: &#39;X&#39;,&#39;Y&#39;,&#39;Z&#39;. This direction guess is for fields that could be components of a vector fields.</span>

  <span class="n">direction</span> <span class="o">=</span> <span class="n">guess_direction</span><span class="p">(</span><span class="n">var_cdf_ob</span><span class="p">)</span>

  <span class="n">Dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">e</span><span class="o">.</span><span class="n">direction</span><span class="p">:</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">ax_stack</span><span class="p">}</span>
  <span class="n">Dict</span><span class="p">[</span><span class="s">&#39;scalar&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ID</span><span class="p">()</span>

  <span class="n">direction</span> <span class="o">=</span> <span class="n">Dict</span><span class="p">[</span><span class="n">direction</span><span class="p">]</span>

  <span class="k">if</span> <span class="n">squeeze_Field</span><span class="p">:</span>
  <span class="c"># if there are dimensions of length 1, remove them.</span>
    <span class="k">if</span> <span class="mi">1</span> <span class="ow">in</span> <span class="n">var_cdf_ob</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
      <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">dim</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dims</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">var_cdf_ob</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
          <span class="n">dims</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">dims</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    
    <span class="n">body</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">body</span><span class="p">)</span>

  <span class="nb">file</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

  

  <span class="k">return</span> <span class="n">Field</span><span class="p">(</span><span class="n">varname</span><span class="p">,</span><span class="n">body</span><span class="p">,</span><span class="n">grid</span><span class="o">=</span><span class="n">grid</span><span class="p">,</span><span class="n">units</span> <span class="o">=</span> <span class="n">units</span><span class="p">,</span> <span class="n">direction</span> <span class="o">=</span> <span class="n">direction</span><span class="p">,</span> <span class="n">long_name</span> <span class="o">=</span> <span class="n">long_name</span><span class="p">,</span> <span class="n">metadata</span> <span class="o">=</span> <span class="n">metadata</span><span class="p">)</span>

</div>
<span class="k">def</span> <span class="nf">_dimname</span><span class="p">(</span><span class="n">crd</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Strip off _crd suffix if it had been added because dim name equalled axis name.</span>
<span class="sd">  &quot;&quot;&quot;</span>

  <span class="k">if</span> <span class="p">(</span><span class="s">&#39;_crd&#39;</span> <span class="ow">in</span> <span class="n">crd</span><span class="o">.</span><span class="n">name</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">crd</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;_crd&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">crd</span><span class="o">.</span><span class="n">axis</span><span class="o">.</span><span class="n">name</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">crd</span><span class="o">.</span><span class="n">axis</span><span class="o">.</span><span class="n">name</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">crd</span><span class="o">.</span><span class="n">name</span>


<div class="viewcode-block" id="delta"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.delta">[docs]</a><span class="k">def</span> <span class="nf">delta</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Function that calls the d method of the Coord object depending on the kind of coordinate (i.e. x or y).</span>

<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">XCoord</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">oth</span> <span class="ow">in</span> <span class="n">x</span><span class="o">.</span><span class="n">others</span><span class="p">:</span>
      <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">oth</span><span class="p">,</span><span class="n">YCoord</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">d</span><span class="p">(</span><span class="n">oth</span><span class="p">)</span>
    <span class="k">print</span> <span class="s">&#39;No y found.&#39;</span>
    <span class="k">return</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">d</span><span class="p">()</span>




</div>
<span class="k">def</span> <span class="nf">_prep_dual_array</span><span class="p">(</span><span class="n">raw_array</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Prepare the dual.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">if</span> <span class="n">raw_array</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">raw_array</span>
  <span class="k">elif</span> <span class="n">raw_array</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">raw_array</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">raw_array</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]:</span>
      <span class="c"># assume FAMOUS-type encoding of coord edges.</span>
        <span class="n">new_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">raw_array</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">raw_array</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span> <span class="p">)</span>
    <span class="k">elif</span> <span class="n">raw_array</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">raw_array</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]:</span>
      <span class="c"># assume FAMOUS-type encoding of coord edges.     </span>
        <span class="n">new_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">raw_array</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="p">[</span><span class="n">raw_array</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],]</span> <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&#39;! edge/ boundary var of ndim 2 not recognised.&#39;</span><span class="p">)</span>
 
      <span class="k">print</span> <span class="n">raw_array</span>
      <span class="c"># (un!)lucky guess:</span>
      <span class="n">new_array</span> <span class="o">=</span> <span class="n">raw_array</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>    

  <span class="k">else</span><span class="p">:</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&#39;! edge/ boundary var not recognised.&#39;</span><span class="p">)</span>
    <span class="n">new_array</span> <span class="o">=</span> <span class="n">raw_array</span>    
    
  <span class="k">return</span> <span class="n">new_array</span>


<span class="c"># ------------- some Ax related functions ----------------------</span>

<span class="k">def</span> <span class="nf">_guess_grid_type</span><span class="p">(</span><span class="n">crd</span><span class="p">,</span> <span class="n">default</span> <span class="o">=</span> <span class="s">&#39;ts_grid&#39;</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Function that guesses the grid type using the keywords contained in the (sg) global dictionary grid_type_names by testing for keywords (contained as lists in that dictionary).</span>

<span class="sd">  Returns Entry from grid_type_names or None if no grid type is found. </span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">for</span> <span class="n">grtn</span> <span class="ow">in</span> <span class="n">grid_type_names</span><span class="p">:</span>
    <span class="k">if</span> <span class="nb">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">:</span> <span class="n">x</span><span class="o">|</span><span class="n">y</span><span class="p">,</span> <span class="p">[</span><span class="n">e</span> <span class="ow">in</span> <span class="n">crd</span><span class="o">.</span><span class="n">long_name</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">grid_type_names</span><span class="p">[</span><span class="n">grtn</span><span class="p">]]):</span>
      <span class="k">return</span> <span class="n">grtn</span>
  <span class="c"># No grid type found, default is assumed.</span>
  <span class="k">return</span> <span class="n">default</span>






<div class="viewcode-block" id="make_axes"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.make_axes">[docs]</a><span class="k">def</span> <span class="nf">make_axes</span><span class="p">(</span><span class="n">cstack</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Replaces axis attribute of Coord objects if it is a string with newly created (non-repeating) corresponding axis objects.</span>

<span class="sd">   The Ax objects are created here.</span>

<span class="sd">  Returns list of Ax objects!!</span>

<span class="sd">  NOTE THAT THIS FUNCTION DOES 2 THINGS: IT RETURNS A LIST OF AXES AND MODIFIES THE CSTACK ARGUMENT. </span>


<span class="sd">  Args: </span>
<span class="sd">    cstack: (list of Coord) to act on.</span>

<span class="sd">  Returns: </span>
<span class="sd">    List of all unique (no repeats) Ax objects that have been created to replace the axis attribute of the elements of the Coord list (cstack) argument that were strings. None is returned when all cstack Coord elements already have Ax axis attributes.</span>
<span class="sd">  &quot;&quot;&quot;</span>

  <span class="c"># No Coord objects will be removed from the cstack list. But cstack argument is modified!</span>
  <span class="c"># created_axes will contain the newly created Ax objects!! So created_axes is NOT cstack!!</span>
  <span class="n">created_axes</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cstack</span><span class="p">:</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="s">&#39;axis&#39;</span><span class="p">):</span>
      <span class="c"># string Ax attribute will be replaced with corresponding Ax object attribute</span>
      <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">axis</span><span class="p">,</span><span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">axis</span><span class="p">,</span><span class="nb">unicode</span><span class="p">):</span>
        <span class="c"># str attr found --&gt; create corresponding Ax object.</span>
        <span class="n">new_ax</span> <span class="o">=</span> <span class="n">Ax</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">axis</span><span class="p">,</span><span class="n">direction</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">direction</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">id_in</span><span class="p">(</span><span class="n">created_axes</span><span class="p">,</span><span class="n">new_ax</span><span class="p">):</span>
          <span class="c"># however, if we already have that Ax object in created_axes, assign existing Ax object instead.</span>
          <span class="n">i</span> <span class="o">=</span> <span class="n">id_index</span><span class="p">(</span><span class="n">created_axes</span><span class="p">,</span><span class="n">new_ax</span><span class="p">)</span>
          <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">direction</span> <span class="o">!=</span> <span class="n">created_axes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">direction</span><span class="p">:</span>
            <span class="c"># if direction inconsistent, proceed but issue warning.</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&#39;Warning! While associating Ax object </span><span class="si">%s</span><span class="s"> with coord </span><span class="si">%s</span><span class="s">. </span><span class="si">%s</span><span class="s">.direction =</span><span class="si">%s</span><span class="s">, </span><span class="si">%s</span><span class="s">.direction = </span><span class="si">%s</span><span class="s"> &#39;</span> <span class="o">%</span><span class="p">(</span><span class="n">created_axes</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">c</span><span class="p">,</span> <span class="n">created_axes</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">created_axes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">direction</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">direction</span><span class="p">)</span> <span class="p">)</span>
          <span class="n">c</span><span class="o">.</span><span class="n">axis</span> <span class="o">=</span> <span class="n">created_axes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
          
        <span class="k">else</span><span class="p">:</span>
          <span class="c"># new Ax object not in created_axes, proceed using new Ax object.</span>
          <span class="n">created_axes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_ax</span><span class="p">)</span>
          <span class="n">c</span><span class="o">.</span><span class="n">axis</span> <span class="o">=</span> <span class="n">new_ax</span> 
        <span class="c"># Ax object equivalent (parallel) to Coord object.</span>
        <span class="n">c</span><span class="o">.</span><span class="n">axis</span><span class="o">.</span><span class="n">make_equiv</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>     
  <span class="c"># return the list of Ax objects. </span>

  <span class="c"># there might be dual coords associated with coords that still have an axis attribute that hasn&#39;t been converted from str yet. Replace them with elements from the cstack:</span>
  <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">crd</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cstack</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">crd</span><span class="p">,</span><span class="s">&#39;dual&#39;</span><span class="p">):</span>
      <span class="k">if</span> <span class="ow">not</span> <span class="n">crd</span><span class="o">.</span><span class="n">dual</span> <span class="ow">is</span> <span class="n">crd</span><span class="p">:</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">id_index</span><span class="p">(</span><span class="n">cstack</span><span class="p">,</span> <span class="n">crd</span><span class="o">.</span><span class="n">dual</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">i</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
          
          <span class="n">cstack</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">dual</span> <span class="o">=</span> <span class="n">cstack</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

  <span class="k">return</span> <span class="n">created_axes</span>        

</div>
<span class="k">def</span> <span class="nf">_int2slice</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>

  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span><span class="nb">int</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">slice</span><span class="p">(</span><span class="n">value</span><span class="p">,</span><span class="n">value</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="bp">None</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">value</span>


<div class="viewcode-block" id="interpret_slices"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.interpret_slices">[docs]</a><span class="k">def</span> <span class="nf">interpret_slices</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">grid</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Interpret slice argument, e.g. TEMP(X,:,Y,:50) or TEMP(:,50:)</span>

<span class="sd">  Args:</span>
<span class="sd">    L: (list) of slice, Ax or Coord ojbects</span>
<span class="sd">    grid: (Gr) grid to slice on</span>

<span class="sd">  Returns:</span>
<span class="sd">    A list of standard slice objects that can be used to slice ndarrays or Netcdf vars</span>
<span class="sd">  &quot;&quot;&quot;</span>

  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="nb">tuple</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="nb">list</span><span class="p">):</span>
    <span class="c"># In this case, the argument is expected to be multiple slice objects only or slice objects interspersed with Coord objects.</span>
 
    <span class="n">crds</span> <span class="o">=</span> <span class="p">[]</span>		<span class="c"># holds Coord objects along which to slice</span>
    <span class="n">slices</span> <span class="o">=</span> <span class="p">[]</span>	<span class="c"># holds slice objects</span>
      
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">L</span><span class="p">:</span>
      <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">Coord</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">grid</span><span class="p">:</span>
          <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Slice Coord argument </span><span class="si">%s</span><span class="s"> not in Field </span><span class="si">%s</span><span class="s"> grid </span><span class="si">%s</span><span class="s">.&#39;</span><span class="o">%</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="bp">self</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">))</span>

        <span class="n">crds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

      <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">Ax</span><span class="p">):</span>
       
        <span class="n">slice_coord</span> <span class="o">=</span> <span class="n">i</span><span class="o">*</span><span class="n">grid</span>
        <span class="k">if</span> <span class="n">slice_coord</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
          <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Slice axis argument </span><span class="si">%s</span><span class="s"> not in Field </span><span class="si">%s</span><span class="s"> grid </span><span class="si">%s</span><span class="s">.&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="bp">self</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="n">crds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">slice_coord</span><span class="p">)</span> 

      <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="nb">int</span><span class="p">):</span>  
        <span class="n">slices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="bp">None</span><span class="p">))</span>
      <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="nb">slice</span><span class="p">):</span>
        <span class="n">slices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s">&#39;Non-integer slice axis argument </span><span class="si">%s</span><span class="s"> for grid </span><span class="si">%s</span><span class="s"> not recognised as Ax or Coord object. The Ax/ Coord object might be stale. &#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">grid</span><span class="p">)</span> <span class="p">)</span>


    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">crds</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
      <span class="c"># No Coord objects recorded: this is likely a normal slice list: do nothing</span>
      <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">slices</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span> <span class="s">&#39;(severe): no slices!&#39;</span><span class="p">,</span> <span class="ne">RuntimeWarning</span> <span class="p">)</span>
      <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>

    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">crds</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">slices</span><span class="p">):</span>        
          <span class="c"># In this case, we can associate a slice object (or int) to each Coord object in the argument.</span>
          <span class="c"># The order then determines which slice object corresponds to which Coord object.</span>
          <span class="c"># The task is now to slice the Field value appropriately and to create the associated Coord objects.</span>


      <span class="n">all_slices</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">member</span> <span class="ow">in</span> <span class="n">grid</span><span class="p">]</span>

      <span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">crds</span><span class="p">,</span><span class="n">slices</span><span class="p">):</span>
      
        <span class="n">all_slices</span><span class="p">[</span><span class="n">grid</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">it</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span> <span class="o">=</span>  <span class="n">it</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> 

      <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">all_slices</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
     <span class="c"># case where len(crds) != len(slices). Leads to error</span>
     <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Field slice error in Field </span><span class="si">%s</span><span class="s"> arg </span><span class="si">%s</span><span class="s">: use slice objects only or pairs of Coord objects and slice objects.&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">L</span><span class="p">)</span>  <span class="p">)</span>         

  <span class="k">else</span><span class="p">:</span>
  <span class="c"># Trivial case where argument is not a tuple. e.g. it is &#39;slice(10,None,None)&#39; or &#39;10&#39;</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">L</span><span class="p">,)</span>





</div>
<div class="viewcode-block" id="GetId"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.GetId">[docs]</a><span class="k">class</span> <span class="nc">GetId</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Define the scalar axis via a lazy class. Then ID*X = X etc.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">ret_id</span> <span class="o">=</span> <span class="bp">None</span>  

  <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ret_id</span><span class="p">):</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">ret_id</span> <span class="o">=</span> <span class="n">Ax</span><span class="p">(</span><span class="s">&#39;scalar&#39;</span><span class="p">)</span>


    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ret_id</span>
</div>
<span class="n">ID</span> <span class="o">=</span> <span class="n">GetId</span><span class="p">()</span>


<span class="c"># ---------------- Gr related functions --------------------</span>

<div class="viewcode-block" id="finer_grid"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.finer_grid">[docs]</a><span class="k">def</span> <span class="nf">finer_grid</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">factor</span> <span class="o">=</span> <span class="mf">5.</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Call finer method on Gr members.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="nb">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">:</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">,</span> <span class="p">[</span><span class="n">crd</span><span class="o">.</span><span class="n">finer</span><span class="p">(</span><span class="n">factor</span> <span class="o">=</span> <span class="n">factor</span><span class="p">)</span> <span class="k">for</span> <span class="n">crd</span> <span class="ow">in</span> <span class="n">grid</span><span class="p">])</span>





</div>
<span class="kn">from</span> <span class="nn">plotting</span> <span class="kn">import</span> <span class="o">*</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../index.html">spacegrids  documentation</a> &raquo;</li>
          <li><a href="../index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2014, Willem Sijp.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
  </body>
</html>