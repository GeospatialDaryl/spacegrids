<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>spacegrids.fieldcls &mdash; spacegrids  documentation</title>
    
    <link rel="stylesheet" href="../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="spacegrids  documentation" href="../../index.html" />
    <link rel="up" title="Module code" href="../index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../index.html">spacegrids  documentation</a> &raquo;</li>
          <li><a href="../index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for spacegrids.fieldcls</h1><div class="highlight"><pre>
<span class="c">#encoding:utf-8</span>

<span class="sd">&quot;&quot;&quot; Coord, Gr, Ax, AxGr and Field class</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">numpy.ma</span> <span class="kn">as</span> <span class="nn">ma</span>
<span class="kn">from</span> <span class="nn">scipy.interpolate</span> <span class="kn">import</span> <span class="n">griddata</span>

<span class="kn">import</span> <span class="nn">inspect</span>
<span class="kn">import</span> <span class="nn">datetime</span>
<span class="kn">import</span> <span class="nn">glob</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">from</span> <span class="nn">config</span> <span class="kn">import</span> <span class="o">*</span>

<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">copy</span>


<span class="kn">from</span> <span class="nn">utilsg</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">iosg</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">warnings</span><span class="o">.</span><span class="n">formatwarning</span> <span class="o">=</span> <span class="n">warning_on_one_line</span>

<span class="c"># -------- Coord  ----------------</span>

<div class="viewcode-block" id="Coord"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Coord">[docs]</a><span class="k">class</span> <span class="nc">Coord</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  coordinate , represents single coordinate elements such as points along the x axis. </span>
<span class="sd">  Coord objects are defined by a name, value (generally a numpy array) and units.</span>
<span class="sd">  Coord objects c1 and c2 are considered equal, c1&amp;c2 yields True, when the name, value (numpy array) and units attributes are equal.</span>
<span class="sd">  &quot;&quot;&quot;</span>

  <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s">&#39;alias&#39;</span><span class="p">):</span>
      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">alias</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>

  <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">i</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

<div class="viewcode-block" id="Coord.array_equal"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Coord.array_equal">[docs]</a>  <span class="k">def</span> <span class="nf">array_equal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; test whether Coord objects contain identical Coord values</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">Coord</span><span class="p">):</span>
      <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;Error: provide Coord argument (</span><span class="si">%s</span><span class="s"> provided).&#39;</span><span class="o">%</span><span class="n">other</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">,</span><span class="n">other</span><span class="o">.</span><span class="n">value</span><span class="p">)</span> 
</div>
<div class="viewcode-block" id="Coord.same"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Coord.same">[docs]</a>  <span class="k">def</span> <span class="nf">same</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Coord method to check whether this Coord has identical main attributes (except units) to argument other Coord.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c"># not checking for units</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">,</span><span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">,</span><span class="nb">unicode</span><span class="p">):</span>

      <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&#39; </span><span class="si">%s</span><span class="s"> Coord (self) has string/ unicode axis attribute </span><span class="si">%s</span><span class="s">&#39;</span><span class="o">%</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">))</span>

      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">name</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axis</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">axis</span> <span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">direction</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">direction</span>  <span class="p">)</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">axis</span><span class="p">,</span><span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">axis</span><span class="p">,</span><span class="nb">unicode</span><span class="p">):</span>

      <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&#39; </span><span class="si">%s</span><span class="s"> Coord (other) has string/ unicode axis attribute </span><span class="si">%s</span><span class="s">&#39;</span><span class="o">%</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">name</span><span class="p">,</span><span class="n">other</span><span class="o">.</span><span class="n">axis</span><span class="p">))</span>

      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">name</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axis</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">axis</span> <span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">direction</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">direction</span>  <span class="p">)</span>


    <span class="k">else</span><span class="p">:</span>
      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">name</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="o">.</span><span class="n">same</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">axis</span><span class="p">)</span> <span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">direction</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">direction</span>  <span class="p">)</span>
</div>
<div class="viewcode-block" id="Coord.samein"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Coord.samein">[docs]</a>  <span class="k">def</span> <span class="nf">samein</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">L</span><span class="p">):</span>

    <span class="k">return</span> <span class="nb">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">:</span><span class="n">x</span> <span class="ow">or</span> <span class="n">y</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">same</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="n">L</span><span class="p">]</span> <span class="p">)</span>
</div>
<div class="viewcode-block" id="Coord.sameindex"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Coord.sameindex">[docs]</a>  <span class="k">def</span> <span class="nf">sameindex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">L</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">it</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">L</span><span class="p">):</span>
      <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">same</span><span class="p">(</span><span class="n">it</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">i</span>
     
    <span class="k">return</span> <span class="bp">None</span>    


</div>
  <span class="k">def</span> <span class="nf">__and__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">):</span>

    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">weaksame</span><span class="p">(</span><span class="n">other</span> <span class="o">=</span> <span class="n">other</span><span class="p">)</span>

<div class="viewcode-block" id="Coord.weaksame"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Coord.weaksame">[docs]</a>  <span class="k">def</span> <span class="nf">weaksame</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    self.weaksame(other)</span>
<span class="sd">    Returns True/ False</span>

<span class="sd">    coord1.weaksame(coord2) tests whether Coord objects coord1, coord2 contain identical Coord values, name and direction. </span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c"># </span>

    <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">name</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">direction</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">direction</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> 




    </div>
<div class="viewcode-block" id="Coord.sort"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Coord.sort">[docs]</a>  <span class="k">def</span> <span class="nf">sort</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Sorts Coord value. Passes arguments on to Numpy sort method.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


</div>
<div class="viewcode-block" id="Coord.copy"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Coord.copy">[docs]</a>  <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">name</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span><span class="n">value</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">dual</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span><span class="n">direction</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span><span class="n">units</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">long_name</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">metadata</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">strings</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">equiv</span> <span class="o">=</span> <span class="bp">True</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Copy function for Coord objects. If equiv = True, the copies will be equivalent. When no value is selected for an argument (i.e. it retains its default value of None), a copy of the self attribute will be used. Otherwise, the argument value will be used.</span>

<span class="sd">    Returns a copy of the Coord object.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">frame</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">currentframe</span><span class="p">()</span>
    <span class="n">args</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">values</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">getargvalues</span><span class="p">(</span><span class="n">frame</span><span class="p">)</span>

    <span class="k">del</span> <span class="n">values</span><span class="p">[</span><span class="s">&#39;frame&#39;</span><span class="p">]</span>
    <span class="k">del</span> <span class="n">values</span><span class="p">[</span><span class="s">&#39;equiv&#39;</span><span class="p">]</span>   
   
    <span class="k">del</span> <span class="n">values</span><span class="p">[</span><span class="s">&#39;self&#39;</span><span class="p">]</span>    

    
    <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">values</span><span class="p">:</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">arg</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="p">):</span>

          <span class="k">if</span> <span class="n">values</span><span class="p">[</span><span class="n">arg</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">values</span><span class="p">[</span><span class="n">arg</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="p">[</span><span class="n">arg</span><span class="p">]</span>

      <span class="k">else</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&#39;arg </span><span class="si">%s</span><span class="s"> is not an object attribute.&#39;</span> <span class="o">%</span><span class="n">arg</span><span class="p">)</span>

    <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">(</span><span class="o">**</span><span class="n">values</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">equiv</span><span class="p">:</span>
      <span class="n">result</span><span class="o">.</span><span class="n">equivs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">equivs</span>

    <span class="k">return</span> <span class="n">result</span>
</div>
  <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;scalar&#39;</span><span class="p">,</span><span class="n">value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">]),</span> <span class="n">dual</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span><span class="n">axis</span> <span class="o">=</span> <span class="s">&#39;?&#39;</span><span class="p">,</span><span class="n">direction</span> <span class="o">=</span><span class="s">&#39;scalar&#39;</span><span class="p">,</span> <span class="n">units</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span><span class="n">long_name</span> <span class="o">=</span><span class="s">&#39;?&#39;</span><span class="p">,</span> <span class="n">metadata</span> <span class="o">=</span> <span class="p">{}</span> <span class="p">,</span> <span class="n">strings</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>  

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Initialisation of Coord object. This is the basic building block of grid objects.</span>
<span class="sd">    E.g. xt or yt, corresponding to the tracer grid cells in the x and y directions.</span>
<span class="sd">    </span>
<span class="sd">    Coord objects have a corresponding dual. For xt it is xt_edges and vice versa.</span>
<span class="sd">    The duality operation projects the centre of the grid cell onto the 2 adjacent edges and vice versa.</span>
<span class="sd">    If no dual argument is given, the Coord object is its own dual.</span>

<span class="sd">    &quot;&quot;&quot;</span>
  
<span class="c"># choosing the name ID creates an identity object. ID*b = b for all Coord elements b.</span>
<span class="c"># could implement the identity Field in __call__</span>

<span class="c"># Metric could be a class. Objects of this class could be constructed by a method of the Coord class (Coord objects then spawn metric objects).</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">equivs</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="p">]</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">axis</span> <span class="o">=</span> <span class="n">axis</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">units</span> <span class="o">=</span> <span class="n">units</span>
 
    <span class="bp">self</span><span class="o">.</span><span class="n">direction</span> <span class="o">=</span> <span class="n">direction</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">long_name</span> <span class="o">=</span> <span class="n">long_name</span>


    <span class="k">if</span> <span class="n">dual</span><span class="p">:</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">dual</span> <span class="o">=</span> <span class="n">dual</span>
      <span class="n">dual</span><span class="o">.</span><span class="n">dual</span> <span class="o">=</span> <span class="bp">self</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="c"># if no dual is selected, the Coord object is its own dual</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">dual</span> <span class="o">=</span> <span class="bp">self</span>   
 
    <span class="bp">self</span><span class="o">.</span><span class="n">fld</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span> <span class="o">=</span> <span class="n">metadata</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">nbytes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">nbytes</span>

    <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">axis</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">Ax</span><span class="p">)</span>  <span class="p">:</span>
      <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">equivs</span><span class="p">)</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">strings</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
      <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">strings</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Provide strings argument of equal length to value argument for Coord </span><span class="si">%s</span><span class="s"> if providing strings argument. </span><span class="si">%s</span><span class="s"> vs </span><span class="si">%s</span><span class="s">&#39;</span><span class="o">%</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">strings</span><span class="p">)))</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">strings</span> <span class="o">=</span> <span class="n">strings</span>


  <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">len</span>

  <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>

    <span class="c"># belongs to Coord </span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calling a Coord object with a grid Gr object as argument yields an array A defined on that grid where A[:,i,...] = self.value for all i </span>

<span class="sd">    In other words, this leads to an expansion of the Coord value useful for grid operations such as interpolation.</span>

<span class="sd">    E.g. R=xt(xt*yt*zt) then R.shape = (len(xt),len(yt),len(zt)). Here, the value of R is constant in yt and zt, but equal to xt along the xt axis.</span>

<span class="sd">    If the argument is a Field object, then calling the Coord object on it yields a slice along that Coord axis of that Field. The index argument is the index of the slice.</span>

<span class="sd">    If no argument is given, a Field is returned with the values of the Coord values and defined on a grid containing only the Coord.</span>


<span class="sd">    &quot;&quot;&quot;</span>

<span class="c">#    print self</span>
<span class="c">#    print other</span>

    <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">other</span> <span class="ow">is</span> <span class="bp">self</span><span class="p">):</span>
      <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fld</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fld</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">units</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">units</span><span class="p">)</span>
    
      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fld</span>
    <span class="k">else</span><span class="p">:</span>

      <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">Gr</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span> <span class="ow">in</span> <span class="n">other</span><span class="p">:</span>
          <span class="k">return</span> <span class="n">Field</span><span class="p">(</span><span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">**</span><span class="mi">2</span><span class="p">)(</span><span class="n">other</span><span class="p">)(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">),</span> <span class="n">grid</span> <span class="o">=</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="k">return</span> 
      <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">Field</span><span class="p">):</span>
          <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">bigslice</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">index</span><span class="p">)</span>



      <span class="k">return</span> 
      
  <span class="k">def</span> <span class="nf">__neg__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    version of Coord with negative values (e.g. -xt). Includes a negative dual (edges). </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">neg_crd</span> <span class="o">=</span> <span class="n">Coord</span><span class="p">(</span><span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span><span class="n">value</span> <span class="o">=-</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">,</span><span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">,</span> <span class="n">units</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">units</span><span class="p">)</span>
    <span class="n">neg_dual</span> <span class="o">=</span> <span class="n">Coord</span><span class="p">(</span><span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dual</span><span class="o">.</span><span class="n">name</span><span class="p">,</span><span class="n">value</span> <span class="o">=-</span><span class="bp">self</span><span class="o">.</span><span class="n">dual</span><span class="o">.</span><span class="n">value</span><span class="p">,</span><span class="n">dual</span> <span class="o">=</span> <span class="n">neg_crd</span><span class="p">,</span><span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">,</span> <span class="n">units</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">units</span><span class="p">)</span>
    <span class="n">neg_crd</span><span class="o">.</span><span class="n">dual</span> <span class="o">=</span> <span class="n">neg_dual</span>
    <span class="k">return</span> <span class="n">neg_crd</span>


  <span class="k">def</span> <span class="nf">__or__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Register equivalence. e.g. a = Gr((&#39;xt&#39;,)) and b = Gr((&#39;xu&#39;,))</span>
<span class="sd">    a|b registers b in the equivalents of a and vice versa.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">Coord</span><span class="p">):</span>
<span class="c">#      self.equivs.append(other)</span>
<span class="c">#      other.equivs.append(self)    </span>


      <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">equivs</span><span class="p">):</span>
        <span class="n">e</span><span class="o">.</span><span class="n">equivs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

      <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">equivs</span><span class="p">):</span>
        <span class="n">e</span><span class="o">.</span><span class="n">equivs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>        

      <span class="bp">self</span><span class="o">.</span><span class="n">equivs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">equivs</span><span class="p">))</span>
      <span class="n">other</span><span class="o">.</span><span class="n">equivs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">equivs</span><span class="p">))</span>


      <span class="k">return</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">Field</span><span class="p">):</span>
      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">vcumsum</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">VField</span><span class="p">):</span>
      <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      this method works through on the individual members of a vector Field:</span>
<span class="sd">      &quot;&quot;&quot;</span>
      <span class="k">return</span> <span class="n">VField</span><span class="p">([</span><span class="bp">self</span><span class="o">|</span><span class="n">e</span>  <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">other</span><span class="p">]</span> <span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;Coord error in </span><span class="si">%s</span><span class="s">|</span><span class="si">%s</span><span class="s"> with Coord </span><span class="si">%s</span><span class="s">: provide Coord or Field for right multiplicant (</span><span class="si">%s</span><span class="s">), or check staleness.&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">,</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">)</span>  <span class="p">)</span>

<span class="c"># Belongs to Coord   </span>

  <span class="k">def</span> <span class="nf">__xor__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    If argument is a Coord, this method tests for equivalence. e.g. xt equiv to xu</span>
<span class="sd">    If argument is a Gr, this method yields the Coord element from the Gr object that is equivalent to self.</span>
<span class="sd">    If argument is a Field, this method takes the derivative along self Coord axis.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
<span class="c">#    global nodes_done</span>

    <span class="c"># This method works recursively to ensure associativity of the ^ relationship. E.g. a0^a1 is True and a1^a2 is True =&gt; a0^a3 is True</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">Coord</span><span class="p">)</span> <span class="o">|</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">Ax</span><span class="p">):</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">other</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">equivs</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="bp">self</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">equivs</span><span class="p">):</span>

        <span class="k">return</span> <span class="bp">True</span>     
      <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">&amp;</span><span class="n">other</span><span class="p">):</span>
          <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&#39;Warning (severe) from </span><span class="si">%s</span><span class="s">^</span><span class="si">%s</span><span class="s">: objects not equivalent, but contain the same main attributes (name, value, units)! &#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">)</span> <span class="p">)</span>
        <span class="k">return</span> <span class="bp">False</span>
      
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">Gr</span><span class="p">):</span>
      <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">eq_in</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">other</span><span class="p">[</span><span class="n">other</span><span class="o">.</span><span class="n">eq_index</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>      <span class="p">]</span>
      <span class="k">else</span><span class="p">:</span>   
        <span class="k">return</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">Field</span><span class="p">):</span>
      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">der</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;Coord error in </span><span class="si">%s</span><span class="s">^</span><span class="si">%s</span><span class="s"> with Coord </span><span class="si">%s</span><span class="s">. Provide Coord,Gr or Field object for right multiplicant (now </span><span class="si">%s</span><span class="s">).&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">,</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">)</span> <span class="p">)</span>
      <span class="k">return</span>
      

  <span class="k">def</span> <span class="nf">__pow__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">n</span><span class="p">):</span>

    <span class="k">return</span> <span class="nb">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">:</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">,</span> <span class="n">n</span><span class="o">*</span><span class="p">[</span><span class="bp">self</span><span class="p">])</span>

<span class="c"># --&gt; belongs to Coord </span>
  <span class="k">def</span> <span class="nf">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">):</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">direction</span> <span class="o">==</span> <span class="s">&#39;scalar&#39;</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">Gr</span><span class="p">((</span><span class="n">other</span><span class="p">,))</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">Coord</span><span class="p">):</span>   
        <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">direction</span> <span class="o">==</span> <span class="s">&#39;scalar&#39;</span><span class="p">:</span> 
          <span class="k">return</span> <span class="n">Gr</span><span class="p">((</span><span class="bp">self</span><span class="p">,))</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="k">if</span> <span class="n">other</span><span class="o">^</span><span class="bp">self</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Gr</span><span class="p">((</span><span class="bp">self</span><span class="p">,))</span>
          <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Gr</span><span class="p">((</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">))</span>

      <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">Ax</span><span class="p">):</span>
        <span class="c"># Ax and Coord objects commute</span>
        <span class="k">return</span> <span class="n">other</span><span class="o">*</span><span class="bp">self</span>

      <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">Gr</span><span class="p">):</span>   
        <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">eq_in</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
          <span class="n">new_other</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
       
          <span class="n">new_other</span><span class="p">[</span><span class="n">other</span><span class="o">.</span><span class="n">eq_index</span><span class="p">(</span><span class="bp">self</span><span class="p">)]</span> <span class="o">=</span> <span class="bp">self</span>
          <span class="k">return</span> <span class="n">Gr</span><span class="p">(</span><span class="n">new_other</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="k">return</span> <span class="n">Gr</span><span class="p">(</span> <span class="p">[</span><span class="bp">self</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">other</span><span class="p">))</span>
      <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">Field</span><span class="p">):</span>
<span class="c">#        print &#39;Warning (benign): converting left multiplicant to Gr object from Coord object.&#39;</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">other</span>

      <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">VField</span><span class="p">):</span>
         <span class="c"># case whether vector Field is multiplied by Coord (yielding vsum).</span>
         <span class="c"># this commutes:</span>
         <span class="k">return</span> <span class="n">other</span><span class="o">*</span><span class="bp">self</span>

      <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;Coord error in </span><span class="si">%s</span><span class="s">*</span><span class="si">%s</span><span class="s"> with Coord </span><span class="si">%s</span><span class="s">: provide Coord, Gr or Field object as right multiplicant (now </span><span class="si">%s</span><span class="s">). If multiplicant appears to be a Coord of other multiplicant Field, check whether its definition is stale (reloaded sg since its creation). &#39;</span><span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">,</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">)</span> <span class="p">)</span>




  <span class="k">def</span> <span class="nf">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Coord method.</span>
<span class="sd">    Refine Coord by combining grid points from both. Only implemented for self-dual Coord objects.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">dual</span> <span class="o">==</span> <span class="bp">self</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">dual</span> <span class="o">==</span> <span class="n">other</span><span class="p">)):</span>

      <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

      <span class="n">result</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">merge</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">,</span><span class="n">other</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
      
      <span class="k">return</span> <span class="n">result</span>

    <span class="k">else</span><span class="p">:</span>

      <span class="k">print</span> <span class="s">&#39;+ only implemented for self-dual Coord objects (e.g. time), returning None.&#39;</span>
      <span class="k">return</span> <span class="bp">None</span>  


<div class="viewcode-block" id="Coord.start_zero"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Coord.start_zero">[docs]</a>  <span class="k">def</span> <span class="nf">start_zero</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a copy of this Coord where the coordinate values start at 0.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s">&#39;_zero&#39;</span>  <span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
 </div>
<div class="viewcode-block" id="Coord.cdf_insert"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Coord.cdf_insert">[docs]</a>  <span class="k">def</span> <span class="nf">cdf_insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">file_handle</span><span class="p">,</span> <span class="n">miss_default</span> <span class="o">=</span> <span class="mf">9.96921e+36</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Netcdf insert method of Coord </span>
<span class="sd">    Inserts Coord as variable into Netcdf file.</span>

<span class="sd">    Input: file_handle file handle of opened Netcdf file.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c"># make a copy of self content and deal with missing values.</span>
    <span class="n">value</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">[:])</span>

    <span class="n">miss_val</span> <span class="o">=</span> <span class="n">miss_default</span>
    <span class="k">if</span> <span class="s">&#39;FillValue&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">:</span>
      <span class="n">miss_val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s">&#39;FillValue&#39;</span><span class="p">]</span>
    <span class="k">elif</span> <span class="s">&#39;missing_value&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">:</span>
      <span class="n">miss_val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s">&#39;missing_value&#39;</span><span class="p">]</span>

    <span class="k">try</span><span class="p">:</span>
    
      <span class="n">value</span><span class="p">[</span>  <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span> <span class="n">value</span><span class="p">[:]</span>  <span class="p">)</span> <span class="o">==</span> <span class="bp">True</span>   <span class="p">]</span> <span class="o">=</span> <span class="n">miss_val</span>
    <span class="k">except</span><span class="p">:</span>
      <span class="k">try</span><span class="p">:</span>
        <span class="n">value</span><span class="p">[</span>  <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span> <span class="n">value</span><span class="p">[:]</span>  <span class="p">)</span> <span class="o">==</span> <span class="bp">True</span>   <span class="p">]</span> <span class="o">=</span> <span class="n">miss_default</span>

      <span class="k">except</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&#39;Could not set missing value for Coord </span><span class="si">%s</span><span class="s">.&#39;</span><span class="o">%</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>





    <span class="n">file_handle</span><span class="o">.</span><span class="n">createDimension</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>


    <span class="n">var_cdf</span> <span class="o">=</span> <span class="n">file_handle</span><span class="o">.</span><span class="n">createVariable</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">char</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,)</span>   <span class="p">)</span>
    
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">:</span>
      <span class="nb">setattr</span><span class="p">(</span><span class="n">var_cdf</span><span class="p">,</span><span class="n">k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> 

    <span class="n">var_cdf</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">return</span> <span class="n">file_handle</span>

</div>
<div class="viewcode-block" id="Coord.write"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Coord.write">[docs]</a>  <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">name</span> <span class="o">=</span> <span class="bp">None</span> <span class="p">,</span> <span class="n">history</span> <span class="o">=</span> <span class="s">&#39;Created from Spacegrids &#39;</span>  <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Write method of Coord .</span>
<span class="sd">    Writes Coord data to Netcdf file.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
      <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;.&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&#39;nc&#39;</span><span class="p">,</span><span class="s">&#39;cdf&#39;</span><span class="p">]:</span>
      <span class="n">name</span> <span class="o">=</span> <span class="n">name</span> <span class="o">+</span><span class="s">&#39;.nc&#39;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">path</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
      <span class="n">name</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span> <span class="n">path</span> <span class="p">,</span> <span class="n">name</span> <span class="p">)</span> 

    <span class="k">print</span> <span class="s">&#39;Writing Field to file </span><span class="si">%s</span><span class="s">&#39;</span><span class="o">%</span><span class="n">name</span>

    <span class="k">try</span><span class="p">:</span>
      <span class="c"># using io_sg version of netcdf_file. May use ScientificIO or Scipy</span>
      <span class="n">file_handle</span> <span class="o">=</span> <span class="n">netcdf_file</span><span class="p">(</span><span class="n">name</span> <span class="p">,</span> <span class="s">&#39;w&#39;</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">IOError</span><span class="p">:</span>
      <span class="k">print</span> <span class="s">&#39;Cannot write &#39;</span><span class="p">,</span> <span class="n">name</span>
    <span class="k">else</span><span class="p">:</span>

      <span class="n">file_handle</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cdf_insert</span><span class="p">(</span><span class="n">file_handle</span><span class="p">)</span>

      <span class="n">file_handle</span><span class="o">.</span><span class="n">history</span> <span class="o">=</span> <span class="n">history</span> <span class="o">+</span> <span class="s">&#39;</span><span class="si">%s</span><span class="s">&#39;</span><span class="o">%</span><span class="nb">str</span><span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">())</span>
 
<span class="c">#    var_cdf.units = self.units</span>

      <span class="n">file_handle</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>


</div>
<div class="viewcode-block" id="Coord.finer"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Coord.finer">[docs]</a>  <span class="k">def</span> <span class="nf">finer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">factor</span> <span class="o">=</span> <span class="mf">5.</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Method of Coord. Refine the coordinate point interval with a given factor.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
      <span class="n">result</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">],(</span><span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">/</span><span class="n">factor</span><span class="p">))</span>


    <span class="n">finer_coord</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s">&#39;_fine&#39;</span><span class="p">,</span><span class="n">value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">result</span><span class="p">))</span>  
    <span class="n">finer_coord</span><span class="o">|</span><span class="bp">self</span>
    <span class="k">return</span> <span class="n">finer_coord</span>

</div>
<div class="viewcode-block" id="Coord.bigslice"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Coord.bigslice">[docs]</a>  <span class="k">def</span> <span class="nf">bigslice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">F</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Method of Coord .    </span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">F</span><span class="p">):</span>
      <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&#39;Warning Coord part: Provide Field.&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="bp">self</span> <span class="ow">in</span> <span class="n">F</span><span class="o">.</span><span class="n">gr</span><span class="p">:</span>
      <span class="n">sl</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span><span class="bp">None</span><span class="p">,</span><span class="bp">None</span><span class="p">)</span>
      <span class="n">sl2</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">index</span><span class="p">,</span><span class="n">index</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
      <span class="n">L</span> <span class="o">=</span> <span class="p">[]</span>
      <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">F</span><span class="o">.</span><span class="n">gr</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span> <span class="ow">is</span> <span class="n">e</span><span class="p">:</span>
          <span class="n">L</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sl2</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="n">L</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sl</span><span class="p">)</span>

      <span class="k">return</span> <span class="n">F</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">name</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">name</span> <span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="n">L</span><span class="p">]),</span> <span class="n">grid</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">gr</span><span class="o">/</span><span class="bp">self</span><span class="p">,</span> <span class="n">units</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">units</span><span class="p">)</span>
   
    <span class="k">else</span><span class="p">:</span>
      <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&#39;Warning Coord slice: Coord not in Field grid. Returning Field.&#39;</span> <span class="p">)</span>   
      <span class="k">return</span> <span class="n">F</span>

<span class="c"># belongs to  Coord</span></div>
<div class="viewcode-block" id="Coord.coord_shift"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Coord.coord_shift">[docs]</a>  <span class="k">def</span> <span class="nf">coord_shift</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">F</span><span class="p">,</span><span class="n">shift</span><span class="p">,</span> <span class="n">keepgrid</span> <span class="o">=</span> <span class="bp">False</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Method of Coord .</span>
<span class="sd">    This method shifts the coordinates by a number of indices, namely parameter shift. The shifted Coord in the grid of the Field argument is replaced with a (different) shifted Coord: disable this behaviour with argument keepgrid = True.</span>

<span class="sd">   calls roll function. </span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="n">roll</span><span class="p">(</span><span class="n">F</span><span class="p">,</span><span class="n">shift</span> <span class="o">=</span> <span class="n">shift</span><span class="p">,</span><span class="n">coord</span> <span class="o">=</span> <span class="bp">self</span><span class="p">,</span><span class="n">mask</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">keepgrid</span> <span class="o">=</span> <span class="n">keepgrid</span><span class="p">)</span>

<span class="c"># belongs to  Coord </span></div>
<div class="viewcode-block" id="Coord.trans"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Coord.trans">[docs]</a>  <span class="k">def</span> <span class="nf">trans</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">F</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Method of Coord .</span>
<span class="sd">    Gives the change in Field F upon a Coord shift of 1 index in the direction of the self Coord</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c"># select keepgrid = True to avoid substraction errors relating to different grids</span>
    <span class="k">return</span> <span class="n">F</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">coord_shift</span><span class="p">(</span><span class="n">F</span><span class="p">,</span><span class="n">shift</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">keepgrid</span> <span class="o">=</span> <span class="bp">True</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Coord.sum"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Coord.sum">[docs]</a>  <span class="k">def</span> <span class="nf">sum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">F</span><span class="p">,</span> <span class="n">land_nan</span> <span class="o">=</span> <span class="bp">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Method of Coord  that sums Field F along self Coord direction. Not weighted with grid cell width. Uses masked arrays to handle nan values. nan values can be used to eliminate areas from summing area.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ma</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_array</span><span class="p">(</span><span class="n">F</span><span class="p">[:],</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">F</span><span class="p">[:])),</span> <span class="n">axis</span> <span class="o">=</span> <span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">gr</span><span class="p">)</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="p">))</span>
    <span class="n">find_land</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ma</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">F</span><span class="p">[:]</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">F</span><span class="p">[:])),</span> <span class="n">axis</span> <span class="o">=</span> <span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">gr</span><span class="p">)</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="p">))</span>

    <span class="k">if</span> <span class="n">land_nan</span><span class="p">:</span>
      <span class="k">if</span> <span class="ow">not</span> <span class="n">value</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">value</span><span class="p">[</span><span class="n">find_land</span> <span class="o">==</span> <span class="mf">0.</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

    <span class="k">if</span> <span class="bp">self</span> <span class="ow">in</span> <span class="n">F</span><span class="o">.</span><span class="n">gr</span><span class="p">:</span>
      <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">gr</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
      <span class="k">else</span><span class="p">:</span> 
        <span class="k">return</span> <span class="n">F</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">name</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">name</span><span class="p">,</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="p">,</span> <span class="n">grid</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">gr</span><span class="o">/</span><span class="bp">self</span> <span class="p">)</span>
        
    <span class="k">else</span><span class="p">:</span>
      <span class="k">raise</span>  <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;Coord sum method: Coord must be in grid of argument Field. Make sure Coord object is identical to Coord objects in Field grid.&#39;</span><span class="p">)</span>   
</div>
<div class="viewcode-block" id="Coord.roll"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Coord.roll">[docs]</a>  <span class="k">def</span> <span class="nf">roll</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">shift</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
    
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s">&#39;_rolled&#39;</span><span class="p">,</span><span class="n">value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">,</span><span class="n">shift</span> <span class="o">=</span> <span class="n">shift</span><span class="p">))</span>
</div>
<div class="viewcode-block" id="Coord.flip"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Coord.flip">[docs]</a>  <span class="k">def</span> <span class="nf">flip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">F</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Reverse order of elements along axis of this Coord. Note that grid remains unchanged: strictly, this will lead to an inconsistency between the Field data and the grid.</span>
<span class="sd">    &quot;&quot;&quot;</span>
  
    <span class="n">SI</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">slice_index</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">slice_obj</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span><span class="bp">None</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">F</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">name</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">name</span><span class="p">,</span><span class="n">value</span> <span class="o">=</span> <span class="n">F</span><span class="p">[</span><span class="n">SI</span><span class="p">],</span><span class="n">grid</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">gr</span><span class="p">,</span> <span class="n">units</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">units</span><span class="p">)</span>


</div>
<div class="viewcode-block" id="Coord.slice_index"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Coord.slice_index">[docs]</a>  <span class="k">def</span> <span class="nf">slice_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">F</span> <span class="p">,</span> <span class="n">slice_obj</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="bp">None</span><span class="p">,</span><span class="bp">None</span><span class="p">)):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Yields a list of slice objects that can be used to slice along the axis of this Coord.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sl</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="bp">None</span><span class="p">,))</span>
    <span class="n">L</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">F</span><span class="o">.</span><span class="n">gr</span><span class="p">:</span>
      <span class="k">if</span> <span class="bp">self</span> <span class="ow">is</span> <span class="n">e</span><span class="p">:</span>
        <span class="n">L</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">slice_obj</span><span class="p">)</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="n">L</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sl</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">L</span>

<span class="c"># --&gt; belongs to Coord </span>
</div>
<div class="viewcode-block" id="Coord.cumsum"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Coord.cumsum">[docs]</a>  <span class="k">def</span> <span class="nf">cumsum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">F</span><span class="p">,</span> <span class="n">upward</span> <span class="o">=</span> <span class="bp">False</span><span class="p">,</span><span class="n">land_nan</span> <span class="o">=</span> <span class="bp">True</span><span class="p">):</span>
    
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Method of Coord .</span>
<span class="sd">    Compute cumulative sum (integral) of input Field F along axis of F corresponding to this Coord object. If argument upward is set to true, summing takes place with increasing array index. If it is set to False, summing takes place with decreasing array index starting at index -1. Values of nan are set to 0, and therefore not counted.</span>

<span class="sd">    &quot;&quot;&quot;</span>

<span class="c"># nan values are set to 0. They are not counted.</span>
    <span class="k">if</span> <span class="bp">self</span> <span class="ow">in</span> <span class="n">F</span><span class="o">.</span><span class="n">gr</span><span class="p">:</span>

      <span class="k">if</span> <span class="n">upward</span><span class="p">:</span>
        <span class="c"># use the copy method of the Field to obtain a similar Field, but with some attributes different (namely, those set in the argument).</span>
        <span class="n">Fc</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">name</span><span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">name</span><span class="p">,</span><span class="n">value</span> <span class="o">=</span> <span class="n">F</span><span class="p">[:],</span> <span class="n">grid</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">gr</span><span class="p">)</span>
        
      <span class="k">else</span><span class="p">:</span>
        <span class="n">Fc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">F</span><span class="o">.</span><span class="n">name</span><span class="p">,</span><span class="n">value</span> <span class="o">=</span> <span class="n">F</span><span class="p">[:],</span> <span class="n">grid</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">gr</span><span class="p">))</span>
      
      <span class="n">land_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">Fc</span><span class="p">[:])</span> 
      <span class="n">Fc</span><span class="p">[</span><span class="n">land_i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.</span>

      <span class="n">result_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">Fc</span><span class="p">[:],</span> <span class="n">axis</span> <span class="o">=</span> <span class="p">(</span><span class="n">Fc</span><span class="o">.</span><span class="n">gr</span><span class="p">)</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="p">))</span>

      <span class="k">if</span> <span class="n">land_nan</span> <span class="o">==</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">result_array</span><span class="p">[</span><span class="n">land_i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

      <span class="k">if</span> <span class="n">upward</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">F</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">name</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">name</span><span class="p">,</span><span class="n">value</span> <span class="o">=</span> <span class="n">result_array</span><span class="p">,</span> <span class="n">grid</span> <span class="o">=</span> <span class="n">Fc</span><span class="o">.</span><span class="n">gr</span> <span class="p">)</span>
      <span class="k">else</span><span class="p">:</span>
   
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">name</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">name</span><span class="p">,</span><span class="n">value</span> <span class="o">=</span> <span class="n">result_array</span><span class="p">,</span> <span class="n">grid</span> <span class="o">=</span> <span class="n">Fc</span><span class="o">.</span><span class="n">gr</span> <span class="p">))</span>

    <span class="k">else</span><span class="p">:</span>
      <span class="k">print</span> <span class="s">&#39;Coord cum_sum method: Coord must be in grid of argument Field. Make sure Coord object is identical to Coord objects in Field grid.&#39;</span>  

</div>
<div class="viewcode-block" id="Coord.vsum"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Coord.vsum">[docs]</a>  <span class="k">def</span> <span class="nf">vsum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">F</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Method of Coord .</span>
<span class="sd">    Sums Field along self Coord, weighted with grid cell width (using self.d(), called by self.vol(F.gr)). Note: due to possible dependence of one Coord on the other, only use mean method of grid. There is no mean method for Coord objects.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">F</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vol</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">gr</span><span class="p">)))</span>     
</div>
<div class="viewcode-block" id="Coord.vcumsum"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Coord.vcumsum">[docs]</a>  <span class="k">def</span> <span class="nf">vcumsum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">F</span><span class="p">,</span><span class="n">upward</span> <span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Method of Coord .</span>
<span class="sd">    Calculates the cumulative sum weighted by width of grid cells along self direction.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">F</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vol</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">gr</span><span class="p">))</span> <span class="p">,</span> <span class="n">upward</span> <span class="o">=</span> <span class="n">upward</span><span class="p">)</span>   

</div>
<div class="viewcode-block" id="Coord.der"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Coord.der">[docs]</a>  <span class="k">def</span> <span class="nf">der</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span><span class="n">method</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Method of Coord .</span>
<span class="sd">    Derivative method on Field F. If Coord non-cyclical, the first derivative element is nan and the second is the derivative at the first element of the original Coord. </span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="bp">self</span> <span class="ow">in</span> <span class="n">F</span><span class="o">.</span><span class="n">gr</span><span class="p">:</span>
      <span class="n">dF</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">trans</span><span class="p">(</span><span class="n">F</span><span class="p">)</span>
      <span class="n">ds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">trans</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="p">())</span>

      <span class="k">return</span> <span class="n">dF</span><span class="o">/</span><span class="n">ds</span>

    <span class="k">else</span><span class="p">:</span>

      <span class="k">raise</span>  <span class="ne">Exception</span><span class="p">(</span><span class="s">&quot;derivative error: Field argument not defined on Coord.&quot;</span><span class="p">)</span>

<span class="c"># belongs to  Coord</span></div>
<div class="viewcode-block" id="Coord.s"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Coord.s">[docs]</a>  <span class="k">def</span> <span class="nf">s</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fact</span> <span class="o">=</span> <span class="mf">1.</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Yields the distance along Coord from a certain fixed point (e.g. ocean surface or from equator along y-direction).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="n">Field</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;distance_&#39;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span><span class="n">value</span> <span class="o">=</span> <span class="n">fact</span><span class="o">*</span><span class="bp">self</span><span class="p">[:],</span><span class="n">grid</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span> <span class="n">units</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">units</span><span class="p">)</span> 

<span class="c"># belongs to  Coord  </span></div>
<div class="viewcode-block" id="Coord.dist"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Coord.dist">[docs]</a>  <span class="k">def</span> <span class="nf">dist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fact</span> <span class="o">=</span> <span class="mf">1.</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Method to calculate the distance between elements of Coord.</span>
<span class="sd">    Appropriate to vertical direction.</span>
<span class="sd">    To be over-ridden for hor coords x,y =&gt; derive classes XCoord, YCoord</span>

<span class="sd">    Returns an array as len(result) == len(grid)-1</span>

<span class="sd">    &quot;&quot;&quot;</span>
       
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">trans</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="p">())</span><span class="o">*</span><span class="n">fact</span>

<span class="c"># --&gt; belongs to  Coord</span></div>
<div class="viewcode-block" id="Coord.d"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Coord.d">[docs]</a>  <span class="k">def</span> <span class="nf">d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">F</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Calculates changes of argument Field F in direction of self Coord and defined on the dual of the self Coord. If no Field is given, this yields the grid cell width, and then calculates width of grid cell in direction of self Coord object using the dual of self. Can be used to compute volumes.</span>

<span class="sd">To be overriden by coord_edge derived objects to yield a function from fields to fields and yielding differentiation. Also overriden in x and y direction to accomodate for sphere.</span>
<span class="sd"> </span>
<span class="sd">    &quot;&quot;&quot;</span>

<span class="c">#    if not(F):</span>
<span class="c">#      F = self.s()</span>

    <span class="k">if</span> <span class="n">F</span><span class="p">:</span>
      <span class="n">gr_dual</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dual</span><span class="o">*</span><span class="n">F</span><span class="o">.</span><span class="n">gr</span>
      <span class="n">ret_Field</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">&#39;d&#39;</span><span class="o">+</span><span class="n">F</span><span class="o">.</span><span class="n">name</span><span class="p">,</span><span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dual</span><span class="o">.</span><span class="n">trans</span><span class="p">(</span><span class="n">F</span><span class="p">(</span><span class="n">gr_dual</span><span class="p">))</span><span class="o">.</span><span class="n">slice</span><span class="p">(</span><span class="n">sl_coord</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dual</span><span class="p">,</span><span class="n">slice_obj</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="bp">None</span><span class="p">,</span><span class="bp">None</span><span class="p">)),</span> <span class="n">grid</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">gr</span><span class="p">,</span> <span class="n">units</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">units</span><span class="p">)</span>     

    <span class="k">else</span><span class="p">:</span>    
      <span class="n">ret_Field</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dual</span><span class="o">.</span><span class="n">dist</span><span class="p">()</span>
      <span class="k">if</span> <span class="bp">self</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dual</span><span class="p">:</span>
        <span class="n">ret_Field</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">ret_Field</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

      <span class="n">ret_Field</span><span class="o">.</span><span class="n">gr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">**</span><span class="mi">2</span>
      <span class="n">ret_Field</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">ret_Field</span><span class="o">.</span><span class="n">gr</span><span class="o">.</span><span class="n">shape</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">ret_Field</span>
</div>
<div class="viewcode-block" id="Coord.vol"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Coord.vol">[docs]</a>  <span class="k">def</span> <span class="nf">vol</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gr</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Determines widths of cells along self Coord. grid argument acts as filter: aborts if self not in grid. The grid argument is more critical in derived classes (e.g. x_coord), where auxhiliary coordinates are picked from Gr and need to be present.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="bp">self</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">gr</span><span class="p">:</span>
      <span class="k">print</span> <span class="s">&#39;Coord must be in grid argument, returning None.&#39;</span>
      <span class="k">return</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">()</span>




<span class="c"># -------- End Coord  ----------------</span>


<span class="c"># The following contains two Coord subclasses XCoord and YCoord.</span>
<span class="c"># x is longitude and re-entrant and y is latitude.</span>
</div></div>
<div class="viewcode-block" id="XCoord"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.XCoord">[docs]</a><span class="k">class</span> <span class="nc">XCoord</span><span class="p">(</span><span class="n">Coord</span><span class="p">):</span>


<div class="viewcode-block" id="XCoord.copy"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.XCoord.copy">[docs]</a>  <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">name</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span><span class="n">value</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span><span class="n">direction</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span><span class="n">units</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">long_name</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">strings</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">equiv</span> <span class="o">=</span> <span class="bp">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Copy function for Coord objects. If equiv = True, the copies will be equivalent.</span>
<span class="sd">    Copies with identical key attributes that are not equivalent will yield a severe warning about this when equivalance is tested with the ^ operator.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">frame</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">currentframe</span><span class="p">()</span>
    <span class="n">args</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">values</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">getargvalues</span><span class="p">(</span><span class="n">frame</span><span class="p">)</span>

    <span class="k">del</span> <span class="n">values</span><span class="p">[</span><span class="s">&#39;frame&#39;</span><span class="p">]</span>
    <span class="k">del</span> <span class="n">values</span><span class="p">[</span><span class="s">&#39;equiv&#39;</span><span class="p">]</span>   
   
    <span class="k">del</span> <span class="n">values</span><span class="p">[</span><span class="s">&#39;self&#39;</span><span class="p">]</span>     
    
    <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">values</span><span class="p">:</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">arg</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="p">):</span>

          <span class="k">if</span> <span class="n">values</span><span class="p">[</span><span class="n">arg</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">values</span><span class="p">[</span><span class="n">arg</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="p">[</span><span class="n">arg</span><span class="p">]</span>

      <span class="k">else</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&#39;Warning: arg </span><span class="si">%s</span><span class="s"> is not an object attribute.&#39;</span> <span class="o">%</span><span class="n">arg</span><span class="p">)</span>
   
  
    <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">(</span><span class="o">**</span><span class="n">values</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">equiv</span><span class="p">:</span>
      <span class="n">result</span><span class="o">.</span><span class="n">equivs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">equivs</span>


    <span class="k">return</span> <span class="n">result</span>
</div>
<div class="viewcode-block" id="XCoord.roll"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.XCoord.roll">[docs]</a>  <span class="k">def</span> <span class="nf">roll</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">shift</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
    <span class="n">value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">,</span><span class="n">shift</span> <span class="o">=</span> <span class="n">shift</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">shift</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
      <span class="n">value</span><span class="p">[:</span><span class="n">shift</span><span class="p">]</span> <span class="o">-=</span> <span class="mf">360.</span>
    <span class="k">elif</span> <span class="n">shift</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
      <span class="n">value</span><span class="p">[</span><span class="n">shift</span><span class="p">:]</span> <span class="o">+=</span> <span class="mf">360.</span>
      <span class="n">value</span> <span class="o">-=</span> <span class="mf">360.</span>
   
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s">&#39;_rolled&#39;</span><span class="p">,</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="p">)</span>

<span class="c"># belongs to XCoord </span></div>
<div class="viewcode-block" id="XCoord.coord_shift"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.XCoord.coord_shift">[docs]</a>  <span class="k">def</span> <span class="nf">coord_shift</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">F</span><span class="p">,</span><span class="n">shift</span><span class="p">,</span> <span class="n">keepgrid</span> <span class="o">=</span> <span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Overides Coord coord_shift method. Here, mask is False, so that the array is rotated.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="n">roll</span><span class="p">(</span><span class="n">F</span><span class="p">,</span><span class="n">shift</span> <span class="o">=</span> <span class="n">shift</span><span class="p">,</span><span class="n">coord</span> <span class="o">=</span> <span class="bp">self</span><span class="p">,</span> <span class="n">keepgrid</span> <span class="o">=</span> <span class="n">keepgrid</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="XCoord.der"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.XCoord.der">[docs]</a>  <span class="k">def</span> <span class="nf">der</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span><span class="n">y_coord</span><span class="p">,</span><span class="n">method</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Derivative method on Field F.</span>
<span class="sd">    &quot;&quot;&quot;</span>


<span class="c"># Cyclical coords uses different method for ds.</span>

    <span class="k">if</span> <span class="bp">self</span> <span class="ow">in</span> <span class="n">F</span><span class="o">.</span><span class="n">gr</span><span class="p">:</span>
      <span class="n">dF</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">trans</span><span class="p">(</span><span class="n">F</span><span class="p">)</span>
      <span class="n">ds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">angle_trans</span><span class="p">(</span><span class="n">y_coord</span><span class="p">)</span>

      <span class="k">return</span> <span class="n">dF</span><span class="o">/</span><span class="n">ds</span>

    <span class="k">else</span><span class="p">:</span>

      <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&quot;Derivative error: Field argument not defined on Coord.&quot;</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="XCoord.angle_trans"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.XCoord.angle_trans">[docs]</a>  <span class="k">def</span> <span class="nf">angle_trans</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">y_coord</span><span class="p">,</span><span class="n">fact</span> <span class="o">=</span> <span class="n">R</span><span class="p">):</span>
 
    <span class="n">crdvals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="bp">self</span><span class="p">[:],</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">crdvals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-=</span> <span class="mf">360.</span>
    <span class="n">crdvals</span> <span class="o">-=</span> <span class="bp">self</span><span class="p">[:]</span>

    <span class="n">val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span> <span class="o">-</span><span class="n">fact</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">y</span><span class="p">))</span><span class="o">*</span><span class="n">crdvals</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">y_coord</span>  <span class="p">])</span>

    
   
    <span class="k">return</span> <span class="n">Field</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;delta_&#39;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span><span class="n">value</span> <span class="o">=</span> <span class="n">val</span><span class="p">,</span><span class="n">grid</span> <span class="o">=</span> <span class="n">y_coord</span><span class="o">*</span><span class="bp">self</span><span class="p">,</span> <span class="n">units</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">units</span><span class="p">)</span> 

</div>
<div class="viewcode-block" id="XCoord.s"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.XCoord.s">[docs]</a>  <span class="k">def</span> <span class="nf">s</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y_coord</span><span class="p">,</span> <span class="n">fact</span> <span class="o">=</span> <span class="n">R</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Distance along self x-coord direction from a fixed point.</span>
<span class="sd">    &quot;&quot;&quot;</span>



    <span class="n">crdvals</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[:]</span>
    
    <span class="k">return</span> <span class="n">Field</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;distance_&#39;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span><span class="n">value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span> <span class="n">fact</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">y</span><span class="p">))</span><span class="o">*</span><span class="n">crdvals</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">y_coord</span>  <span class="p">])</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mf">180.</span><span class="p">,</span><span class="n">grid</span> <span class="o">=</span> <span class="n">y_coord</span><span class="o">*</span><span class="bp">self</span><span class="p">,</span> <span class="n">units</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">units</span><span class="p">)</span> 
</div>
<div class="viewcode-block" id="XCoord.dist"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.XCoord.dist">[docs]</a>  <span class="k">def</span> <span class="nf">dist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y_coord</span><span class="p">,</span> <span class="n">fact</span> <span class="o">=</span> <span class="n">R</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Method to calculate the distance between elements of Coord.</span>
<span class="sd">    </span>

<span class="sd">    &quot;&quot;&quot;</span>
       
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">angle_trans</span><span class="p">(</span><span class="n">y_coord</span><span class="p">,</span> <span class="n">fact</span> <span class="o">=</span> <span class="n">fact</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mf">180.</span>


</div>
<div class="viewcode-block" id="XCoord.d"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.XCoord.d">[docs]</a>  <span class="k">def</span> <span class="nf">d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">y_coord</span><span class="p">,</span><span class="n">F</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Grid cell width method&quot;. Calculates width of grid cell in direction of self Coord object (e.g. in the direction of xt) using the dual of self (e.g. xt_edges). </span>

<span class="sd">    Can be used to compute volumes.</span>

<span class="sd">    Returns Field of shape (len(yt),len(xt)) containing the widths</span>
<span class="sd">    For instance, xt.d(yt) yields a Field containing name attribute &#39;dxt&#39;</span>


<span class="sd"> </span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c"># This d method overides the standard d method of the Coord class.</span>
    <span class="c"># It takes the y coordinate object in argument y_coord.</span>
    <span class="c"># When constructing classes derived from the Coord class, use</span>
    <span class="c"># this naming convention for Coord arguments: name argument</span>
    <span class="c"># {x,y,z}_coord to take {x,y,z}coord object. This can then be</span>
    <span class="c"># used to determine volume elements in grid objects (using the inspect module).</span>

    <span class="k">if</span> <span class="n">F</span><span class="p">:</span>
      <span class="n">gr_dual</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dual</span><span class="o">*</span><span class="n">F</span><span class="o">.</span><span class="n">gr</span>
      <span class="n">ret_Field</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">&#39;d&#39;</span><span class="o">+</span><span class="n">F</span><span class="o">.</span><span class="n">name</span><span class="p">,</span><span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dual</span><span class="o">.</span><span class="n">trans</span><span class="p">(</span><span class="n">F</span><span class="p">(</span><span class="n">gr_dual</span><span class="p">))</span><span class="o">.</span><span class="n">slice</span><span class="p">(</span><span class="n">sl_coord</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dual</span><span class="p">,</span><span class="n">slice_obj</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="bp">None</span><span class="p">,</span><span class="bp">None</span><span class="p">)),</span> <span class="n">grid</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">gr</span><span class="p">,</span> <span class="n">units</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">units</span><span class="p">)</span>     

    <span class="k">else</span><span class="p">:</span>    
      <span class="n">ret_Field</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dual</span><span class="o">.</span><span class="n">dist</span><span class="p">(</span><span class="n">y_coord</span><span class="p">)</span>
      <span class="n">ret_Field</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">ret_Field</span><span class="p">[:,</span><span class="mi">1</span><span class="p">:]</span>
      <span class="n">ret_Field</span><span class="o">.</span><span class="n">gr</span> <span class="o">=</span> <span class="n">y_coord</span><span class="o">*</span><span class="bp">self</span>
      <span class="n">ret_Field</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">ret_Field</span><span class="o">.</span><span class="n">gr</span><span class="o">.</span><span class="n">shape</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">ret_Field</span>


<span class="c"># --&gt; belongs to XCoord</span>
</div>
<div class="viewcode-block" id="XCoord.vol"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.XCoord.vol">[docs]</a>  <span class="k">def</span> <span class="nf">vol</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">gr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    1-D volume method of XCoord class (the lengths of the grid cells in the x-direction, dependent on y).</span>
<span class="sd">    Determines widths of grid cells in self Coord, picking auxiliary coordinate (as when x-widths depend on y) from grid argument gr (y grid is chosen on the same grid as x-coord). </span>
<span class="sd">    Returns Field. Returns None if self not in grid.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># Depends on the use of {x,y,z}_coord convention in arguments to d() method of classes derived from Coord class (e.g. XCoord takes y_coord argument).</span>

    <span class="k">if</span> <span class="bp">self</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">gr</span><span class="p">:</span>
      <span class="k">print</span> <span class="s">&#39;Coord must be in grid argument, returning None.&#39;</span>
      <span class="k">return</span>


    <span class="n">coord_types</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;x_coord&#39;</span><span class="p">:</span><span class="n">XCoord</span><span class="p">,</span><span class="s">&#39;y_coord&#39;</span><span class="p">:</span><span class="n">YCoord</span><span class="p">,</span><span class="s">&#39;z_coord&#39;</span><span class="p">:</span><span class="n">Coord</span><span class="p">}</span>

    <span class="n">coord_store</span> <span class="o">=</span> <span class="p">{}</span>
<span class="c"># Determine the type of each coord in self</span>
    <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">gr</span><span class="p">:</span>
      <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">coord_types</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">coord_types</span><span class="p">[</span><span class="n">i</span><span class="p">]):</span>
          <span class="n">coord_store</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span>

    <span class="c"># dV the identity initially</span>
<span class="c">#    dV = Coord(&#39;scalar&#39;)</span>
   
      <span class="c"># get the Coord-derived objects that need to be passed to each d method of Coord (e.g. xt.d(yt))</span>

    <span class="k">try</span><span class="p">:</span>
      <span class="n">coords</span> <span class="o">=</span> <span class="p">[</span><span class="n">coord_store</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">inspect</span><span class="o">.</span><span class="n">getargspec</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">c</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&#39;x_coord&#39;</span><span class="p">,</span><span class="s">&#39;y_coord&#39;</span><span class="p">,</span><span class="s">&#39;z_coord&#39;</span><span class="p">]]</span>
    <span class="k">except</span><span class="p">:</span>
      <span class="k">print</span> <span class="s">&#39;Error in Coord argument matching. Required Coord likely absent in grid argument.&#39;</span>
      <span class="k">raise</span>

      <span class="c"># Use splat operator * to pass coords list on as argument. Create Field dV.</span>
      
    <span class="n">dV</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">(</span><span class="o">*</span><span class="n">coords</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">dV</span>     
  

</div></div>
<div class="viewcode-block" id="YCoord"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.YCoord">[docs]</a><span class="k">class</span> <span class="nc">YCoord</span><span class="p">(</span><span class="n">Coord</span><span class="p">):</span>

<div class="viewcode-block" id="YCoord.copy"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.YCoord.copy">[docs]</a>  <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">name</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span><span class="n">value</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span><span class="n">direction</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span><span class="n">units</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">long_name</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">strings</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">equiv</span> <span class="o">=</span> <span class="bp">True</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Copy function for Coord objects. If equiv = True, the copies will be equivalent.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">frame</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">currentframe</span><span class="p">()</span>
    <span class="n">args</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">values</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">getargvalues</span><span class="p">(</span><span class="n">frame</span><span class="p">)</span>

    <span class="k">del</span> <span class="n">values</span><span class="p">[</span><span class="s">&#39;frame&#39;</span><span class="p">]</span>
    <span class="k">del</span> <span class="n">values</span><span class="p">[</span><span class="s">&#39;equiv&#39;</span><span class="p">]</span>   
   
    <span class="k">del</span> <span class="n">values</span><span class="p">[</span><span class="s">&#39;self&#39;</span><span class="p">]</span>    

    
    <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">values</span><span class="p">:</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">arg</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="p">):</span>

          <span class="k">if</span> <span class="n">values</span><span class="p">[</span><span class="n">arg</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">values</span><span class="p">[</span><span class="n">arg</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="p">[</span><span class="n">arg</span><span class="p">]</span>

      <span class="k">else</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&#39;Warning: arg </span><span class="si">%s</span><span class="s"> is not an object attribute.&#39;</span> <span class="o">%</span><span class="n">arg</span> <span class="p">)</span>
   
 
    <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">(</span><span class="o">**</span><span class="n">values</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">equiv</span><span class="p">:</span>
      <span class="n">result</span><span class="o">.</span><span class="n">equivs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">equivs</span>


    <span class="k">return</span> <span class="n">result</span>

</div>
  <span class="k">def</span> <span class="nf">s</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fact</span> <span class="o">=</span> <span class="n">R</span><span class="p">):</span>

    <span class="k">return</span> <span class="n">Field</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;distance_&#39;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span><span class="n">value</span> <span class="o">=</span> <span class="n">fact</span><span class="o">*</span><span class="bp">self</span><span class="p">[:],</span><span class="n">grid</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span> <span class="n">units</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">units</span><span class="p">)</span> 

<div class="viewcode-block" id="YCoord.s"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.YCoord.s">[docs]</a>  <span class="k">def</span> <span class="nf">s</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fact</span> <span class="o">=</span> <span class="n">R</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Yields the distance along Coord from a certain fixed point (e.g. ocean surface or from equator along y-direction).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="n">Field</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;distance_&#39;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span><span class="n">value</span> <span class="o">=</span> <span class="n">fact</span><span class="o">*</span><span class="bp">self</span><span class="p">[:]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mf">180.</span><span class="p">,</span><span class="n">grid</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span> <span class="n">units</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">units</span><span class="p">)</span> 



<span class="c">#------------------------- Ax and AxGr  -------------------------------</span>



<span class="c"># -------- Ax  definition ----------</span>


</div></div>
<div class="viewcode-block" id="Ax"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Ax">[docs]</a><span class="k">class</span> <span class="nc">Ax</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  axis .</span>
<span class="sd">  &quot;&quot;&quot;</span>

  <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>


  <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">i</span><span class="p">):</span>
    <span class="k">return</span> 

<div class="viewcode-block" id="Ax.same"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Ax.same">[docs]</a>  <span class="k">def</span> <span class="nf">same</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">name</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">direction</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">direction</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Ax.samein"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Ax.samein">[docs]</a>  <span class="k">def</span> <span class="nf">samein</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">L</span><span class="p">):</span>

    <span class="k">return</span> <span class="nb">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">:</span><span class="n">x</span> <span class="ow">or</span> <span class="n">y</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">same</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="n">L</span><span class="p">]</span> <span class="p">)</span>
</div>
<div class="viewcode-block" id="Ax.sameindex"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Ax.sameindex">[docs]</a>  <span class="k">def</span> <span class="nf">sameindex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">L</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">it</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">L</span><span class="p">):</span>
      <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">same</span><span class="p">(</span><span class="n">it</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">i</span>
     
    <span class="k">return</span> <span class="bp">None</span>    

</div>
  <span class="k">def</span> <span class="nf">__and__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">):</span>
    <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">name</span><span class="p">):</span>
      <span class="k">return</span> <span class="bp">True</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">return</span> <span class="bp">False</span>


<div class="viewcode-block" id="Ax.copy"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Ax.copy">[docs]</a>  <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">(</span><span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
</div>
  <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">):</span>

    <span class="k">if</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">other</span><span class="p">:</span>
      <span class="k">return</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">return</span> <span class="mi">0</span>

  <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;scalar&#39;</span><span class="p">,</span><span class="n">direction</span> <span class="o">=</span><span class="s">&#39;scalar&#39;</span><span class="p">,</span><span class="n">display_name</span><span class="o">=</span> <span class="s">&#39;&#39;</span> <span class="p">):</span>  

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Initialisation of Ax object. </span>

<span class="sd">    &quot;&quot;&quot;</span>
  
<span class="c"># choosing the name ID creates an identity object. ID*b = b for all Coord elements b.</span>
<span class="c"># could implement the identity Field in __call__</span>

<span class="c"># Metric could be a class. Objects of this class could be constructed by a method of the Coord class (Coord objects then spawn metric objects).</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">equivs</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="p">]</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">direction</span> <span class="o">=</span> <span class="n">direction</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">display_name</span> <span class="o">=</span> <span class="n">display_name</span>
 
<span class="c"># --&gt; belongs to Ax </span>
  <span class="k">def</span> <span class="nf">__or__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Register equivalence. e.g. a = Gr((&#39;xt&#39;,)) and b = Ax((&#39;X&#39;,))</span>
<span class="sd">    a|b registers b in the equivalents of a and vice versa.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">Coord</span><span class="p">)</span> <span class="o">|</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">Ax</span><span class="p">):</span>
      <span class="c"># argument is Coord/ Ax: equivalence check functionality</span>
      <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">equivs</span><span class="p">):</span>
        <span class="n">e</span><span class="o">.</span><span class="n">equivs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

      <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">equivs</span><span class="p">):</span>
        <span class="n">e</span><span class="o">.</span><span class="n">equivs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>        

      <span class="bp">self</span><span class="o">.</span><span class="n">equivs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">equivs</span><span class="p">))</span>
      <span class="n">other</span><span class="o">.</span><span class="n">equivs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">equivs</span><span class="p">))</span>
      <span class="k">return</span>

<span class="c"># ---end equivalence check functionality.</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">Field</span><span class="p">):</span>
      <span class="c"># argument is Field: cumsum functionality.</span>
      <span class="c"># reduce to Coord method on other via multiplication:</span>
      <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">*</span><span class="n">other</span><span class="o">.</span><span class="n">gr</span><span class="p">)</span><span class="o">|</span><span class="n">other</span>
 
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">VField</span><span class="p">):</span>
      <span class="k">return</span> <span class="n">VField</span><span class="p">([</span><span class="bp">self</span><span class="o">|</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">other</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;Ax error in </span><span class="si">%s</span><span class="s">|</span><span class="si">%s</span><span class="s"> with Coord </span><span class="si">%s</span><span class="s">: provide Coord, Ax or Field object for right member (now </span><span class="si">%s</span><span class="s">).&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">,</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">)</span> <span class="p">)</span>



<span class="c"># --&gt; belongs to Ax    </span>

  <span class="k">def</span> <span class="nf">__xor__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    If argument is a Coord, this method tests for equivalence. e.g. xt ~ xu</span>
<span class="sd">    If argument is a Field, this method takes the derivative along self Coord axis.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
  
    <span class="c"># This method works recursively to ensure associativity of the ^ relationship. E.g. a0^a1 is True and a1^a2 is True =&gt; a0^a3 is True</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">Coord</span><span class="p">)</span> <span class="o">|</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">Ax</span><span class="p">):</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">other</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">equivs</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="bp">self</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">equivs</span><span class="p">):</span>

        <span class="k">return</span> <span class="bp">True</span>
      
      <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">False</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">Field</span><span class="p">):</span>
<span class="c">#      return (self*(other.gr)).der(other)</span>
      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">der</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">VField</span><span class="p">):</span>
      <span class="k">return</span> <span class="n">VField</span><span class="p">(</span> <span class="p">[</span><span class="bp">self</span><span class="o">^</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">other</span> <span class="p">]</span> <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;Ax error in </span><span class="si">%s</span><span class="s">^</span><span class="si">%s</span><span class="s"> with Ax </span><span class="si">%s</span><span class="s">. Provide Coord, Ax or Field for right member (now </span><span class="si">%s</span><span class="s">).&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">,</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">)</span> <span class="p">)</span>
      <span class="k">return</span>

<div class="viewcode-block" id="Ax.der"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Ax.der">[docs]</a>  <span class="k">def</span> <span class="nf">der</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">F</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Derivative method of Ax . Uses entire grid, in case some coords depend on other coords. e.g. x-differentiation requires knowledge of y-position due to nature of polar coords.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">gr</span><span class="p">)</span><span class="o">.</span><span class="n">der</span><span class="p">(</span><span class="n">crd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">*</span><span class="n">F</span><span class="o">.</span><span class="n">gr</span><span class="p">,</span> <span class="n">F</span> <span class="o">=</span> <span class="n">F</span><span class="p">)</span>      
</div>
  <span class="k">def</span> <span class="nf">__pow__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">n</span><span class="p">):</span>

    <span class="k">return</span> <span class="nb">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">:</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">,</span> <span class="n">n</span><span class="o">*</span><span class="p">[</span><span class="bp">self</span><span class="p">])</span>

<span class="c"># --&gt; belongs to Ax </span>
  <span class="k">def</span> <span class="nf">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">):</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s">&#39;scalar&#39;</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">AxGr</span><span class="p">((</span><span class="n">other</span><span class="p">,))</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">Coord</span><span class="p">):</span>   
        <span class="c"># --&gt; multiplication with Coord: yields right multiplicant if equivalent, none otherwise.</span>
        <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s">&#39;scalar&#39;</span><span class="p">:</span> 
          <span class="k">return</span> <span class="n">AxGr</span><span class="p">((</span><span class="bp">self</span><span class="p">,))</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="k">if</span> <span class="n">other</span><span class="o">^</span><span class="bp">self</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">AxGr</span><span class="p">((</span><span class="n">other</span><span class="p">,))</span>
          <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> 


      <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">Ax</span><span class="p">):</span>   
        <span class="c"># --&gt; multiplication with Ax object: behaves as Coord multiplication.</span>
        <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s">&#39;scalar&#39;</span><span class="p">:</span> 
          <span class="k">return</span> <span class="n">AxGr</span><span class="p">((</span><span class="bp">self</span><span class="p">,))</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="k">if</span> <span class="n">other</span><span class="o">^</span><span class="bp">self</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">AxGr</span><span class="p">((</span><span class="bp">self</span><span class="p">,))</span>
          <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">AxGr</span><span class="p">((</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">))</span>

      <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">Gr</span><span class="p">):</span>   
        <span class="c"># --&gt; multiplication with Gr object: yields equivalent Coord in Gr or raises error.</span>
        <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">eq_in</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

          <span class="k">return</span> <span class="n">other</span><span class="p">[</span><span class="n">other</span><span class="o">.</span><span class="n">eq_index</span><span class="p">(</span><span class="bp">self</span><span class="p">)]</span>

        <span class="k">else</span><span class="p">:</span>
<span class="c">#          raise Exception(&#39;Axis not in Coord grid.&#39;)</span>
          <span class="k">return</span> <span class="bp">None</span> 
        
      <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">AxGr</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span> <span class="ow">in</span> <span class="n">other</span><span class="p">:</span>
          <span class="k">return</span> <span class="n">other</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="k">return</span> <span class="n">AxGr</span><span class="p">([</span><span class="bp">self</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="p">)</span>


      <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">Field</span><span class="p">):</span>
        <span class="c"># --&gt; multiplication with Field object: yields grid method on Field, which is cumsum</span>
        <span class="c"># reduce to Coord via multiplication and then to grid method via power:</span>
        <span class="k">return</span> <span class="p">((</span><span class="bp">self</span><span class="o">*</span><span class="n">other</span><span class="o">.</span><span class="n">gr</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">other</span>

      <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">VField</span><span class="p">):</span>

        <span class="k">return</span> <span class="n">VField</span><span class="p">([</span><span class="bp">self</span><span class="o">*</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">other</span><span class="p">])</span>


      <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;Ax error in </span><span class="si">%s</span><span class="s">*</span><span class="si">%s</span><span class="s"> with Ax </span><span class="si">%s</span><span class="s">: provide Coord, Gr or Field object as right multiplicant (now </span><span class="si">%s</span><span class="s">). If multiplicant appears to be a Coord of other multiplicant Field, check whether it is stale --&gt; update from Exper Coord stack to be synchronous with the grid of that Field. &#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">,</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">))</span>




<span class="c"># -------- End Ax  definition ----------</span>

</div>
<div class="viewcode-block" id="AxGr"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.AxGr">[docs]</a><span class="k">class</span> <span class="nc">AxGr</span><span class="p">(</span><span class="nb">tuple</span><span class="p">):</span>


  <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>    
    <span class="n">rp</span> <span class="o">=</span> <span class="s">&#39;(&#39;</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
      <span class="n">rp</span> <span class="o">+=</span> <span class="n">i</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span><span class="s">&#39;,&#39;</span>
    
    <span class="k">return</span> <span class="n">rp</span><span class="o">+</span><span class="s">&#39;)&#39;</span>


  <span class="k">def</span> <span class="nf">__and__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">):</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
      <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">c</span><span class="o">&amp;</span><span class="n">other</span><span class="p">[</span><span class="n">i</span><span class="p">]):</span>    
          <span class="k">return</span> <span class="bp">False</span>

      <span class="k">return</span> <span class="bp">True</span>

    <span class="k">else</span><span class="p">:</span>

      <span class="k">return</span> <span class="bp">False</span>

<div class="viewcode-block" id="AxGr.copy"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.AxGr.copy">[docs]</a>  <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

    <span class="k">return</span> <span class="n">AxGr</span><span class="p">(</span> <span class="p">[</span> <span class="n">e</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span>  <span class="p">]</span> <span class="p">)</span>
</div>
  <span class="k">def</span> <span class="nf">__div__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Division of grids. E.g. xt*yt*zt/yt = xt*zt</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">Ax</span><span class="p">):</span>
      <span class="n">other</span> <span class="o">=</span> <span class="n">AxGr</span><span class="p">((</span><span class="n">other</span><span class="p">,))</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">Coord</span><span class="p">):</span>
      <span class="n">other</span> <span class="o">=</span> <span class="n">Gr</span><span class="p">((</span><span class="n">other</span><span class="p">,))</span>

    <span class="n">result</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
      <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">eq_in</span><span class="p">(</span><span class="n">it</span><span class="p">):</span>
        <span class="n">result</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">AxGr</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>




  <span class="k">def</span> <span class="nf">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Multiplication of Ax grids.</span>
<span class="sd">    (X*Z)*(zt*yt*xu) = xu*zt</span>

<span class="sd">    Multiplication can take other arguments than just Ax grids. If a Field is provided as right multiplicant, the Field is summed over the left multiplicant grid, weighted with grid cell widths (the equivalence of integration over the grid space). If the right multiplicant is a Coord object, it is converted to a single-element grid (gr) object before multiplication. </span>

<span class="sd">if right multiplicant is Gr object, operation picks elements from right multiplicant that are equivalent with Ax objects in AxGr object left multiplicant and yields a product in the order of the left multiplicant.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">Field</span><span class="p">):</span>

      <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">*</span><span class="n">other</span><span class="o">.</span><span class="n">gr</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">VField</span><span class="p">):</span>

      <span class="k">return</span> <span class="n">VField</span><span class="p">([</span><span class="bp">self</span><span class="o">*</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">other</span><span class="p">])</span>


    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">Coord</span><span class="p">):</span>
      <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s">&#39;scalar&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">eq_in</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
          <span class="k">return</span> <span class="n">other</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="k">return</span> 

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">Ax</span><span class="p">):</span>
      <span class="c"># multiplication between Gr Ax and Ax objects</span>
      <span class="k">if</span> <span class="n">other</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">AxGr</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="n">other</span><span class="p">])</span>


      <span class="k">return</span> <span class="n">other</span><span class="o">*</span><span class="bp">self</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">AxGr</span><span class="p">):</span>

      <span class="k">return</span> <span class="nb">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">:</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span> <span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">other</span><span class="p">))</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">Gr</span><span class="p">):</span>
      <span class="c"># if right multiplicant is Gr object, operation picks elements from right multiplicant that are equivalent with Ax objects in AxGr object left multiplicant and yields a product in the order of the left multiplicant.</span>
      <span class="n">L</span> <span class="o">=</span> <span class="p">[]</span>

      <span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">eq_in</span><span class="p">(</span><span class="n">it</span><span class="p">):</span>
          <span class="n">L</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">other</span><span class="p">[</span><span class="n">other</span><span class="o">.</span><span class="n">eq_index</span><span class="p">(</span><span class="n">it</span><span class="p">)])</span>

      <span class="k">return</span> <span class="n">Gr</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>    


    <span class="k">else</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;gr type error </span><span class="si">%s</span><span class="s">*</span><span class="si">%s</span><span class="s"> with Gr </span><span class="si">%s</span><span class="s"> (grid): provide Field, Gr or Coord object or np array as right multiplicant (now </span><span class="si">%s</span><span class="s">).&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">,</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">)</span> <span class="p">)</span>


<div class="viewcode-block" id="AxGr.eq_in"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.AxGr.eq_in">[docs]</a>  <span class="k">def</span> <span class="nf">eq_in</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">crd</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
      <span class="k">if</span> <span class="n">crd</span><span class="o">^</span><span class="n">i</span><span class="p">:</span> <span class="k">return</span> <span class="bp">True</span>
    <span class="k">return</span> <span class="bp">False</span>




<span class="c">#------------------------- end Ax and AxGr  -------------------------------</span>


<span class="c"># -------------- grid  --------------------------</span>

</div></div>
<div class="viewcode-block" id="Gr"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Gr">[docs]</a><span class="k">class</span> <span class="nc">Gr</span><span class="p">(</span><span class="nb">tuple</span><span class="p">):</span>

  <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Gr . consists of a tuple of Coord objects, with additional methods. Gr objects g1 and g2 are considered equal, g1&amp;g2 yields True, when the individual Coord elements are equal.</span>
<span class="sd">  &quot;&quot;&quot;</span>



  <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">):</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>

      <span class="k">return</span> <span class="nb">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="ow">and</span> <span class="n">y</span><span class="p">,</span> <span class="p">[</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">e</span><span class="p">[:],</span> <span class="n">other</span><span class="p">[</span><span class="n">i</span><span class="p">][:])</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">e</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>  <span class="p">]</span> <span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
      <span class="k">return</span> <span class="bp">False</span>

<div class="viewcode-block" id="Gr.same"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Gr.same">[docs]</a>  <span class="k">def</span> <span class="nf">same</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;    </span>
<span class="sd">    Coord-wise comparison of elements using Coord same method. </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>

      <span class="k">return</span> <span class="nb">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="ow">and</span> <span class="n">y</span><span class="p">,</span> <span class="p">[</span> <span class="n">e</span><span class="o">.</span><span class="n">same</span><span class="p">(</span> <span class="n">other</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">e</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>  <span class="p">]</span> <span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
      <span class="k">return</span> <span class="bp">False</span>
</div>
  <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">,</span> <span class="n">method</span> <span class="o">=</span> <span class="s">&#39;linear&#39;</span><span class="p">):</span>

    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">regrid</span><span class="p">(</span><span class="n">other</span> <span class="o">=</span> <span class="n">other</span><span class="p">,</span> <span class="n">method</span> <span class="o">=</span> <span class="n">method</span><span class="p">)</span>

<div class="viewcode-block" id="Gr.regrid"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Gr.regrid">[docs]</a>  <span class="k">def</span> <span class="nf">regrid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">,</span> <span class="n">method</span> <span class="o">=</span> <span class="s">&#39;linear&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Input: other Gr object (grid). </span>

<span class="sd">    The regrid method of a Gr object takes another Gr object, other, and yields a function F. This function F takes an array A and re-arranges the order of   the indices to match the input Gr object (other). If the length of the input object exceeds that of the calling object, F(A) also expands the array along the additional axes by creating copies of it along those axes (using the expand method). Note that the coords of the calling Gr object need to be a subset of the argument Gr object.</span>
<span class="sd">    </span>

<span class="sd">    Yields a transformation on fields going from self grid to other grid.</span>

<span class="sd">    E.g. xt*yt(yt*xt) yields a tranpose operation on an array</span>
<span class="sd">    xt*yt(xu*yu) yields an interpolation acting on fields.</span>

<span class="sd">    yt*xt(zt*yt*xt) yields a functions transforming a 2D array corresponding to the values of a Field defined on yt*xt to a 3D array constant in the zt direction.</span>
<span class="sd">    </span>

<span class="sd">    If self is longer than other, calling will lead to a reduction. E.g.</span>

<span class="sd">    R=(zt*yt*xt)((yt**2))(A) where A.shape = (len(zt),len(yt),len(xt))</span>
<span class="sd">    Leads to a list of length len(yt) containing arrays of dimension len(zt) by len(xt).</span>
<span class="sd">    Then for S=array(R) we get S.shape is (len(yt), len(zt), len(xt))</span>
<span class="sd">    </span>
<span class="sd">    For R=(zt*yt*xt)((xt*yt))(A) we get a list of lists and S.shape is (len(xt), len(yt), len(zt))</span>
<span class="sd">    Note that yt,xt appear in different order in self and other.</span>
<span class="sd">    </span>


<span class="sd">    &quot;&quot;&quot;</span>

<span class="c"># might expand other to other*self in future code.</span>
    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>    
<span class="c"># *** CASE 1 ************************</span>

      <span class="c"># in this case both grids span the same space</span>

      <span class="c"># check if a permutation of Coord objects exists, i.e. whether the elements of either can be rearranged to yield the other: </span>
      <span class="n">pm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">perm</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">verbose</span> <span class="o">=</span> <span class="bp">False</span><span class="p">)</span>

      <span class="k">if</span> <span class="n">pm</span><span class="p">:</span>
        <span class="c"># CASE 1a ***</span>

        <span class="c"># if so, a function is returned that attempts to transpose any np array according to the permutation required to go from self to other.</span>
        <span class="c"># If A is a np array defined consistent with self ( A.shape is self.shape() ), then self(other)(A) is a np array consistent with other</span>
        <span class="k">return</span> <span class="k">lambda</span> <span class="n">A</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">pm</span><span class="p">)</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="c"># if no such direct permutation exists, check for a weaker conditions:</span>
        <span class="n">pm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eq_perm</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="c"># if there is a permutation of the coords up to equivalence (case 1b below), pm is that permutation and after permuting array A, the result needs to be interpolated from the permuted self (namely self.rearrange(pm)) to other.</span>
        <span class="c"># Here, &quot;up to equivalence&quot; means &quot;equivalent Coord objects being considered identical in considering whether a permutation exists&quot;.</span>
        <span class="c">#If A is a np array defined consistent with self, then self(other)(A) is a np array consistent with other, is interpolated onto the other.</span>

        <span class="k">if</span> <span class="n">pm</span><span class="p">:</span>
          <span class="c"># CASE 1b ***</span>
          <span class="k">return</span> <span class="k">lambda</span> <span class="n">A</span><span class="p">:</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">pm</span><span class="p">))</span><span class="o">.</span><span class="n">_smart_interp</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">pm</span><span class="p">),</span><span class="n">other</span><span class="p">,</span> <span class="n">method</span> <span class="o">=</span> <span class="n">method</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="c"># CASE 1c ***</span>
          <span class="c"># No luck.</span>
          <span class="k">print</span> <span class="s">&quot;grid </span><span class="si">%s</span><span class="s"> not equivalent to </span><span class="si">%s</span><span class="s">.&quot;</span><span class="o">%</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">)</span>
          <span class="k">return</span>

    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>  

<span class="c"># *** CASE 2 ************************</span>

      <span class="c"># A grid is called on a higher dimensional grid.</span>

      <span class="c"># inflate self grid by left multiplying with non-self elements</span>
      <span class="c"># don&#39;t do deepcopy, it copies the individual Coord elements too!</span>
      <span class="c"># instead, use the identity Coord:</span>

      <span class="c"># re-arrange Coord terms in accordance with expand method (the non-self elements of the other Gr are appended on the LEFT, and in the order of other).</span>
      <span class="c"># e.g. R=(yt*xt)(xt*yt*zw) yields a function yielding an array defined on the grid zw*yt*xt</span>
      <span class="c"># the order of the Coord elements in self_expanded is arranged so as to perform the expansion more easily (namely, adding axes at the beginning).</span>

      <span class="c"># if A is an ndarray consistent with self, then self.expand(A,other) is an ndarray consistent with the Gr self_expanded created here:</span>
      <span class="n">self_expanded</span> <span class="o">=</span> <span class="p">(</span><span class="n">other</span><span class="o">/</span><span class="bp">self</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span>

      <span class="c"># we now have a grid of equal length to other.</span>

      <span class="c"># the expanded left argument is not always in the same order as other (or even fully comprising of identical elements)</span>
      <span class="n">pm</span> <span class="o">=</span> <span class="n">self_expanded</span><span class="o">.</span><span class="n">perm</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">verbose</span> <span class="o">=</span> <span class="bp">False</span><span class="p">)</span>
     
      <span class="k">if</span> <span class="n">pm</span><span class="p">:</span>
        <span class="c"># case 2a</span>
        
        <span class="c"># In this case other contains only Coord elements from self_expanded.</span>
        <span class="c"># return function that takes ndarray A consistent with self and returns A expanded to other (yielding array of same dimension as other) and then transposed to be consistent with other.</span>
        <span class="c"># this should yield the same result as using other as argument for expand</span>
        <span class="k">return</span> <span class="k">lambda</span> <span class="n">A</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">self_expanded</span><span class="p">),</span><span class="n">pm</span><span class="p">)</span>

      <span class="k">else</span><span class="p">:</span>
        <span class="n">pm</span> <span class="o">=</span> <span class="n">self_expanded</span><span class="o">.</span><span class="n">eq_perm</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">verbose</span> <span class="o">=</span> <span class="bp">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">pm</span><span class="p">:</span>
          <span class="c"># case 2b</span>

          <span class="c"># line up the equivalent Coord elements in the same order for interpolation.</span>
          <span class="k">return</span> <span class="k">lambda</span> <span class="n">A</span><span class="p">:</span> <span class="p">(</span><span class="n">self_expanded</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">pm</span><span class="p">))</span><span class="o">.</span><span class="n">_smart_interp</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">self_expanded</span><span class="p">),</span><span class="n">pm</span><span class="p">),</span><span class="n">other</span><span class="p">,</span> <span class="n">method</span> <span class="o">=</span> <span class="n">method</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="c"># case 2c</span>
          <span class="k">print</span> <span class="s">&quot;grids not equivalent&quot;</span>
          <span class="k">return</span>

      <span class="k">return</span> 

    <span class="k">else</span><span class="p">:</span>
<span class="c">#**** CASE 3 ************************</span>

      <span class="c"># This is the case where len(other) &lt; len(self) =&gt; reduce method. This yields a function that slices along the Gr provided in the argument, and a permutation among those axes if they appear in different order in self and other.</span>

<span class="c"># To illustrate this functionality:</span>

<span class="c">#If V is an ndarray consistent with zt*yt*xt</span>
<span class="c"># and we do R = np.array((zt*yt*xt)(yt*xt)(V));R = R.reshape((yt*xt*zt).shape())</span>
<span class="c"># Then We get V back, but transposed onto yt*xt*zt. This is because the index grid L = yt*xt is put first by (zt*yt*xt)(yt*xt)</span>


      <span class="c"># create target_grid of same dimension as self, and with other Coord elements first</span>
      <span class="n">target_grid</span> <span class="o">=</span> <span class="n">other</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">/</span><span class="n">other</span><span class="p">)</span>
      
      <span class="n">pm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">perm</span><span class="p">(</span><span class="n">target_grid</span><span class="p">,</span> <span class="n">verbose</span> <span class="o">=</span> <span class="bp">False</span><span class="p">)</span>      
     
      <span class="c"># Using reduce method. Note that reduce has the arguments the other way around. reduce is called as method of other!</span>
      <span class="k">if</span> <span class="n">pm</span><span class="p">:</span>
        <span class="c"># case 3a</span>
        <span class="k">return</span> <span class="k">lambda</span> <span class="n">A</span><span class="p">:</span> <span class="n">other</span><span class="o">.</span><span class="n">to_slices</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">pm</span><span class="p">),</span><span class="n">target_grid</span><span class="p">)</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="n">pm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eq_perm</span><span class="p">(</span><span class="n">target_grid</span><span class="p">,</span> <span class="n">verbose</span> <span class="o">=</span> <span class="bp">False</span><span class="p">)</span> 
        <span class="k">if</span> <span class="n">pm</span><span class="p">:</span>
          <span class="c"># case 3b</span>
          <span class="k">return</span> <span class="k">lambda</span> <span class="n">A</span><span class="p">:</span> <span class="n">other</span><span class="o">.</span><span class="n">to_slices</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">pm</span><span class="p">))</span><span class="o">.</span><span class="n">_smart_interp</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">pm</span><span class="p">),</span><span class="n">target_grid</span><span class="p">,</span> <span class="n">method</span> <span class="o">=</span> <span class="n">method</span><span class="p">),</span><span class="n">target_grid</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
          <span class="c"># case 3c</span>
          <span class="k">print</span> <span class="s">&#39;Nope&#39;</span>
          <span class="k">return</span>
     
    <span class="k">return</span>
</div>
<div class="viewcode-block" id="Gr.function"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Gr.function">[docs]</a>  <span class="k">def</span> <span class="nf">function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">func</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a Field containing the values of function argument func on the grid points defined in this grid. The Field name is the name of the function.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">vfunc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="n">value</span> <span class="o">=</span> <span class="n">vfunc</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">inflate</span><span class="p">())</span>
 
    <span class="k">return</span> <span class="n">Field</span><span class="p">(</span><span class="n">name</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">func_name</span><span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="p">,</span> <span class="n">grid</span> <span class="o">=</span> <span class="bp">self</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Gr.array_equal"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Gr.array_equal">[docs]</a>  <span class="k">def</span> <span class="nf">array_equal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    grid component-wise test whether the Coord objects contain the same grid point location values. Input another grid.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">()</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">axis</span><span class="p">():</span>
      <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;Error: provide grids defined along same axes.&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">[</span><span class="n">e</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">other</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">e</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>   <span class="p">]</span>
        
</div>
<div class="viewcode-block" id="Gr.axis"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Gr.axis">[docs]</a>  <span class="k">def</span> <span class="nf">axis</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns an AxGr object containing the axis properties of the Coord elements of this grid.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">:</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">,[</span><span class="n">e</span><span class="o">.</span><span class="n">axis</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">])</span>

</div>
<div class="viewcode-block" id="Gr.reverse"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Gr.reverse">[docs]</a>  <span class="k">def</span> <span class="nf">reverse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

    <span class="k">return</span> <span class="n">Gr</span><span class="p">([</span> <span class="bp">self</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-</span><span class="n">i</span> <span class="o">-</span><span class="mi">1</span> <span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>  <span class="p">])</span>

</div>
<div class="viewcode-block" id="Gr.nbytes"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Gr.nbytes">[docs]</a>  <span class="k">def</span> <span class="nf">nbytes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">:</span><span class="n">x</span><span class="o">.</span><span class="n">nbytes</span><span class="o">+</span><span class="n">y</span><span class="o">.</span><span class="n">nbytes</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
</div>
  <span class="k">def</span> <span class="nf">__and__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    self&amp;other</span>
<span class="sd">    Tests whether Gr object contains same values (in attributes) as argument grid. A&amp;B = True when Gr objects A,B contain the same values (but need not be same objects). Corresponds to copy method.</span>
<span class="sd">    &quot;&quot;&quot;</span>


    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
      <span class="n">L</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span><span class="o">&amp;</span><span class="n">other</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">e</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">)]</span>
      <span class="k">return</span> <span class="nb">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="ow">and</span> <span class="n">y</span><span class="p">,</span> <span class="n">L</span><span class="p">)</span>
  
    <span class="k">else</span><span class="p">:</span>
      <span class="k">return</span> <span class="bp">False</span> 

<div class="viewcode-block" id="Gr.copy"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Gr.copy">[docs]</a>  <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Creates object with same values. A = B.copy() yields A&amp;B = True, see __and__ method.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="n">Gr</span><span class="p">([</span><span class="n">e</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">])</span>


<span class="c"># ------------------------------------------</span>
<span class="c"># Lower level methods:</span>
</div>
<div class="viewcode-block" id="Gr.to_slices"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Gr.to_slices">[docs]</a>  <span class="k">def</span> <span class="nf">to_slices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">A</span><span class="p">,</span><span class="n">other</span><span class="p">):</span>        
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    yields a list of slices along the coords defined in self. e.g.</span>
<span class="sd">    zt(zt*yt*xt) = [A[0,:,:],A[1,:,:],...] where A.shape is (zt*yt*xt).shape()</span>

<span class="sd">    Expects self coords to be subset of other, and appearing in same order in both.</span>
<span class="sd">    other must appear in the left side of self (i.e. self is self*(other/self)  ).</span>
<span class="sd">    For instance, zt*yt(zt*yt*xt) is valid,  yt*xt(zt*yt*xt) and zt(yt*xt) are not.</span>
<span class="sd">    The indexing in the output list (as list of lists) is of opposite order to the Coord elements in self.</span>

<span class="sd">    No checks are done on consistency between A or other or self and other.</span>

<span class="sd">    The opposite of expand. Used by call method of fields on Gr objects of lower dimension that the Field.</span>

<span class="sd">    Inputs: </span>
<span class="sd">    A		ndarray of shape other.shape()</span>
<span class="sd">    other	another larger Gr (grid) object containing self</span>

<span class="sd">    Outputs:</span>
<span class="sd">    A list of nparrays being slices of input A along the self Gr.</span>

<span class="sd">    Note that argument is longer than self. This is opposite to __call__ method, where a longer self leads to a reduction.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c"># This method works with recursion. If len(self)&gt;1, a list is built using this method on the smaller elements and indexing by the first dimension.</span>
    <span class="c"># if B = self.to_slices(A,other) and A is an array, then array(B) has the same shape and values as A.</span>
    <span class="c"># calling say (zt*yt).to_slices(A,zt*yt*xt) yields a list of lists. Each of those lists then contains a 1D array.</span>



<span class="c"># the following code is made slightly difficult due to recursion:</span>
<span class="c">#    if (force == False) and ( other != self*(other/self) ):</span>
<span class="c">#      warnings.warn(&#39;Calling Gr %s on Gr %s. other must equal self*(other/self).&#39;%(str(self),str(other) ) )</span>

 
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
      <span class="c"># single Coord Gr called on Gr. Endpoint of recursion.</span>
    
      <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span> 
      <span class="n">coord</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
      <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="nb">list</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">coord</span><span class="p">)):</span>
        <span class="c"># Numpy note: the colon here in A can represent several dimensions.</span>
          <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>   
       
      <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">coord</span><span class="p">)):</span>
  
        <span class="c"># Numpy note: the colon here in A can represent several dimensions.</span>
          <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,:])</span>   

      <span class="k">return</span> <span class="n">result</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="c"># multiple coord Gr called on Gr. Recursion until single coord Gr called on Gr.</span>

      <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
      <span class="n">subself</span> <span class="o">=</span> <span class="n">Gr</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

      <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">subself</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">coord</span> <span class="o">=</span> <span class="n">subself</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">subself</span> <span class="o">=</span> <span class="n">subself</span><span class="o">/</span><span class="p">(</span><span class="n">coord</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="nb">list</span><span class="p">):</span>
          <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">coord</span><span class="p">)):</span>
            <span class="n">result</span> <span class="o">+=</span> <span class="p">(</span><span class="n">subself</span><span class="o">.</span><span class="n">to_slices</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">other</span><span class="p">))</span>

        <span class="k">else</span><span class="p">:</span>
          <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">coord</span><span class="p">)):</span>
            <span class="n">result</span> <span class="o">+=</span> <span class="p">(</span><span class="n">subself</span><span class="o">.</span><span class="n">to_slices</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,:],</span><span class="n">other</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">result</span>
        

</div>
<div class="viewcode-block" id="Gr.expand"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Gr.expand">[docs]</a>  <span class="k">def</span> <span class="nf">expand</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">A</span><span class="p">,</span><span class="n">other</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Adds dimensions specified in Gr other at the beginning of array A</span>

<span class="sd">    input: ndarray of shape consistent with self, Gr other</span>
<span class="sd">    output: an ndarray of shape (other/self)*self containing identical copies of A along other/self</span>

<span class="sd">    Example.</span>

<span class="sd">    SAT = P[&#39;DPO&#39;][&#39;A_sat&#39;]</span>
<span class="sd">    SAT.shape is (100,100)</span>
<span class="sd">    W=SAT.gr.expand(SAT[:],depth**2)</span>
<span class="sd">    W.shape is (19,100,100)</span>
<span class="sd">    W contains 19 identical copies (slices) of SAT[:] </span>

<span class="sd">    Note that the other grid is appended on the left side.</span>

<span class="sd">    Example 2.</span>

<span class="sd">    (zt*yt*xt).shape() is (46, 110, 200)</span>

<span class="sd">    A = np.ones((xt**2).shape())</span>

<span class="sd">    K=(xt**2).expand(A,zt*yu*xt  )</span>
<span class="sd">    K.shape is (46, 110, 200)</span>

<span class="sd">    K=(xt**2).expand(A,zt*xt*yt  )</span>
<span class="sd">    K.shape is (46, 110, 200)</span>

<span class="sd">    Warning: method requires Gr argument, do not use coord argument. Instead, for a single coord (e.g.) xt, use xt**2.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c"># only use those coord elements that are in the other gr but not the self gr.</span>
    <span class="n">new_coords</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">other</span><span class="o">/</span><span class="bp">self</span><span class="p">)</span>
    <span class="n">new_coords</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">new_coords</span><span class="p">:</span>
      <span class="c"># initialize L for each coord with the A from argument, or just built below</span>
      <span class="n">L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">A</span><span class="p">],)</span>
      <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">coord</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="c"># grow the dimensions with identical copies of A</span>
        <span class="n">L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">L</span><span class="p">,[</span><span class="n">A</span><span class="p">,],</span><span class="mi">0</span><span class="p">)</span>
      <span class="n">A</span> <span class="o">=</span> <span class="n">L</span> 

    <span class="k">return</span> <span class="n">L</span>



</div>
<div class="viewcode-block" id="Gr.inflate"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Gr.inflate">[docs]</a>  <span class="k">def</span> <span class="nf">inflate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span> <span class="o">=</span> <span class="s">&#39;array&#39;</span><span class="p">,</span> <span class="n">force</span> <span class="o">=</span> <span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd"> </span>
<span class="sd">    Input:</span>
<span class="sd">    type = output type. -&#39;array&#39; in arguments will return a list of arrays. -&#39;Field&#39; in arguments will return a list of fields.</span>

<span class="sd">    Output: </span>
<span class="sd">    A list of arrays or fields of the dimension of the grid being called.</span>
<span class="sd">    Each element in the list corresponds to a Coord object in the called grid, where the array equals the content of the Coord along the array index corresponding to that Coord, and is constant otherwise.</span>


<span class="sd">    For example, a grid defined by (yt,xt) (equal to yt*xt) yields [YT,XT] where YT = yt(yt*xt) and XT = XT(yt*xt). We refer to XT as the inflated version of xt. Here, the Coord object has been called on the grid object: this yields an array defined on the argument grid and constant in all Coord axes other than the calling Coord. The array equals the value of the calling Coord object along that axis.</span>


<span class="sd">    Cached for performance. Refresh with force = True.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span>  <span class="ow">not</span><span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s">&#39;inflated&#39;</span><span class="p">))</span> <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">inflated</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">force</span> <span class="o">==</span> <span class="bp">True</span><span class="p">):</span>
      <span class="c"># compute values and store as arrays.</span>
        
        <span class="c"># This yields a list of arrays, corresponding to the inflated Coord objects.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inflated</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">value</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">]</span>
        
    <span class="k">if</span> <span class="nb">type</span> <span class="o">==</span> <span class="s">&#39;array&#39;</span><span class="p">:</span>
      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">inflated</span>
    <span class="k">elif</span> <span class="nb">type</span> <span class="o">==</span><span class="s">&#39;Field&#39;</span><span class="p">:</span>
      <span class="k">return</span> <span class="p">[</span><span class="n">Field</span><span class="p">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">&#39;inflated_&#39;</span><span class="o">+</span><span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="p">,</span><span class="n">value</span> <span class="o">=</span> <span class="n">e</span><span class="p">,</span> <span class="n">grid</span> <span class="o">=</span> <span class="bp">self</span> <span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inflated</span> <span class="p">)</span> <span class="p">]</span>

</div>
  <span class="k">def</span> <span class="nf">_smart_interp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">A</span><span class="p">,</span><span class="n">other</span><span class="p">,</span> <span class="n">method</span> <span class="o">=</span> <span class="s">&#39;linear&#39;</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Inputs: an array A of the shape corresponding to self.</span>
<span class="sd">            a destination grid.</span>

<span class="sd">    Outputs: an array containing A interpolated from the self grid to the destination grid.</span>


<span class="sd">    Smart interpolation of array A, using griddata interpolation only along Coord axes that are not equal (but must be equivalent).</span>
<span class="sd">    !!!Arguments must be in the right order: order(left) = order(right)!!!</span>

<span class="sd">  </span>

<span class="sd">    &quot;&quot;&quot;</span>
<span class="c"># belongs to grid object.</span>

<span class="c"># it is the left element. Coord elements of self and other (grids) may be up to equivalence, but need to be in same order. The common (equal) elements will be stored in L</span>


    <span class="n">L</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">it</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="k">if</span> <span class="n">it</span> <span class="o">==</span> <span class="n">other</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
        <span class="n">L</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">it</span><span class="o">^</span><span class="n">other</span><span class="p">[</span><span class="n">i</span><span class="p">]):</span>
          <span class="k">print</span> <span class="s">&quot;order/ equivalence wrong, aborting.&quot;</span>
          <span class="k">return</span>

    <span class="k">if</span> <span class="n">L</span><span class="p">:</span>
      <span class="c"># In this case, the source and destination grid have Coord elements in common. This means we need to interpolate only along the axes they do not have in common.</span>

      <span class="c"># check first whether source and destination grids are equal, in which case we can simply return A.</span>
      <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">L</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">A</span>

      <span class="c"># In this case, source and dest grids are not equal, and contain both equal and equivalent-only Coord elements:</span>
      <span class="n">L</span> <span class="o">=</span> <span class="n">Gr</span><span class="p">(</span><span class="n">L</span><span class="p">);</span>
      
      <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c"># Take slices into a list</span>
      <span class="n">B</span><span class="o">=</span><span class="bp">self</span><span class="p">(</span><span class="n">L</span><span class="p">)(</span><span class="n">A</span><span class="p">)</span>      
  
<span class="c">#    B is a (often long) list containing the slices to be interpolated.</span>
<span class="c"># array(B) will yield shape (len(coord1)*len(coord2)*...  , shape(array)) for coordi in L and array the slices to be interpolated</span>
<span class="c"># This should be reshaped to list(L.shape()) + shape(array)</span>
<span class="c"># where shape(array) = (self/L).shape()</span>

      <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">b</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">B</span><span class="p">):</span>
      <span class="c"># perform interpolation on array b from self/L to other/L on each slice.</span>
        <span class="n">srcgrid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">/</span><span class="n">L</span>
        <span class="n">destgrid</span> <span class="o">=</span> <span class="n">other</span><span class="o">/</span><span class="n">L</span>

        <span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">srcgrid</span><span class="o">.</span><span class="n">_interp</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">destgrid</span><span class="p">)</span>
     
<span class="c"># B has now been interpolated.</span>
      <span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>

<span class="c"># some commented out diagnostic prints</span>
<span class="c">#      print L</span>
<span class="c">#      print self/L</span>

<span class="c">#      print list(L.shape())</span>
<span class="c">#      print list((self/L).shape())</span>

<span class="c">#      print B.shape</span>

      <span class="n">B</span> <span class="o">=</span> <span class="n">B</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">shape</span><span class="p">())</span> <span class="o">+</span> <span class="nb">list</span><span class="p">((</span><span class="n">other</span><span class="o">/</span><span class="n">L</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span><span class="p">())</span> <span class="p">)</span>

      <span class="n">pm</span> <span class="o">=</span> <span class="p">(</span><span class="n">L</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">/</span><span class="n">L</span><span class="p">))</span><span class="o">.</span><span class="n">perm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verbose</span> <span class="o">=</span> <span class="bp">False</span><span class="p">)</span>
      <span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">B</span><span class="p">,</span><span class="n">pm</span><span class="p">)</span>

      <span class="k">return</span> <span class="n">B</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_interp</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">other</span><span class="p">,</span> <span class="n">method</span> <span class="o">=</span> <span class="n">method</span><span class="p">)</span>

<span class="c"># methods belong to Gr </span>

  <span class="k">def</span> <span class="nf">_interp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">A</span><span class="p">,</span><span class="n">other</span><span class="p">,</span> <span class="n">method</span> <span class="o">=</span> <span class="s">&#39;linear&#39;</span><span class="p">):</span>


<span class="c"># it is assumed that self^other and that the shape of array A corresponds to the lenghts of the Coord elements of self (and therefore other).</span>
    <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="bp">self</span><span class="o">^</span><span class="n">other</span><span class="p">):</span>
      <span class="k">print</span> <span class="s">&#39;Arguments not equivalent. Use equivalent grids.&#39;</span>
      <span class="k">return</span>
 
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
    
      <span class="n">L</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">][:]</span>
      <span class="n">R</span> <span class="o">=</span> <span class="n">other</span><span class="p">[</span><span class="mi">0</span><span class="p">][:]</span>

      <span class="k">if</span> <span class="n">L</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">&lt;</span><span class="n">L</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
        <span class="c"># in case it&#39;s a negative scale, as in depth</span>
        <span class="n">L</span> <span class="o">=</span> <span class="o">-</span><span class="n">L</span>
        <span class="n">R</span> <span class="o">=</span> <span class="o">-</span><span class="n">R</span>
       
      <span class="n">IA</span> <span class="o">=</span> <span class="n">griddata</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">A</span><span class="p">,</span><span class="n">R</span><span class="p">,</span> <span class="n">method</span> <span class="o">=</span> <span class="n">method</span><span class="p">)</span>
      
    
      <span class="k">return</span> <span class="n">IA</span>
     
    <span class="k">else</span><span class="p">:</span>
  
      <span class="n">L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span> <span class="n">e</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">inflate</span><span class="p">()</span> <span class="p">])</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
      <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span> <span class="n">e</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">inflate</span><span class="p">()</span> <span class="p">])</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>  

      <span class="n">IA</span> <span class="o">=</span> <span class="n">griddata</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">A</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span><span class="n">R</span><span class="p">,</span> <span class="n">method</span> <span class="o">=</span> <span class="n">method</span><span class="p">)</span>
      <span class="n">IA</span><span class="o">=</span><span class="n">IA</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">shape</span><span class="p">())</span>
    
      <span class="k">return</span> <span class="n">IA</span>


  <span class="k">def</span> <span class="nf">__div__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Division of grids. E.g. xt*yt*zt/yt = xt*zt</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">Coord</span><span class="p">):</span>
      <span class="n">other</span> <span class="o">=</span> <span class="n">Gr</span><span class="p">((</span><span class="n">other</span><span class="p">,))</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">Ax</span><span class="p">):</span>
      <span class="n">other</span> <span class="o">=</span> <span class="n">AxGr</span><span class="p">((</span><span class="n">other</span><span class="p">,))</span>


    <span class="n">result</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
      <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">eq_in</span><span class="p">(</span><span class="n">it</span><span class="p">):</span>
        <span class="n">result</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Gr</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>


  <span class="k">def</span> <span class="nf">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Multiplication of grids.</span>
<span class="sd">    At the moment, xu*zt*xt*yt = (xu,zt,yt,) whereas xu*(zt*xt*yt) = (zt,xu,yt,)</span>

<span class="sd">    Multiplication can take other arguments than just grids. If a Field is provided as right multiplicant, the Field is summed over the left multiplicant grid, weighted with grid cell widths (the equivalence of integration over the grid space). If the right multiplicant is a Coord object, it is converted to a single-element grid (Gr) object before multiplication. </span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
      <span class="c"># multiplication with an array yields a Field if the sizes match.</span>
      <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">()</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Field</span><span class="p">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">&#39;&#39;</span><span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="n">other</span><span class="p">,</span> <span class="n">grid</span> <span class="o">=</span> <span class="bp">self</span><span class="p">)</span>
      <span class="k">else</span><span class="p">:</span> 
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;Gr shape error </span><span class="si">%s</span><span class="s">*</span><span class="si">%s</span><span class="s"> with Gr </span><span class="si">%s</span><span class="s">: provide correct shape np array.&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span> <span class="p">)</span>
        <span class="k">return</span>   
 
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">Field</span><span class="p">):</span>

      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">vsum</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>


    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">Coord</span><span class="p">):</span>
      <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s">&#39;scalar&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">eq_in</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
          <span class="k">return</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="k">return</span> <span class="n">Gr</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="n">other</span><span class="p">]</span> <span class="p">)</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">VField</span><span class="p">):</span>
      <span class="c"># multiplication of grid object with vector Field.</span>
      <span class="c"># this commutes:</span>
      <span class="k">return</span> <span class="n">other</span><span class="o">*</span><span class="bp">self</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">Ax</span><span class="p">):</span>
      <span class="c"># multiplication between Gr and Ax objects is commutative</span>
      <span class="k">return</span> <span class="n">other</span><span class="o">*</span><span class="bp">self</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">Gr</span><span class="p">):</span>

      <span class="k">return</span> <span class="nb">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">:</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span> <span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">other</span><span class="p">))</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">AxGr</span><span class="p">):</span>
      <span class="c"># --&gt; multiplication between Gr and AxGr objects DOES NOT commute: in agreement with general rules, result retains Coord element order of left multiplicant.</span>
      
      <span class="n">L</span> <span class="o">=</span> <span class="p">[]</span>

      <span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">eq_in</span><span class="p">(</span><span class="n">it</span><span class="p">):</span>
          <span class="n">L</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>

      <span class="k">return</span> <span class="n">Gr</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>    


    <span class="k">else</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;Gr type error </span><span class="si">%s</span><span class="s">*</span><span class="si">%s</span><span class="s"> with Gr </span><span class="si">%s</span><span class="s"> (grid): provide Field, Gr or Coord object or np array as right multiplicant.&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span> <span class="p">)</span>


<span class="c"># belongs to grid </span>
<div class="viewcode-block" id="Gr.strict_equiv"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Gr.strict_equiv">[docs]</a>  <span class="k">def</span> <span class="nf">strict_equiv</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Tests whether two Gr objects have equivalent Coord elements at each position.</span>
<span class="sd">    This is a stricter test than grid (Gr object) equivalence testing via gr1^gr2, which only tests whether both grids describe the same space (elements equivalent up to a permutation).</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
      
      <span class="n">RO</span> <span class="o">=</span> <span class="bp">True</span>      
      <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">it</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">RO</span> <span class="o">*=</span> <span class="p">(</span><span class="n">it</span><span class="o">^</span><span class="n">other</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
      <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="n">RO</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">return</span> <span class="bp">False</span>

</div>
  <span class="k">def</span> <span class="nf">__xor__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Checks equivalence between grids, where grids are equivalent if they define the same physical subspace, based on the equivalence definition for Coord classes. In other words, checks whether the individual Coord elements of the two grid (Gr object) arguments are equivalent up to a permutation. A stricter version of this test is strict_equiv, which allows no permutation.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
      
      <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">eq_perm</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">True</span>
      <span class="k">return</span> <span class="bp">False</span>

    <span class="k">else</span><span class="p">:</span>
      <span class="k">return</span> <span class="bp">False</span>


<div class="viewcode-block" id="Gr.eq_in"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Gr.eq_in">[docs]</a>  <span class="k">def</span> <span class="nf">eq_in</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">crd</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
      <span class="k">if</span> <span class="n">crd</span><span class="o">^</span><span class="n">i</span><span class="p">:</span> <span class="k">return</span> <span class="bp">True</span>
    <span class="k">return</span> <span class="bp">False</span>
</div>
<div class="viewcode-block" id="Gr.eq_index"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Gr.eq_index">[docs]</a>  <span class="k">def</span> <span class="nf">eq_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">crd</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="k">if</span> <span class="n">crd</span><span class="o">^</span><span class="n">v</span><span class="p">:</span> <span class="k">return</span> <span class="n">i</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
</div>
<div class="viewcode-block" id="Gr.shuffle"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Gr.shuffle">[docs]</a>  <span class="k">def</span> <span class="nf">shuffle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">permutation</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Gr method that rearranges the order of the elements of this grid Gr object via permutation arrgument. E.g.</span>

<span class="sd">    g1 = latitude*depth</span>
<span class="sd">    g1.shuffle( (1,0) ) is (depth, latitude)</span>

<span class="sd">    See also perm method of Gr.</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">Gr</span><span class="p">((</span><span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">permutation</span><span class="p">))</span>
    
    

</div>
<div class="viewcode-block" id="Gr.perm"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Gr.perm">[docs]</a>  <span class="k">def</span> <span class="nf">perm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span><span class="n">verbose</span> <span class="o">=</span> <span class="bp">False</span><span class="p">):</span>     
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    yields permutation of axes going from grid self to grid other.</span>
<span class="sd">    E.g. for grids gr1 and gr2, g2 = g1.shuffle( g1.perm(g2) )</span>

<span class="sd">    Returns None if no permutation exists.</span>

<span class="sd">    See also shuffle.</span>

<span class="sd">    &quot;&quot;&quot;</span>  
    <span class="k">return</span> <span class="n">find_perm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">,</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Gr.eq_perm"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Gr.eq_perm">[docs]</a>  <span class="k">def</span> <span class="nf">eq_perm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">verbose</span> <span class="o">=</span> <span class="bp">True</span><span class="p">):</span>      
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    yields permutation of axes going from grid self to grid other, where equivalent axes are treated as identical. </span>

<span class="sd">    See also perm.</span>
<span class="sd">    &quot;&quot;&quot;</span>  

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
      <span class="n">perm</span> <span class="o">=</span> <span class="p">[]</span>
      <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">other</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">eq_in</span><span class="p">(</span><span class="n">r</span><span class="p">):</span>
          <span class="n">perm</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eq_index</span><span class="p">(</span><span class="n">r</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span> <span class="s">&#39;Warning from eq_perm (often benign): inputs not permutable, returning None.&#39;</span><span class="p">)</span>
          <span class="k">return</span>

    <span class="k">else</span><span class="p">:</span>
      <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="k">print</span> <span class="s">&quot;Message from eq_perm: inputs must be of equal length.&quot;</span>
      <span class="k">return</span> 
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">perm</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Gr.shape"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Gr.shape">[docs]</a>  <span class="k">def</span> <span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">sh</span> <span class="o">=</span> <span class="p">[];</span>

    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
      <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="p">[:],</span><span class="nb">str</span><span class="p">))</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="p">[:],</span><span class="nb">unicode</span><span class="p">)):</span>
        <span class="n">sh</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="n">sh</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">sh</span><span class="p">)</span>
 
</div>
<div class="viewcode-block" id="Gr.dual"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Gr.dual">[docs]</a>  <span class="k">def</span> <span class="nf">dual</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Method of Gr object that returns a grid made up of the dual Coord elements of this Gr object.</span>
<span class="sd">      &quot;&quot;&quot;</span>
      <span class="n">gr_dual</span> <span class="o">=</span> <span class="n">Coord</span><span class="p">(</span><span class="s">&#39;scalar&#39;</span><span class="p">)</span>
      <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
        <span class="n">gr_dual</span> <span class="o">*=</span> <span class="n">e</span><span class="o">.</span><span class="n">dual</span>
      <span class="k">return</span> <span class="n">gr_dual</span>
</div>
<div class="viewcode-block" id="Gr.ones"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Gr.ones">[docs]</a>  <span class="k">def</span> <span class="nf">ones</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

    <span class="k">return</span> <span class="n">Field</span><span class="p">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">&#39;ones&#39;</span><span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">()</span> <span class="p">)</span> <span class="p">,</span><span class="n">grid</span> <span class="o">=</span> <span class="bp">self</span> <span class="p">)</span>

</div>
<div class="viewcode-block" id="Gr.vsum"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Gr.vsum">[docs]</a>  <span class="k">def</span> <span class="nf">vsum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">F</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Method of Gr object. Sum weighted with Coord grid cell widths (integration) over self grid. </span>

<span class="sd">Takes Field argument and returns a Field with grid made up of remaining Coord objects or a float. E.g. if F.gr == (&#39;zt&#39;,&#39;yt&#39;,&#39;xt&#39;), (xt*yt).vsum(F) yields a Field defined on grid (&#39;zt&#39;,).</span>

<span class="sd">    </span>
<span class="sd">    Note that when Coord elements with direction attribute &#39;X&#39; and &#39;Y&#39; both appear in the Gr object, vsum will check whether the &#39;X&#39; Coord appears after the &#39;Y&#39; Coord. If so, they will be interchanged when performing the calculation as otherwise no y-coord is available when the x grid cell width is required. This is a small detail.</span>

<span class="sd">    &quot;&quot;&quot;</span>


    <span class="c"># If X and Y directions both occur in the averaging grid, need to make sure X appears before Y because X-direction Coord grid cell width depends on Y-direction Coord.</span>

    <span class="n">dirs</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span><span class="o">.</span><span class="n">direction</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">]</span>

    <span class="k">if</span> <span class="p">(</span><span class="s">&#39;X&#39;</span> <span class="ow">in</span> <span class="n">dirs</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="s">&#39;Y&#39;</span> <span class="ow">in</span> <span class="n">dirs</span><span class="p">):</span>
      <span class="n">i_X</span> <span class="o">=</span> <span class="n">dirs</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s">&#39;X&#39;</span><span class="p">)</span> 
      <span class="n">i_Y</span> <span class="o">=</span> <span class="n">dirs</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s">&#39;Y&#39;</span><span class="p">)</span>

      <span class="k">if</span> <span class="n">i_X</span> <span class="o">&gt;</span> <span class="n">i_Y</span><span class="p">:</span>
        <span class="n">new_gr</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>      
        <span class="n">tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">i_X</span><span class="p">]</span>
        <span class="n">new_gr</span><span class="p">[</span><span class="n">i_X</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">i_Y</span><span class="p">]</span>
        <span class="n">new_gr</span><span class="p">[</span><span class="n">i_Y</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span>
        <span class="k">del</span> <span class="n">tmp</span>
      
        <span class="k">return</span> <span class="nb">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">:</span> <span class="n">y</span><span class="o">.</span><span class="n">vsum</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="p">[</span><span class="n">new_gr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">vsum</span><span class="p">(</span><span class="n">F</span><span class="p">)]</span> <span class="o">+</span> <span class="n">new_gr</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="p">)</span>


    <span class="c"># Apply Coord vsum method of Coord objects in self to Field argument F, from left to right:</span>
    <span class="k">return</span> <span class="nb">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">:</span> <span class="n">y</span><span class="o">.</span><span class="n">vsum</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="p">[</span><span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">vsum</span><span class="p">(</span><span class="n">F</span><span class="p">)]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span> <span class="p">)</span>
</div>
<div class="viewcode-block" id="Gr.mean"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Gr.mean">[docs]</a>  <span class="k">def</span> <span class="nf">mean</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">F</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Method of Gr object.</span>
<span class="sd">    Determines mean of Field argument F weighted with grid cell width.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">vsum</span><span class="p">(</span><span class="n">F</span><span class="p">)</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">vsum</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">ones</span><span class="p">())</span>

<span class="c"># --&gt; belongs to Gr </span>

</div>
<div class="viewcode-block" id="Gr.der"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Gr.der">[docs]</a>  <span class="k">def</span> <span class="nf">der</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">crd</span><span class="p">,</span><span class="n">F</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Method of grid object. Often the wider context of the grid needs to be known to take the derivative along a Coord, hence a Gr method.</span>

<span class="sd">    Input:</span>
<span class="sd">    crd		Coord object along which to differentiate (e.g. latitude)</span>
<span class="sd">    F		Field object to differentiate (e.g. temperature)</span>


<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">coord_types</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;x_coord&#39;</span><span class="p">:</span><span class="n">XCoord</span><span class="p">,</span><span class="s">&#39;y_coord&#39;</span><span class="p">:</span><span class="n">YCoord</span><span class="p">,</span><span class="s">&#39;z_coord&#39;</span><span class="p">:</span><span class="n">Coord</span><span class="p">}</span>
 
    <span class="k">if</span> <span class="n">crd</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
      <span class="n">C</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_args_coord</span><span class="p">(</span><span class="n">method_name</span> <span class="o">=</span> <span class="s">&#39;der&#39;</span><span class="p">,</span> <span class="n">coord_types</span> <span class="o">=</span> <span class="n">coord_types</span><span class="p">)</span>    
      <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">crd</span><span class="p">)</span>  

      <span class="k">return</span> <span class="n">crd</span><span class="o">.</span><span class="n">der</span><span class="p">(</span><span class="n">F</span><span class="p">,</span><span class="o">*</span><span class="n">C</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

    <span class="k">else</span><span class="p">:</span>

      <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;Error in Gr derivative method der. </span><span class="si">%s</span><span class="s"> must be in grid </span><span class="si">%s</span><span class="s">&#39;</span><span class="p">)</span> <span class="o">%</span> <span class="p">(</span><span class="n">crd</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    </div>
<div class="viewcode-block" id="Gr.vol"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Gr.vol">[docs]</a>  <span class="k">def</span> <span class="nf">vol</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Gr method that determines volumes (areas/ lengths) of grid elements, returns Field.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># Depends on the use of {x,y,z}_coord convention in arguments to d() method of classes derived from Coord  (e.g. XCoord takes y_coord argument).</span>

    <span class="n">coord_types</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;x_coord&#39;</span><span class="p">:</span><span class="n">XCoord</span><span class="p">,</span><span class="s">&#39;y_coord&#39;</span><span class="p">:</span><span class="n">YCoord</span><span class="p">,</span><span class="s">&#39;z_coord&#39;</span><span class="p">:</span><span class="n">Coord</span><span class="p">}</span>

    
    <span class="n">C</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_args_coord</span><span class="p">(</span><span class="n">coord_types</span><span class="p">)</span>

   
    <span class="c"># Use splat operator * to pass coords list on as argument</span>
    <span class="c"># cycle through coords, the list of Coord elements required as arguments for each Coord, </span>

    <span class="k">return</span> <span class="nb">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="p">:</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">,</span> <span class="p">[</span><span class="n">r</span><span class="o">.</span><span class="n">d</span><span class="p">(</span><span class="o">*</span><span class="n">C</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">r</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">)]</span>  <span class="p">)</span>     
  </div>
<div class="viewcode-block" id="Gr.find_args_coord"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Gr.find_args_coord">[docs]</a>  <span class="k">def</span> <span class="nf">find_args_coord</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">coord_types</span><span class="p">,</span> <span class="n">method_name</span> <span class="o">=</span> <span class="s">&#39;d&#39;</span><span class="p">):</span>

    <span class="n">coord_store</span> <span class="o">=</span> <span class="p">{}</span>
<span class="c"># Determine the type of each Coord in self</span>
    <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
      <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">coord_types</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">coord_types</span><span class="p">[</span><span class="n">i</span><span class="p">]):</span>
          <span class="n">coord_store</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span>

    <span class="n">L</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
      <span class="c"># get the Coord-derived objects that need to be passed to each d method of Coord (e.g. xt.d(yt))</span>
      <span class="k">exec</span> <span class="s">&#39;method = r.&#39;</span> <span class="o">+</span> <span class="n">method_name</span>
      <span class="n">coords</span> <span class="o">=</span> <span class="p">[</span><span class="n">coord_store</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">inspect</span><span class="o">.</span><span class="n">getargspec</span><span class="p">(</span><span class="n">method</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">coord_types</span><span class="o">.</span><span class="n">keys</span><span class="p">()]</span>

      <span class="n">L</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>       

    <span class="k">return</span> <span class="n">L</span>

<span class="c"># ---------------- end Gr  ----------------</span>





<span class="c"># -------------- Field  --------------------------</span>


  </div></div>
<div class="viewcode-block" id="Field"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Field">[docs]</a><span class="k">class</span> <span class="nc">Field</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Field  to represent a scalar valued function, also dataset, defined on a grid.</span>

<span class="sd">  The call method allows fields to act as function defined on grid objects.</span>
<span class="sd">  For a 2D scalar corresponding to Field T, say defined on grid yt*xt, T(dy*dx) yields a 2D array of the scalar values.</span>

<span class="sd">  If Field T is naturally defined on grid yt*xt, then T(zt*yt*xt) yields a 3D array b such that b[k,:,:] = T(yt*xt) for all possible k.</span>


<span class="sd">   If g is a Gr (grid) or Coord object, left or right multiplication of a Field  object F with Gr Coord results in the grid-cell width weighted summing of the Field over the coords in the multiplicant g (integration, via g.vsum method), resulting in a smaller dimension Field.</span>

<span class="sd">  If g is a Coord object, g^F yields the derivative of F along g (via g.der method). g|F yields the grid cell width-weight cumulative sum of F over g (primitive, via g.vcumsum).</span>

<span class="sd">  two fields F1, F2 are considered equal, F1&amp;F2 yields True, when their name, value (an numpy array) and Gr (grid) attribute are equal, unless they contain nan values.</span>

<span class="sd">  NOTE: multiplication works a bit different from addition at the moment. Addition will go ahead even when coords in the grids are differently named (or have other non-value attributes differ) as long as the value (the coord points) are the same: then the (left and right) coords are considered equal. Multiplication treats them as different coords in this case.</span>

<span class="sd">  &quot;&quot;&quot;</span>

  <span class="k">global</span> <span class="n">ID</span>

  <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>

  <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">name</span><span class="p">,</span><span class="n">value</span><span class="p">,</span><span class="n">grid</span><span class="p">,</span><span class="n">units</span> <span class="o">=</span> <span class="s">&#39;?&#39;</span><span class="p">,</span><span class="n">direction</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">strict_v</span> <span class="o">=</span> <span class="n">strict_vector</span><span class="p">,</span><span class="n">long_name</span><span class="o">=</span><span class="s">&#39;?&#39;</span><span class="p">,</span><span class="n">metadata</span><span class="o">=</span><span class="p">{}</span> <span class="p">,</span> <span class="n">squeezed_dims</span> <span class="o">=</span><span class="n">Gr</span><span class="p">(</span> <span class="p">()</span>  <span class="p">)):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Initialise a Field. </span>
<span class="sd">    Inputs: </span>

<span class="sd">    name:	the name of the Field (e.g. temperature). Displayed in console</span>
<span class="sd">    value:	the numpy array containing the Field data</span>
<span class="sd">    grid:	the grid Gr object associated with the data</span>
<span class="sd">    units:	data units (if known)</span>
<span class="sd">    direction:	scalar or, if vector Field component, axis direction (e.g. X)</span>
<span class="sd">    strict_v:	if True (default), addition of directional fields leads to vector fields.</span>
<span class="sd">    long_name:	Description of Field, corresponds to long_name Netcdf metadata.</span>

<span class="sd">    These inputs become attributes of the created Field object.</span>

<span class="sd">    &quot;&quot;&quot;</span>


    <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">direction</span><span class="p">):</span>
      <span class="n">direction</span> <span class="o">=</span> <span class="n">ID</span><span class="p">()</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
      <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span><span class="n">Gr</span><span class="p">):</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">shape</span> <span class="o">==</span> <span class="n">value</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
          <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
          <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>
          <span class="bp">self</span><span class="o">.</span><span class="n">gr</span> <span class="o">=</span> <span class="n">grid</span>
          <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">shape</span>
          <span class="bp">self</span><span class="o">.</span><span class="n">units</span> <span class="o">=</span> <span class="n">units</span> 
          <span class="bp">self</span><span class="o">.</span><span class="n">direction</span> <span class="o">=</span> <span class="n">direction</span> 
          <span class="bp">self</span><span class="o">.</span><span class="n">strict_v</span> <span class="o">=</span> <span class="n">strict_v</span>
          <span class="bp">self</span><span class="o">.</span><span class="n">long_name</span> <span class="o">=</span> <span class="n">long_name</span>
          <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span> <span class="o">=</span> <span class="n">metadata</span>
          <span class="bp">self</span><span class="o">.</span><span class="n">nbytes</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">nbytes</span>

          <span class="bp">self</span><span class="o">.</span><span class="n">squeezed_dims</span> <span class="o">=</span> <span class="n">squeezed_dims</span>

        <span class="k">else</span><span class="p">:</span>

          <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;Error in Field creation </span><span class="si">%s</span><span class="s"> using grid </span><span class="si">%s</span><span class="s">: value array argument must have same shape as grid argument! Gr shape </span><span class="si">%s</span><span class="s"> while Field shape </span><span class="si">%s</span><span class="s"> &#39;</span> <span class="o">%</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="n">grid</span><span class="p">,</span><span class="nb">str</span><span class="p">(</span><span class="n">shape</span><span class="p">),</span><span class="nb">str</span><span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="p">)</span> <span class="p">)</span>
          <span class="k">return</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;Error in Field creation </span><span class="si">%s</span><span class="s">: argument grid </span><span class="si">%s</span><span class="s"> must be a Gr object!&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">grid</span><span class="p">))</span>
        <span class="k">return</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;Error in Field creation </span><span class="si">%s</span><span class="s">: argument value must be an ndarray!&#39;</span> <span class="o">%</span> <span class="n">name</span> <span class="p">)</span>
      <span class="k">return</span>

  <span class="k">def</span> <span class="nf">__and__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    self&amp;other</span>
<span class="sd">    Tests whether fields contain equal values. At the moment, if the value contains nan, this function will return false.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">name</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">,</span><span class="n">other</span><span class="o">.</span><span class="n">value</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">gr</span><span class="o">&amp;</span><span class="n">other</span><span class="o">.</span><span class="n">gr</span><span class="p">:</span>
      <span class="k">return</span> <span class="bp">True</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">return</span> <span class="bp">False</span>

<div class="viewcode-block" id="Field.copy"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Field.copy">[docs]</a>  <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">grid</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">units</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">direction</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">long_name</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">metadata</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">squeezed_dims</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>

    <span class="n">frame</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">currentframe</span><span class="p">()</span>
    <span class="n">args</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">values</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">getargvalues</span><span class="p">(</span><span class="n">frame</span><span class="p">)</span>

    <span class="c"># aliases used when arguments do not all match class attribute names</span>
    <span class="n">aliases</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;grid&#39;</span><span class="p">:</span><span class="s">&#39;gr&#39;</span><span class="p">}</span>

    <span class="k">del</span> <span class="n">values</span><span class="p">[</span><span class="s">&#39;frame&#39;</span><span class="p">]</span>
    <span class="k">del</span> <span class="n">values</span><span class="p">[</span><span class="s">&#39;self&#39;</span><span class="p">]</span>    

    
    <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">values</span><span class="p">:</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">arg</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="p">):</span>
         
          <span class="k">if</span> <span class="n">values</span><span class="p">[</span><span class="n">arg</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">values</span><span class="p">[</span><span class="n">arg</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="p">[</span><span class="n">arg</span><span class="p">]</span>
      <span class="k">elif</span> <span class="p">(</span><span class="n">arg</span> <span class="ow">in</span> <span class="n">aliases</span><span class="p">):</span>
          <span class="k">if</span> <span class="n">values</span><span class="p">[</span><span class="n">arg</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">values</span><span class="p">[</span><span class="n">arg</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="p">[</span><span class="n">aliases</span><span class="p">[</span><span class="n">arg</span><span class="p">]]</span>

      <span class="k">else</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span> <span class="s">&#39;Warning: arg </span><span class="si">%s</span><span class="s"> is not an object attribute.&#39;</span> <span class="o">%</span><span class="n">arg</span> <span class="p">)</span>
   
    <span class="c"># In case class are derived from the Field class (as opposed to return Field(**values) here):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">(</span><span class="o">**</span><span class="n">values</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="Field.cdf_insert"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Field.cdf_insert">[docs]</a>  <span class="k">def</span> <span class="nf">cdf_insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">file_handle</span><span class="p">,</span> <span class="n">insert_dual</span> <span class="o">=</span> <span class="bp">True</span><span class="p">,</span> <span class="n">force_squeeze</span> <span class="o">=</span> <span class="bp">False</span><span class="p">,</span> <span class="n">miss_default</span> <span class="o">=</span> <span class="mf">9.96921e+36</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Netcdf insert method of Field .</span>

<span class="sd">    Writes Field to already opened file referred to with file_handle argument, along with its Coord objects.</span>

<span class="sd">    &quot;&quot;&quot;</span>


    <span class="c"># handle the squeeze dimensions</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">force_squeeze</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">squeezed_dims</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">unsqueeze</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">cdf_insert</span><span class="p">(</span><span class="n">file_handle</span> <span class="o">=</span> <span class="n">file_handle</span><span class="p">,</span> <span class="n">insert_dual</span> <span class="o">=</span> <span class="n">insert_dual</span><span class="p">)</span>    

    <span class="c"># insert the coords in own grid</span>
    <span class="k">for</span> <span class="n">crd</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">gr</span><span class="p">:</span>
      <span class="k">if</span> <span class="ow">not</span> <span class="n">crd</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="n">file_handle</span><span class="o">.</span><span class="n">variables</span><span class="p">:</span>
        <span class="n">crd</span><span class="o">.</span><span class="n">cdf_insert</span><span class="p">(</span><span class="n">file_handle</span><span class="p">)</span>
    
        <span class="k">if</span> <span class="n">insert_dual</span> <span class="ow">and</span> <span class="p">(</span><span class="n">crd</span><span class="o">.</span><span class="n">dual</span> <span class="o">!=</span> <span class="n">crd</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">crd</span><span class="o">.</span><span class="n">dual</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="n">file_handle</span><span class="o">.</span><span class="n">variables</span><span class="p">):</span>
          <span class="n">crd</span><span class="o">.</span><span class="n">dual</span><span class="o">.</span><span class="n">cdf_insert</span><span class="p">(</span><span class="n">file_handle</span><span class="p">)</span>         

    <span class="c"># This could bloat memory. Redo in a new way.</span>
    <span class="n">value</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">[:])</span>

    <span class="n">miss_val</span> <span class="o">=</span> <span class="n">miss_default</span>
    <span class="k">if</span> <span class="s">&#39;FillValue&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">:</span>
      <span class="n">miss_val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s">&#39;FillValue&#39;</span><span class="p">]</span>
    <span class="k">elif</span> <span class="s">&#39;missing_value&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">:</span>
      <span class="n">miss_val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s">&#39;missing_value&#39;</span><span class="p">]</span>

    <span class="k">try</span><span class="p">:</span>
      <span class="n">value</span><span class="p">[</span>  <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span> <span class="n">value</span>  <span class="p">)</span> <span class="o">==</span> <span class="bp">True</span>   <span class="p">]</span> <span class="o">=</span> <span class="n">miss_val</span>
      
    <span class="k">except</span><span class="p">:</span>
      <span class="k">try</span><span class="p">:</span>
        <span class="n">value</span><span class="p">[</span>  <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span> <span class="n">value</span>  <span class="p">)</span> <span class="o">==</span> <span class="bp">True</span>   <span class="p">]</span> <span class="o">=</span> <span class="n">miss_default</span>

      <span class="k">except</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&#39;Could not set missing value for Field </span><span class="si">%s</span><span class="s">.&#39;</span><span class="o">%</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>




    <span class="c"># Create the actual variable corresponding to Field.value</span>
    <span class="n">var_cdf</span> <span class="o">=</span> <span class="n">file_handle</span><span class="o">.</span><span class="n">createVariable</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">char</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span> <span class="p">[</span><span class="n">crd</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">crd</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">gr</span><span class="p">]</span> <span class="p">)</span>   <span class="p">)</span>
    <span class="n">var_cdf</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">value</span>


    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">:</span>
      <span class="nb">setattr</span><span class="p">(</span><span class="n">var_cdf</span><span class="p">,</span><span class="n">k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> 

    <span class="k">return</span> <span class="n">file_handle</span>

</div>
<div class="viewcode-block" id="Field.write"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Field.write">[docs]</a>  <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">name</span> <span class="o">=</span> <span class="bp">None</span> <span class="p">,</span> <span class="n">history</span> <span class="o">=</span> <span class="s">&#39;Created from Spacegrids &#39;</span> <span class="p">,</span> <span class="n">insert_dual</span> <span class="o">=</span> <span class="bp">True</span><span class="p">,</span> <span class="n">force_squeeze</span> <span class="o">=</span> <span class="bp">False</span> <span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Write method of Field .</span>

<span class="sd">    Creates Netcdf file and writes Field to it, along with its Coord objects.</span>

<span class="sd">    Fields are unsqueezed before saving, along Coord objects of single length to be saved as well (override with force_squeeze = True).</span>

<span class="sd">    If path and name are not specified, the file will be located in the working directory.</span>
<span class="sd">    If only name is specified, the file will be in the wd under that name</span>
<span class="sd">    If path is specified, the wd is replaced by the path in the above 2 scenarios.</span>

<span class="sd">    insert_dual determines whether the edges of a the Coord objects are saved as well (the default).</span>
<span class="sd">    </span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
      <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;.&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&#39;nc&#39;</span><span class="p">,</span><span class="s">&#39;cdf&#39;</span><span class="p">]:</span>
      <span class="n">name</span> <span class="o">=</span> <span class="n">name</span> <span class="o">+</span><span class="s">&#39;.nc&#39;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">path</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
      <span class="n">name</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span> <span class="n">path</span> <span class="p">,</span> <span class="n">name</span> <span class="p">)</span> 
   
    

    <span class="k">print</span> <span class="s">&#39;Writing Field to file </span><span class="si">%s</span><span class="s">&#39;</span><span class="o">%</span><span class="n">name</span>
    <span class="k">try</span><span class="p">:</span>
      <span class="n">file_handle</span> <span class="o">=</span> <span class="n">netcdf_file</span><span class="p">(</span><span class="n">name</span> <span class="p">,</span> <span class="s">&#39;w&#39;</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">IOError</span><span class="p">:</span>
      <span class="k">print</span> <span class="s">&#39;Cannot write &#39;</span><span class="p">,</span> <span class="n">name</span>
    <span class="k">else</span><span class="p">:</span>

      <span class="n">file_handle</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cdf_insert</span><span class="p">(</span><span class="n">file_handle</span><span class="p">,</span> <span class="n">insert_dual</span> <span class="o">=</span> <span class="n">insert_dual</span> <span class="p">,</span> <span class="n">force_squeeze</span> <span class="o">=</span> <span class="n">force_squeeze</span><span class="p">)</span>

      <span class="n">file_handle</span><span class="o">.</span><span class="n">history</span> <span class="o">=</span> <span class="n">history</span> <span class="o">+</span> <span class="s">&#39;</span><span class="si">%s</span><span class="s">&#39;</span><span class="o">%</span><span class="nb">str</span><span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">())</span>
 
<span class="c">#    var_cdf.units = self.units</span>

      <span class="n">file_handle</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Field.cat"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Field.cat">[docs]</a>  <span class="k">def</span> <span class="nf">cat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">,</span><span class="n">ax</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">name_suffix</span> <span class="o">=</span> <span class="s">&#39;_cat&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Concatenate with another Field along axis ax. If ax is None, concatenation takes place along the first encountered common axis with non-equal values.</span>
<span class="sd">    Grids must be orient along same axes and in same axis order.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c"># if no Ax object is given, an Ax is chosen where the grid Coord elements are not array equal.</span>

<span class="c">#    if len(self.gr) != len(other.gr):</span>
<span class="c">#      raise Exception(&#39;Error: provide grids of equal dimension.&#39;)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span><span class="n">Coord</span><span class="p">):</span>
      <span class="n">ax</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">axis</span>

    <span class="n">self_axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gr</span><span class="o">.</span><span class="n">axis</span><span class="p">()</span>

<span class="c">#    if not reduce(lambda x,y:x and y, [e^other[i] for i,e in enumerate(other)]):</span>
    <span class="k">if</span> <span class="n">self_axis</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">gr</span><span class="o">.</span><span class="n">axis</span><span class="p">():</span>
      <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;Error: provide fields defined on the same grid directions.&#39;</span><span class="p">)</span>


    <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
      
      <span class="n">i_ax</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gr</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">gr</span><span class="p">))</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
      <span class="n">ax</span> <span class="o">=</span> <span class="n">self_axis</span><span class="p">[</span><span class="n">i_ax</span><span class="p">]</span>
    
    <span class="n">cat_coord_self</span> <span class="o">=</span> <span class="n">ax</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">gr</span>
    
    <span class="k">if</span> <span class="n">cat_coord_self</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
      <span class="c"># in this case concat is done along an axis not in the self grid</span>
 
      <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;Axis not in grid.&#39;</span><span class="p">)</span>


    <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gr</span><span class="o">/</span><span class="n">ax</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span><span class="p">()</span> <span class="o">!=</span> <span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">gr</span><span class="o">/</span><span class="n">ax</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span><span class="p">():</span>

      <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;Field concat error </span><span class="si">%s</span><span class="s"> and </span><span class="si">%s</span><span class="s">. Provide pieces of right dimensions. (now </span><span class="si">%s</span><span class="s"> and </span><span class="si">%s</span><span class="s">)&#39;</span><span class="o">%</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span><span class="n">other</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="nb">str</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">gr</span><span class="o">/</span><span class="n">ax</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span><span class="p">())</span>  <span class="p">,</span> <span class="nb">str</span><span class="p">(</span> <span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">gr</span><span class="o">/</span><span class="n">ax</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span><span class="p">())</span>   <span class="p">)</span> <span class="p">)</span>

      <span class="c"># obtain the index of the axis in the grid along which to concatenate.</span>
      <span class="c"># why do we need eq_index here instead of index? because it can be an Ax object.</span>
    <span class="n">ax_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gr</span><span class="o">.</span><span class="n">eq_index</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span>

    <span class="c"># combine the two halves as dictionaries of slices of what is to be the new Coord first</span>
 
    <span class="c"># pick the Coord specified by the ax argument by multiplying the grids: </span>
    <span class="n">left_coord</span> <span class="o">=</span> <span class="p">(</span><span class="n">ax</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">gr</span><span class="p">)</span>
    <span class="n">right_coord</span> <span class="o">=</span> <span class="p">(</span><span class="n">ax</span><span class="o">*</span><span class="n">other</span><span class="o">.</span><span class="n">gr</span><span class="p">)</span>
    <span class="c"># e here is a point in the relevant Coord: </span>
    <span class="n">Dleft</span> <span class="o">=</span> <span class="p">{</span><span class="n">e</span><span class="p">:</span><span class="bp">self</span><span class="p">[</span><span class="n">ax</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span> <span class="n">left_coord</span><span class="p">[:]</span> <span class="p">)</span> <span class="p">}</span>
    <span class="n">Dright</span> <span class="o">=</span> <span class="p">{</span><span class="n">e</span><span class="p">:</span><span class="n">other</span><span class="p">[</span><span class="n">ax</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span>  <span class="nb">enumerate</span><span class="p">(</span> <span class="n">right_coord</span><span class="p">[:]</span> <span class="p">)</span> <span class="p">}</span>

    <span class="c"># if one or both coords have no strings attribute set, don&#39;t give the new Coord a string attribute either.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">left_coord</span><span class="o">.</span><span class="n">strings</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">right_coord</span><span class="o">.</span><span class="n">strings</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">):</span>
      <span class="n">stringsleft</span> <span class="o">=</span> <span class="p">{</span><span class="n">e</span><span class="p">:</span><span class="n">left_coord</span><span class="o">.</span><span class="n">strings</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span> <span class="n">left_coord</span><span class="p">[:]</span> <span class="p">)</span> <span class="p">}</span>    
      <span class="n">stringsright</span> <span class="o">=</span> <span class="p">{</span><span class="n">e</span><span class="p">:</span><span class="n">right_coord</span><span class="o">.</span><span class="n">strings</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span> <span class="n">right_coord</span><span class="p">[:]</span> <span class="p">)</span> <span class="p">}</span>    
      <span class="n">stringscomb</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">stringsleft</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="o">+</span> <span class="n">stringsright</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>

      <span class="n">stringscomb</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="n">Dcomb</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">Dleft</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="o">+</span> <span class="n">Dright</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="p">)</span>

      <span class="c"># each unravelled piece needs to have the right shape for np concatenation.</span>
    <span class="n">piece_shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">piece_shape</span><span class="p">[</span><span class="n">ax_index</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

      <span class="c"># use combined keys to construct ordered values of new concatenated Coord object.</span>
    <span class="n">cat_coord_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">Dcomb</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="n">cat_coord_value</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>

      <span class="c"># create the new concatenated Coord object using the combined ordered sequence of values.</span>
    <span class="k">if</span> <span class="n">stringscomb</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
      <span class="n">new_strings</span> <span class="o">=</span> <span class="p">[</span><span class="n">stringscomb</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">cat_coord_value</span><span class="p">]</span>

      <span class="n">new_coord</span> <span class="o">=</span> <span class="n">cat_coord_self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">name</span> <span class="o">=</span> <span class="n">cat_coord_self</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span><span class="n">name_suffix</span><span class="p">,</span>   <span class="n">value</span> <span class="o">=</span> <span class="n">cat_coord_value</span><span class="p">,</span> <span class="n">strings</span> <span class="o">=</span> <span class="n">new_strings</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
      <span class="n">new_coord</span> <span class="o">=</span> <span class="n">cat_coord_self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">name</span> <span class="o">=</span> <span class="n">cat_coord_self</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span><span class="n">name_suffix</span><span class="p">,</span>   <span class="n">value</span> <span class="o">=</span> <span class="n">cat_coord_value</span><span class="p">,</span> <span class="n">strings</span> <span class="o">=</span> <span class="bp">None</span><span class="p">)</span>



    <span class="n">new_coord</span><span class="o">|</span><span class="n">cat_coord_self</span>
      <span class="c"># construct combined Field values. Reshape is needed for np.concatenate function.</span>
    <span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="n">Dcomb</span><span class="p">[</span><span class="n">k</span><span class="p">][:]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">piece_shape</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">cat_coord_value</span><span class="p">]</span>
   
    <span class="n">new_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">values</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="n">ax_index</span><span class="p">)</span>

      <span class="c"># construct the grid of the combined object by replacing the old partial Coord with the new combined Coord in the self grid. Recall that replacement is done with left multiplication.</span>
    <span class="n">new_grid</span> <span class="o">=</span> <span class="n">new_coord</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">gr</span>
       
<span class="c">#      new_value = new_value.reshape(new_grid.shape())</span>

    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">value</span> <span class="o">=</span> <span class="n">new_value</span><span class="p">,</span><span class="n">grid</span> <span class="o">=</span> <span class="n">new_grid</span> <span class="p">)</span>


</div>
<div class="viewcode-block" id="Field.roll"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Field.roll">[docs]</a>  <span class="k">def</span> <span class="nf">roll</span><span class="p">(</span><span class="n">shift</span><span class="p">,</span> <span class="n">crd</span><span class="p">):</span>

    <span class="k">return</span> <span class="n">roll</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shift</span> <span class="o">=</span> <span class="n">shift</span><span class="p">,</span><span class="n">coord</span> <span class="o">=</span> <span class="n">crd</span><span class="p">)</span>


<span class="c"># belongs to Field </span></div>
  <span class="k">def</span> <span class="nf">__xor__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Tests the equivalence of the grids of two fields.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">gr</span><span class="o">^</span><span class="n">other</span><span class="o">.</span><span class="n">gr</span>


  <span class="k">def</span> <span class="nf">__pow__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">n</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="nb">int</span><span class="p">):</span>
      <span class="k">return</span> <span class="n">Field</span><span class="p">(</span><span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s">&#39;**&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">n</span><span class="p">),</span><span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="o">**</span><span class="n">n</span><span class="p">,</span><span class="n">grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gr</span><span class="p">,</span><span class="n">units</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">units</span> <span class="o">+</span> <span class="s">&#39;^&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">print</span> <span class="s">&#39;Power error: provide integer.&#39;</span>

  <span class="k">def</span> <span class="nf">__neg__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">Field</span><span class="p">(</span><span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span><span class="n">value</span> <span class="o">=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">,</span><span class="n">grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gr</span><span class="p">,</span> <span class="n">units</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">units</span><span class="p">,</span> <span class="n">direction</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">direction</span><span class="p">)</span>

  

  <span class="k">def</span> <span class="nf">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Field addition F + G. Proceeds only when fields are defined on the same grid. To add fields defined on different grids, use something like F + G(F.gr) or other, depending on the space spanned by the grids.</span>
<span class="sd">    If the strict_v attribute of F is set to True (a default), and the direction attributes of F,G differ and are not scalar, addition leads to the formation of a vector Field F*G = (F,G).</span>
<span class="sd">    </span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">L</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span>
    
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">Field</span><span class="p">):</span>
      <span class="n">R</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">value</span>
      <span class="k">if</span> <span class="n">L</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">R</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gr</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">gr</span><span class="p">):</span>
          <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">gr</span><span class="o">.</span><span class="n">same</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">gr</span><span class="p">):</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&#39;grids contain same data points but different other attributes (e.g. name). Proceeding.&#39;</span><span class="p">)</span>

          <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">strict_v</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">direction</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">direction</span><span class="p">:</span>
              <span class="k">return</span> <span class="n">Field</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="n">L</span><span class="o">+</span><span class="n">R</span><span class="p">,</span><span class="n">grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gr</span><span class="p">,</span> <span class="n">units</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">units</span><span class="p">,</span> <span class="n">direction</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">direction</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span> 
              <span class="k">return</span> <span class="bp">self</span><span class="o">*</span><span class="n">other</span>

          <span class="k">else</span><span class="p">:</span>

            <span class="k">return</span> <span class="n">Field</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="n">L</span><span class="o">+</span><span class="n">R</span><span class="p">,</span><span class="n">grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gr</span><span class="p">,</span> <span class="n">units</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">units</span><span class="p">,</span> <span class="n">direction</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">direction</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;Field grid error in </span><span class="si">%s</span><span class="s"> + </span><span class="si">%s</span><span class="s"> with Field </span><span class="si">%s</span><span class="s">: Field grids must be equal. Try F + G(F.gr).&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span> <span class="p">)</span>
          
      <span class="k">else</span><span class="p">:</span>  
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;Field shape error in </span><span class="si">%s</span><span class="s"> + </span><span class="si">%s</span><span class="s"> with Field </span><span class="si">%s</span><span class="s">: shapes must match. Try F + G(F.gr).&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span> <span class="p">)</span>
       

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="nb">int</span><span class="p">):</span>
      <span class="k">return</span> <span class="bp">self</span><span class="o">+</span><span class="nb">float</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="nb">float</span><span class="p">):</span>
      <span class="k">return</span> <span class="n">Field</span><span class="p">(</span><span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span><span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">+</span> <span class="n">other</span><span class="p">,</span><span class="n">grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gr</span><span class="p">,</span> <span class="n">units</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">units</span><span class="p">,</span> <span class="n">direction</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">direction</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;Field type error </span><span class="si">%s</span><span class="s"> + </span><span class="si">%s</span><span class="s"> with Field </span><span class="si">%s</span><span class="s">: right factor must be Field, int or float.&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span> <span class="p">)</span>
        

<span class="c"># --&gt; belongs to Field </span>

  <span class="k">def</span> <span class="nf">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">):</span>
    <span class="n">L</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span>
    
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">Field</span><span class="p">):</span>
      <span class="n">R</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">value</span>
      <span class="k">if</span> <span class="n">L</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">R</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gr</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">gr</span><span class="p">):</span>

          <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">gr</span><span class="o">.</span><span class="n">same</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">gr</span><span class="p">):</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&#39;grids contain same data points but different other attributes (e.g. name). Proceeding.&#39;</span><span class="p">)</span>

          <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">strict_v</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">direction</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">direction</span><span class="p">:</span>

<span class="c"># should these Field creation statements be replaced with self.copy?</span>

              <span class="k">return</span> <span class="n">Field</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="n">L</span> <span class="o">-</span> <span class="n">R</span><span class="p">,</span><span class="n">grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gr</span><span class="p">,</span> <span class="n">units</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">units</span><span class="p">,</span> <span class="n">direction</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">direction</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span> 
              <span class="k">return</span> <span class="bp">self</span><span class="o">*</span><span class="n">other</span>

          <span class="k">else</span><span class="p">:</span>

            <span class="k">return</span> <span class="n">Field</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="n">L</span> <span class="o">-</span> <span class="n">R</span><span class="p">,</span><span class="n">grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gr</span><span class="p">,</span> <span class="n">units</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">units</span><span class="p">,</span> <span class="n">direction</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">direction</span><span class="p">)</span>


        <span class="k">else</span><span class="p">:</span>
          <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;Field grid error in </span><span class="si">%s</span><span class="s">-</span><span class="si">%s</span><span class="s"> with Field </span><span class="si">%s</span><span class="s">: grids must be equal. Try F - G(F.gr) or F(G.gr) - G.&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span> <span class="p">)</span>
          
      <span class="k">else</span><span class="p">:</span>  
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;Field shape error in </span><span class="si">%s</span><span class="s">-</span><span class="si">%s</span><span class="s"> with Field </span><span class="si">%s</span><span class="s">: shapes must match. Try F - G(F.gr) or F(G.gr) - G.&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span>  <span class="p">)</span>
      

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="nb">int</span><span class="p">):</span>
      <span class="k">return</span> <span class="bp">self</span> <span class="o">-</span> <span class="nb">float</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="nb">float</span><span class="p">):</span>
      <span class="k">return</span> <span class="n">Field</span><span class="p">(</span><span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span><span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">-</span> <span class="n">other</span><span class="p">,</span><span class="n">grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gr</span><span class="p">,</span> <span class="n">units</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">units</span><span class="p">,</span> <span class="n">direction</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">direction</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;Field type error in </span><span class="si">%s</span><span class="s"> - </span><span class="si">%s</span><span class="s"> with Field </span><span class="si">%s</span><span class="s">: right factor must be Field, int or float.&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span>  <span class="p">)</span>


  <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
    <span class="k">return</span>



 

  <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">L</span><span class="p">):</span>

    <span class="c">#getitem of Field .</span>
    <span class="c"># returns a numpy array containing the sliced content of self if argument consists only of slice objects.</span>
    <span class="c"># If argument is of form: (crd0,1,crd2,1:) etc for crd0,crd1 Coord objects, slicing will take place along each Coord using the slice object or integer following each crd argument as the slice object. A new Field will be returned and new associated Coord objects and a corresponding grid will be produced for the return Field.</span>

    <span class="c"># The argument may also contain Ax objects X,Y,Z,T. In this case, the argument will be converted to the corresponding Coord object from the Field grid self.gr via multiplication.</span>
    
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="nb">tuple</span><span class="p">):</span>
      <span class="c"># In this case, the argument is expected to be multiple slice objects only or slice objects interspersed with Coord objects.</span>
 
      <span class="n">crds</span> <span class="o">=</span> <span class="p">[]</span>		<span class="c"># holds Coord objects along which to slice</span>
      <span class="n">slices</span> <span class="o">=</span> <span class="p">[]</span>	<span class="c"># holds slice objects</span>
      
      <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">L</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">Coord</span><span class="p">):</span>
          <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">gr</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;Slice Coord argument </span><span class="si">%s</span><span class="s"> not in Field </span><span class="si">%s</span><span class="s"> grid </span><span class="si">%s</span><span class="s">.&#39;</span><span class="o">%</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="bp">self</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">gr</span><span class="p">))</span>

          <span class="n">crds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">Ax</span><span class="p">):</span>
       
          <span class="k">if</span> <span class="n">i</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">gr</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;Slice axis argument </span><span class="si">%s</span><span class="s"> not in Field </span><span class="si">%s</span><span class="s"> grid </span><span class="si">%s</span><span class="s">.&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="bp">self</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">gr</span><span class="p">))</span>
          <span class="k">else</span><span class="p">:</span>
            <span class="n">crds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">gr</span><span class="p">)</span> 
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="nb">int</span><span class="p">)</span>  <span class="o">|</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="nb">slice</span><span class="p">):</span>
          <span class="n">slices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;Non-integer slice axis argument </span><span class="si">%s</span><span class="s"> for Field </span><span class="si">%s</span><span class="s"> not recognised as Ax or Coord object. The Ax/ Coord object might be stale. &#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span> <span class="p">)</span>


      <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">crds</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c"># No Coord objects recorded</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">slices</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
          <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span> <span class="s">&#39;(severe): no slices!&#39;</span><span class="p">,</span> <span class="ne">RuntimeWarning</span> <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="n">L</span><span class="p">]</span>
      <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">crds</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">slices</span><span class="p">):</span>        
        <span class="c"># In this case, we can associate a slice object (or int) to each Coord object in the argument.</span>
        <span class="c"># The order then determines which slice object corresponds to which Coord object.</span>
        <span class="c"># The task is now to slice the Field value appropriately and to create the associated Coord objects.</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">crds</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
          <span class="n">crd</span> <span class="o">=</span> <span class="n">crds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
          <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">crd</span><span class="p">,</span><span class="n">Coord</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;Slice axis not valid. Value crd is: </span><span class="si">%s</span><span class="s"> &#39;</span>  <span class="o">%</span> <span class="n">crd</span><span class="p">)</span>

          <span class="n">slc</span> <span class="o">=</span> <span class="n">slices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
          <span class="n">new_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">slice</span><span class="p">(</span><span class="n">sl_coord</span> <span class="o">=</span> <span class="n">crd</span><span class="p">,</span> <span class="n">slice_obj</span> <span class="o">=</span> <span class="n">slc</span><span class="p">)</span>

          <span class="c"># Create the new sliced Coord object. By default, this yields an equivalent Coord to the original.</span>

          <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">slc</span><span class="p">,</span><span class="nb">int</span><span class="p">):</span>
             <span class="c"># Simple slice case at a certain point along an axis.</span>
            
             <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">value</span> <span class="o">=</span> <span class="n">new_value</span><span class="p">,</span> <span class="n">grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gr</span><span class="o">/</span><span class="n">crd</span><span class="p">)</span>

          <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">slc</span><span class="p">,</span><span class="nb">slice</span><span class="p">):</span>
            <span class="c"># a subset along an axis is taken. New Coord object(s) with the correct value needs to be created.</span>
            <span class="n">new_crd_value</span> <span class="o">=</span> <span class="n">crd</span><span class="p">[</span><span class="n">slc</span><span class="p">]</span>         
            <span class="n">new_crd</span> <span class="o">=</span> <span class="n">crd</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">name</span> <span class="o">=</span> <span class="n">crd</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s">&#39;_sliced&#39;</span><span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="n">new_crd_value</span><span class="p">)</span>

            <span class="n">new_crd</span><span class="o">|</span><span class="n">crd</span>

            <span class="k">if</span> <span class="n">crd</span><span class="o">.</span><span class="n">dual</span> <span class="o">==</span> <span class="n">crd</span><span class="p">:</span>
              <span class="n">new_crd</span><span class="o">.</span><span class="n">dual</span> <span class="o">=</span> <span class="n">new_crd</span>
            <span class="k">else</span><span class="p">:</span>

              <span class="k">if</span> <span class="p">(</span><span class="n">slc</span><span class="o">.</span><span class="n">stop</span> <span class="o">!=</span> <span class="bp">None</span><span class="p">):</span>
                <span class="n">slc_dual</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">slc</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">slc</span><span class="o">.</span><span class="n">stop</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">slc</span><span class="o">.</span><span class="n">step</span><span class="p">)</span>
              <span class="k">else</span><span class="p">:</span>
                <span class="n">slc_dual</span> <span class="o">=</span> <span class="n">slc</span>

              <span class="n">new_crd_dual</span> <span class="o">=</span> <span class="n">crd</span><span class="o">.</span><span class="n">dual</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">name</span> <span class="o">=</span> <span class="n">crd</span><span class="o">.</span><span class="n">dual</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s">&#39;_sliced&#39;</span><span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="n">crd</span><span class="o">.</span><span class="n">dual</span><span class="p">[</span><span class="n">slc_dual</span><span class="p">])</span>
              <span class="n">new_crd_dual</span><span class="o">|</span><span class="n">crd</span><span class="o">.</span><span class="n">dual</span>
              <span class="n">new_crd</span><span class="o">.</span><span class="n">dual</span> <span class="o">=</span> <span class="n">new_crd_dual</span>
              <span class="n">new_crd_dual</span><span class="o">.</span><span class="n">dual</span> <span class="o">=</span> <span class="n">new_crd</span>

            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">value</span> <span class="o">=</span> <span class="n">new_value</span><span class="p">,</span> <span class="n">grid</span> <span class="o">=</span> <span class="n">new_crd</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">gr</span><span class="p">)</span>

          <span class="k">else</span><span class="p">:</span>
            <span class="c"># Input is neither slice object nor int</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;Field slice error in Field </span><span class="si">%s</span><span class="s"> arg </span><span class="si">%s</span><span class="s"> : use slice objects only or Coord objects and slice objects.&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">L</span><span class="p">)</span>  <span class="p">)</span>                


        <span class="k">else</span><span class="p">:</span>
          
          <span class="c"># length of Coord-slice argument pairs is greater than 1.</span>
          <span class="c"># go through arguments recursively.</span>
          <span class="n">F</span> <span class="o">=</span> <span class="bp">self</span>
          <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">crds</span><span class="p">,</span><span class="n">slices</span><span class="p">):</span>
            <span class="n">F</span> <span class="o">=</span> <span class="n">F</span><span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>

          <span class="k">return</span> <span class="n">F</span>
      <span class="k">else</span><span class="p">:</span>
       <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;Field slice error in Field </span><span class="si">%s</span><span class="s"> arg </span><span class="si">%s</span><span class="s"> : use slice objects only or Coord objects and slice objects.&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">L</span><span class="p">)</span>  <span class="p">)</span>         

    <span class="k">else</span><span class="p">:</span>
      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="n">L</span><span class="p">]</span>


  <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">grid</span><span class="p">,</span> <span class="n">method</span> <span class="o">=</span> <span class="s">&#39;linear&#39;</span><span class="p">):</span>

    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">regrid</span><span class="p">(</span><span class="n">grid</span> <span class="o">=</span> <span class="n">grid</span><span class="p">,</span> <span class="n">method</span> <span class="o">=</span> <span class="n">method</span><span class="p">)</span>


<div class="viewcode-block" id="Field.regrid"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Field.regrid">[docs]</a>  <span class="k">def</span> <span class="nf">regrid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">grid</span><span class="p">,</span> <span class="n">method</span> <span class="o">=</span> <span class="s">&#39;linear&#39;</span><span class="p">):</span>

<span class="c"># this method is very important. </span>
<span class="c"># If Field T is naturally defined on grid yt*xt, then T(zt*yt*xt) yields a Field with value a 3D array b such that b[k,:,:] = T(yt*xt) for all possible k.</span>

    <span class="n">value</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gr</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">method</span> <span class="o">=</span> <span class="n">method</span><span class="p">))(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span><span class="nb">list</span><span class="p">):</span>
<span class="c"># in this case the grid argument is a subspace of self.gr so that the grid of the elements is self.gr/grid due to the way self.gr(grid) has been constructed (see call method for grid objects).</span>
      <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
      <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">e</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
        <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Field</span><span class="p">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">&#39;slice_&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">grid</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span> <span class="p">)</span><span class="o">+</span><span class="s">&#39;_&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">,</span><span class="n">value</span> <span class="o">=</span> <span class="n">e</span><span class="p">,</span> <span class="n">grid</span> <span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">gr</span><span class="o">/</span><span class="n">grid</span><span class="p">))</span>
      <span class="k">return</span> <span class="n">result</span>
     
    <span class="k">else</span><span class="p">:</span>
<span class="c"># the element is probably a numpy array. If not, Field init will throw an error.</span>
      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="p">,</span> <span class="n">grid</span> <span class="o">=</span><span class="n">grid</span><span class="p">)</span>
</div>
  <span class="k">def</span> <span class="nf">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    multiplies two Field T1,T2. If T1 is defined on gr1 and T2 on gr2, then T1*T2 is defined on gr1*gr2</span>


<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="nb">int</span><span class="p">):</span>
      <span class="k">return</span> <span class="bp">self</span><span class="o">*</span><span class="nb">float</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
    
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="nb">float</span><span class="p">):</span>
      <span class="k">return</span> <span class="n">Field</span><span class="p">(</span><span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="p">,</span><span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="o">*</span><span class="n">other</span><span class="p">,</span><span class="n">grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gr</span><span class="p">,</span> <span class="n">units</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">units</span> <span class="p">,</span><span class="n">direction</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">direction</span><span class="p">)</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">Gr</span><span class="p">):</span>
      <span class="c"># fields commute with Gr objects</span>
      <span class="k">return</span> <span class="n">other</span><span class="o">*</span><span class="bp">self</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">AxGr</span><span class="p">):</span>
      <span class="c"># fields commute with AxGr objects</span>
      <span class="k">return</span> <span class="n">other</span><span class="o">*</span><span class="bp">self</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">Coord</span><span class="p">)</span> <span class="o">|</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">Ax</span><span class="p">):</span>
<span class="c">#      print &#39;Warning (benign): converting right multiplicant to Gr from Coord object.&#39;</span>
      <span class="k">return</span> <span class="bp">self</span><span class="o">*</span><span class="p">(</span><span class="n">other</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">Field</span><span class="p">):</span>
      <span class="c"># both multiplicants are fields</span>
  
      <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">direction</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">direction</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">direction</span> <span class="o">==</span> <span class="n">ID</span><span class="p">())</span> <span class="o">|</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">direction</span> <span class="o">==</span> <span class="n">ID</span><span class="p">()):</span>
        <span class="c"># in this case, at least one of the multiplicants is a scalar (interacting with all directions), or both multiplicants are along the same direction.</span>

    <span class="c"># Note that this multiplication yields precedence for the order of the left multiplicant (self). E.g. (zt*yt*xt)*(xt*yt) = zt*yt*xt</span>
        <span class="n">common_gr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gr</span><span class="o">*</span><span class="n">other</span><span class="o">.</span><span class="n">gr</span>
 
    <span class="c"># This multiplication inflates the values of self and other (arrays) onto the common grid. </span>
    <span class="c"># In case the grids contain Coord elements that are equivalent but not equal, grid multiplication dictates that common_gr will contain the elements of the left multiplicant (i.e. again a precedence for the left multiplicant). This implies that the right Field will then be interpolated on the left latice</span>
    
        
        <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s">&#39;&#39;</span><span class="p">:</span>
          <span class="n">new_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s">&#39;&#39;</span><span class="p">:</span>
          <span class="n">new_name</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">name</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="n">new_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span><span class="s">&#39;_times_&#39;</span><span class="o">+</span><span class="n">other</span><span class="o">.</span><span class="n">name</span>
 
        <span class="n">new_direction</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">direction</span><span class="o">*</span><span class="n">other</span><span class="o">.</span><span class="n">direction</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">new_direction</span><span class="p">,</span><span class="n">AxGr</span><span class="p">):</span>
          <span class="n">new_direction</span> <span class="o">=</span> <span class="n">new_direction</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">Field</span><span class="p">(</span><span class="n">name</span> <span class="o">=</span> <span class="n">new_name</span> <span class="p">,</span><span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gr</span><span class="p">(</span><span class="n">common_gr</span><span class="p">)(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">)</span><span class="o">*</span><span class="n">other</span><span class="o">.</span><span class="n">gr</span><span class="p">(</span><span class="n">common_gr</span><span class="p">)(</span><span class="n">other</span><span class="o">.</span><span class="n">value</span><span class="p">),</span><span class="n">grid</span> <span class="o">=</span> <span class="n">common_gr</span><span class="p">,</span> <span class="n">units</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">units</span> <span class="o">+</span> <span class="n">other</span><span class="o">.</span><span class="n">units</span><span class="p">,</span> <span class="n">direction</span> <span class="o">=</span> <span class="n">new_direction</span><span class="p">)</span>

      <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">gr</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">gr</span><span class="p">:</span>
          <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">gr</span><span class="o">&amp;</span><span class="n">other</span><span class="o">.</span><span class="n">gr</span><span class="p">:</span>

            <span class="c"># If multiplicants are defined on grids that have the same values but are different objects, a duplicate grid is discovered and housekeeping is done. Duplicate grids commonly arise from earlier slicing.</span>
            <span class="k">print</span> <span class="s">&#39;Duplicate grids. FYI: replacing right gr.&#39;</span>
            <span class="k">del</span> <span class="n">other</span><span class="o">.</span><span class="n">gr</span>
            <span class="n">other</span><span class="o">.</span><span class="n">gr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gr</span>
          <span class="k">else</span><span class="p">:</span>
            <span class="c"># if grids are different and not duplicates, the resulting vectorfield is likely to be ill defined. Creation proceeds nonetheless, but with a warning.</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span> <span class="s">&#39;(severe) VField components defined on different grids.&#39;</span><span class="p">,</span> <span class="ne">RuntimeWarning</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">VField</span><span class="p">((</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">))</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">VField</span><span class="p">):</span>
      <span class="c"># the right multiplicant is a vector Field.</span>

      <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">direction</span> <span class="o">==</span> <span class="n">ID</span><span class="p">():</span>
        <span class="n">new_vfield</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">*</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">other</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">VField</span><span class="p">(</span><span class="n">new_vfield</span><span class="p">)</span>       
        
     
      <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">direction</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">direction</span><span class="p">():</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">direction</span><span class="p">()</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">direction</span><span class="p">)</span>

        <span class="n">new_vfield</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="n">new_vfield</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">*</span><span class="n">new_vfield</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">VField</span><span class="p">(</span><span class="n">new_vfield</span><span class="p">)</span>       

      <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">VField</span><span class="p">([</span><span class="bp">self</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="p">)</span>


    <span class="k">else</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;Field error in </span><span class="si">%s</span><span class="s">*</span><span class="si">%s</span><span class="s"> with Field </span><span class="si">%s</span><span class="s">. Provide Field,Gr or Coord objects or int or double for right multiplicant. Hint: common mistake is when multiplying a Field F and a Coord c, and c appears to be in F.gr, c may be stale: check whether they are identical. If not, update c from Exper Coord stack. &#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span> <span class="p">)</span>
     

<span class="c"># --&gt; belongs to  Field.</span>
  <span class="k">def</span> <span class="nf">__div__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    divides two Field T1,T2. If T1 is defined on gr1 and T2 on gr2, then T1*T2 is defined on gr1*gr2</span>


<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="nb">int</span><span class="p">):</span>
      <span class="k">return</span> <span class="bp">self</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
    
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="nb">float</span><span class="p">):</span>
      <span class="k">return</span> <span class="n">Field</span><span class="p">(</span><span class="n">name</span> <span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="p">,</span><span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="o">/</span><span class="n">other</span><span class="p">,</span><span class="n">grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gr</span><span class="p">,</span> <span class="n">direction</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">direction</span><span class="p">)</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">Gr</span><span class="p">):</span>
      <span class="k">return</span> <span class="n">other</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">AxGr</span><span class="p">)</span> <span class="o">|</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">Ax</span><span class="p">):</span>
      <span class="k">return</span> <span class="bp">self</span><span class="o">/</span><span class="p">(</span><span class="n">other</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">gr</span><span class="p">)</span>
 
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">Coord</span><span class="p">):</span>
<span class="c">#      print &#39;Warning: (benign) converting right multiplicant to Gr from Coord object.&#39;</span>
      <span class="k">return</span> <span class="bp">self</span><span class="o">/</span><span class="p">(</span><span class="n">other</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">Field</span><span class="p">):</span>

      <span class="n">new_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
      <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s">&#39;&#39;</span><span class="p">:</span>
        <span class="n">new_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
      <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s">&#39;&#39;</span><span class="p">:</span>
        <span class="n">new_name</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">name</span>


    <span class="c"># Note that this multiplication yields precedence for the order of the left multiplicant (self). E.g. (zt*yt*xt)*(xt*yt) = zt*yt*xt</span>
      <span class="n">common_gr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gr</span><span class="o">*</span><span class="n">other</span><span class="o">.</span><span class="n">gr</span>
 
    <span class="c"># This multiplication inflates the values of self and other (arrays) onto the common grid. </span>
    <span class="c"># In case the grids contain Coord elements that are equivalent but not equal, grid multiplication dictates that common_gr will contain the elements of the left multiplicant (i.e. again a precedence for the left multiplicant). This implies that the right Field will then be interpolated on the left latice</span>

      <span class="k">return</span> <span class="n">Field</span><span class="p">(</span><span class="n">name</span> <span class="o">=</span> <span class="n">new_name</span> <span class="p">,</span><span class="n">value</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gr</span><span class="p">(</span><span class="n">common_gr</span><span class="p">)(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">))</span><span class="o">/</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">gr</span><span class="p">(</span><span class="n">common_gr</span><span class="p">)(</span><span class="n">other</span><span class="o">.</span><span class="n">value</span><span class="p">)),</span><span class="n">grid</span> <span class="o">=</span> <span class="n">common_gr</span><span class="p">,</span> <span class="n">direction</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">direction</span><span class="p">)</span>


    <span class="k">else</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;Field error in </span><span class="si">%s</span><span class="s">/</span><span class="si">%s</span><span class="s"> with Field </span><span class="si">%s</span><span class="s">. Provide Field,gr or Coord objects or int or double for denominator. (Or check staleness of objects.)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span> <span class="p">)</span>
     

<span class="c"># --&gt; method belongs to Field.</span>
<div class="viewcode-block" id="Field.sum"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Field.sum">[docs]</a>  <span class="k">def</span> <span class="nf">sum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">grid</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes sum of Field over grid using masked array (nan is not counted). Outputs a float if grid is entire grid of the Field, and a Field on remaining grid (self.gr/grid) if grid argument is a subgrid.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">gr</span><span class="o">.</span><span class="n">perm</span><span class="p">(</span><span class="n">grid</span><span class="p">):</span>
<span class="c"># in this case no grid argument is given, or the full grid is given (up to a permutation).</span>
      <span class="n">R</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">masked_array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">))</span>
      <span class="k">return</span> <span class="n">ma</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">R</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
<span class="c"># in this case, it is assumed the user wants to take sums along a certain set of axes, where that grid object is a subspace of self.gr  </span>

<span class="c"># obtain the dual vectorspace axes of grid argument, due to the way the call method of grid objects works.   </span>
      <span class="n">F</span> <span class="o">=</span> <span class="bp">self</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gr</span><span class="o">/</span><span class="n">grid</span><span class="p">)</span>
      
<span class="c"># we assume that F is now a list of fields.</span>
<span class="c"># each element has to be summed.</span>
    
      <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
      <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">F</span><span class="p">:</span>
        <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>

      <span class="n">new_grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gr</span><span class="o">/</span><span class="n">grid</span> 
           
      <span class="k">return</span> <span class="n">Field</span><span class="p">(</span><span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">result</span><span class="p">))</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">new_grid</span><span class="o">.</span><span class="n">shape</span><span class="p">())</span> <span class="p">,</span><span class="n">grid</span> <span class="o">=</span> <span class="n">new_grid</span><span class="p">)</span>


</div>
<div class="viewcode-block" id="Field.ones"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Field.ones">[docs]</a>  <span class="k">def</span> <span class="nf">ones</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nan_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns Field containing domain of this Field: values are 1 in grid locations where Field is defined, nan otherwise.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">new_fld</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gr</span><span class="o">.</span><span class="n">ones</span><span class="p">()</span>
    <span class="n">new_fld</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="p">[:])]</span> <span class="o">=</span> <span class="n">nan_val</span>

    <span class="k">return</span> <span class="n">new_fld</span>

<span class="c"># --&gt; method belongs to Field.</span></div>
<div class="viewcode-block" id="Field.dV"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Field.dV">[docs]</a>  <span class="k">def</span> <span class="nf">dV</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ones</span><span class="p">()</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">gr</span><span class="o">.</span><span class="n">vol</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Field.vol"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Field.vol">[docs]</a>  <span class="k">def</span> <span class="nf">vol</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grid</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute volume (area/ length) of non-nan grid cells. </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dV</span><span class="p">())</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>
    </div>
<div class="viewcode-block" id="Field.vsum"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Field.vsum">[docs]</a>  <span class="k">def</span> <span class="nf">vsum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">grid</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dV</span><span class="p">()</span><span class="o">*</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Field.mean"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Field.mean">[docs]</a>  <span class="k">def</span> <span class="nf">mean</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">grid</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dV</span><span class="p">()</span><span class="o">*</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dV</span><span class="p">())</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="Field.slice"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Field.slice">[docs]</a>  <span class="k">def</span> <span class="nf">slice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sl_coord</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span><span class="n">slice_obj</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="bp">None</span><span class="p">,</span><span class="bp">None</span><span class="p">)):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Slice along Coord (e.g. xt) using slice_obj as slice, e.g. slice(1,None,None).</span>
<span class="sd">    &quot;&quot;&quot;</span>
  
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sl_coord</span><span class="p">,</span><span class="n">Coord</span><span class="p">):</span>
     
      <span class="n">sl</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="bp">None</span><span class="p">,))</span>
      
      <span class="n">L</span> <span class="o">=</span> <span class="p">[]</span>
      <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">gr</span><span class="p">:</span>
        
        <span class="k">if</span> <span class="n">sl_coord</span> <span class="ow">is</span> <span class="n">e</span><span class="p">:</span>
          <span class="n">L</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">slice_obj</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="n">L</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sl</span><span class="p">)</span>    
     
      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="n">L</span><span class="p">]</span>
</div>
<div class="viewcode-block" id="Field.draw"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.Field.draw">[docs]</a>  <span class="k">def</span> <span class="nf">draw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">colorbar</span> <span class="o">=</span> <span class="bp">True</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gr</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
      <span class="n">h</span><span class="o">=</span> <span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
      <span class="n">cb</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gr</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
   
      <span class="n">h</span> <span class="o">=</span> <span class="n">contourf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
      <span class="n">cb</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">()</span>
      <span class="n">cb</span><span class="o">.</span><span class="n">set_label</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">units</span><span class="p">)</span>

    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gr</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
      <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">gr</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">e</span><span class="p">,</span><span class="s">&#39;axis&#39;</span><span class="p">):</span>
          <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">axis</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s">&#39;Z&#39;</span><span class="p">:</span>
            <span class="k">break</span>       
      <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">axis</span><span class="o">.</span><span class="n">name</span> <span class="o">!=</span> <span class="s">&#39;Z&#39;</span><span class="p">:</span>
        <span class="n">e</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

      <span class="n">h</span> <span class="o">=</span> <span class="n">contourf</span><span class="p">(</span><span class="n">e</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
      <span class="n">cb</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">()</span>
      <span class="n">cb</span><span class="o">.</span><span class="n">set_label</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">units</span><span class="p">)</span>

    
    <span class="k">return</span> <span class="n">h</span><span class="p">,</span> <span class="n">cb</span>


<span class="c"># ------------------ end Field  definition ----------------</span>


</div></div>
<div class="viewcode-block" id="VField"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.VField">[docs]</a><span class="k">class</span> <span class="nc">VField</span><span class="p">(</span><span class="nb">tuple</span><span class="p">):</span>

  <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  vector Field. A tuple of fields with extra rules. Allows multiplication.</span>
<span class="sd">  &quot;&quot;&quot;</span>

  <span class="k">def</span> <span class="nf">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">):</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">Field</span><span class="p">):</span>
      
        <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">direction</span> <span class="o">==</span> <span class="n">ID</span><span class="p">():</span>
          <span class="c"># scalar Field multiplication works on individual member fields.</span>
          <span class="k">return</span> <span class="n">VField</span><span class="p">([</span><span class="n">e</span><span class="o">*</span><span class="n">other</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">])</span>

        <span class="k">elif</span> <span class="n">other</span><span class="o">.</span><span class="n">direction</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">direction</span><span class="p">():</span>
          <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">direction</span><span class="p">()</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">direction</span><span class="p">)</span>
          <span class="n">new_vfield</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
          <span class="n">new_vfield</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_vfield</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">other</span>
          <span class="k">return</span> <span class="n">VField</span><span class="p">(</span><span class="n">new_vfield</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
          
          <span class="n">new_vfield</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
          <span class="k">if</span> <span class="n">new_vfield</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">gr</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">gr</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&#39;VField components defined on different grids.&#39;</span><span class="p">,</span><span class="ne">RuntimeWarning</span><span class="p">)</span> 

        <span class="k">return</span> <span class="n">VField</span><span class="p">(</span><span class="n">new_vfield</span> <span class="o">+</span> <span class="p">[</span><span class="n">other</span><span class="p">])</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">VField</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
          <span class="k">return</span> <span class="n">VField</span><span class="p">(</span> <span class="nb">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">:</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="o">*</span><span class="n">other</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">+</span><span class="nb">list</span><span class="p">(</span><span class="n">other</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span> <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="k">return</span> <span class="bp">self</span><span class="o">*</span><span class="n">other</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">else</span><span class="p">:</span>
       <span class="c"># all other types will work on the individual fields. Error messages will be generated from individual multiplication.</span>

       <span class="k">return</span> <span class="n">VField</span><span class="p">([</span><span class="n">e</span><span class="o">*</span><span class="n">other</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">])</span>


  <span class="k">def</span> <span class="nf">__div__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">):</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">Field</span><span class="p">):</span>
      
        <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">direction</span> <span class="o">==</span> <span class="n">ID</span><span class="p">():</span>
          <span class="c"># scalar Field multiplication works on individual member fields.</span>
          <span class="k">return</span> <span class="n">VField</span><span class="p">([</span><span class="n">e</span><span class="o">/</span><span class="n">other</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">])</span>

        <span class="k">elif</span> <span class="n">other</span><span class="o">.</span><span class="n">direction</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">direction</span><span class="p">():</span>
          <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">direction</span><span class="p">()</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">direction</span><span class="p">)</span>
          <span class="n">new_vfield</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
          <span class="n">new_vfield</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_vfield</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="n">other</span>
          <span class="k">return</span> <span class="n">VField</span><span class="p">(</span><span class="n">new_vfield</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="n">new_vfield</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">VField</span><span class="p">(</span><span class="n">new_vfield</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">other</span><span class="o">**-</span><span class="mi">1</span><span class="p">))</span>


    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">VField</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
          <span class="k">return</span> <span class="n">VField</span><span class="p">(</span> <span class="nb">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">:</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="o">*</span><span class="n">other</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">+</span><span class="nb">list</span><span class="p">(</span><span class="n">other</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span> <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="k">return</span> <span class="bp">self</span><span class="o">*</span><span class="n">other</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">else</span><span class="p">:</span>
       <span class="c"># all other types will work on the individual fields. Error messages will be generated from individual multiplication.</span>

       <span class="k">return</span> <span class="n">VField</span><span class="p">([</span><span class="n">e</span><span class="o">/</span><span class="n">other</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">])</span>

  <span class="k">def</span> <span class="nf">__neg__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">VField</span><span class="p">(</span> <span class="p">[</span><span class="o">-</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">]</span> <span class="p">)</span>

  <span class="k">def</span> <span class="nf">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span> <span class="o">+</span> <span class="p">(</span><span class="o">-</span><span class="n">other</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">):</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">VField</span><span class="p">):</span>

      <span class="n">L_l</span> <span class="o">=</span> <span class="p">[]</span>
      <span class="n">L_r</span> <span class="o">=</span> <span class="p">[]</span>

      <span class="k">for</span> <span class="n">lft</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">rgt</span> <span class="ow">in</span> <span class="n">other</span><span class="p">:</span>
          <span class="k">if</span> <span class="n">lft</span><span class="o">.</span><span class="n">direction</span> <span class="o">==</span> <span class="n">rgt</span><span class="o">.</span><span class="n">direction</span><span class="p">:</span>
            <span class="n">L_l</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lft</span><span class="p">)</span>
            <span class="n">L_r</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rgt</span><span class="p">)</span>

      <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">L_l</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">L_r</span><span class="p">):</span>
        <span class="n">L</span> <span class="o">=</span><span class="p">[]</span>    
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">it</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">L_l</span><span class="p">):</span>
          <span class="n">sum_fld</span> <span class="o">=</span> <span class="n">it</span> <span class="o">+</span> <span class="n">L_r</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
          <span class="c"># direction must be assigned, as summing fields does not retain direction.</span>
          <span class="n">sum_fld</span><span class="o">.</span><span class="n">direction</span> <span class="o">=</span> <span class="n">it</span><span class="o">.</span><span class="n">direction</span>
          <span class="n">L</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sum_fld</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">VField</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;Error in VField addition </span><span class="si">%s</span><span class="s"> + </span><span class="si">%s</span><span class="s">. Provide equal length&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">))</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">Field</span><span class="p">):</span>
      <span class="c"># sum a Field to a VField. the Field is added to all members.  </span>
<span class="c">#      if other.direction == ID():</span>

    
      <span class="n">L</span> <span class="o">=</span> <span class="p">[]</span>
      <span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
        <span class="n">sum_fld</span> <span class="o">=</span> <span class="n">it</span> <span class="o">+</span> <span class="n">other</span>
        <span class="n">sum_fld</span><span class="o">.</span><span class="n">direction</span> <span class="o">=</span> <span class="n">it</span><span class="o">.</span><span class="n">direction</span>
        <span class="n">L</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sum_fld</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">VField</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>

    <span class="k">return</span>


<div class="viewcode-block" id="VField.sum"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.VField.sum">[docs]</a>  <span class="k">def</span> <span class="nf">sum</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

    <span class="k">return</span> <span class="nb">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">:</span> <span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="VField.copy"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.VField.copy">[docs]</a>  <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

    <span class="k">return</span> <span class="n">VField</span><span class="p">([</span> <span class="n">e</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span> <span class="p">])</span>    
</div>
<div class="viewcode-block" id="VField.direction"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.VField.direction">[docs]</a>  <span class="k">def</span> <span class="nf">direction</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; </span>
<span class="sd">    Method that returns a tuple of the directions of the tuple components of this vector Field by examining these components.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">:</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">,</span> <span class="p">[</span><span class="n">e</span><span class="o">.</span><span class="n">direction</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">])</span>

</div>
<div class="viewcode-block" id="VField.draw"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.VField.draw">[docs]</a>  <span class="k">def</span> <span class="nf">draw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">direction</span><span class="p">())</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
      <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">gr</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>

        <span class="c"># insert quiver plot here.</span>
        <span class="n">quiver</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
      <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">gr</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>

        <span class="k">pass</span>
    <span class="k">else</span><span class="p">:</span>

      <span class="k">print</span> <span class="s">&quot;Refused. Only plotting 2D fields.&quot;</span>



<span class="c"># ------------ end of VField  --------------------</span>







<span class="c"># Field related functions:</span>



</div></div>
<div class="viewcode-block" id="concatenate"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.concatenate">[docs]</a><span class="k">def</span> <span class="nf">concatenate</span><span class="p">(</span><span class="n">fields</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">name_suffix</span><span class="o">=</span><span class="s">&#39;_cat&#39;</span><span class="p">,</span> <span class="n">new_coord_name</span> <span class="o">=</span> <span class="s">&#39;gamma&#39;</span><span class="p">,</span> <span class="n">new_coord</span><span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">strings</span> <span class="o">=</span> <span class="bp">None</span> <span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Joins a sequence of fields together.</span>

<span class="sd">  concatenate((a1,a2,...),ax=None)</span>
<span class="sd">  Parameters</span>
<span class="sd">  ----------</span>
<span class="sd">  a1, a2,.... : sequence of Field objects</span>
<span class="sd">       </span>
<span class="sd">  The Field value ndarrays must have the same shape, except in the dimension</span>
<span class="sd">  corresponding to `ax` (the one with unequal Coord point values, by default). axis : Ax object, optional       </span>
<span class="sd">  The axis along which the arrays will be joined.  Default is the first one with unequal Coord point values.</span>

<span class="sd">  a new Coord is created if none of the grid elements point in the direction of the ax argument. Then, new_coord_name is used. </span>
<span class="sd">  The above behaviour is overridden if the new_coord argument is given. This is a Coord object that will be used to construct one Field from the fields list argument. The list elements become slices (at single Coord values) and the new_coord values are the corresponding coordinates.</span>
<span class="sd">  &quot;&quot;&quot;</span>

  
  <span class="k">if</span> <span class="n">fields</span> <span class="o">==</span> <span class="p">[]:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Provide list of fields.&#39;</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">new_coord</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">fields</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_coord</span><span class="p">):</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Provide fields and new_coord arguments of equal length if providing new_coord argument.&#39;</span><span class="p">)</span>

    <span class="c"># EXIT POINT</span>
    <span class="k">return</span> <span class="n">fields</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span> <span class="n">name</span> <span class="o">=</span> <span class="n">fields</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span><span class="n">name_suffix</span><span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span> <span class="p">[</span> <span class="n">F</span><span class="p">[:]</span> <span class="k">for</span> <span class="n">F</span> <span class="ow">in</span> <span class="n">fields</span> <span class="p">]</span> <span class="p">)</span> <span class="p">,</span> <span class="n">grid</span> <span class="o">=</span> <span class="n">new_coord</span><span class="o">*</span><span class="n">fields</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">gr</span> <span class="p">)</span>



  <span class="k">if</span> <span class="n">ax</span> <span class="ow">and</span> <span class="p">(</span><span class="n">ax</span><span class="o">*</span><span class="n">fields</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">gr</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">):</span>


    <span class="c"># the axis is not in the grid of the first Field</span>
    <span class="n">expanded_fields</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">if</span> <span class="n">strings</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>    
      <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">F</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">fields</span><span class="p">):</span>
        <span class="n">new_coord</span> <span class="o">=</span> <span class="n">Coord</span><span class="p">(</span><span class="n">name</span> <span class="o">=</span> <span class="n">new_coord_name</span><span class="p">,</span><span class="n">value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">i</span><span class="p">]),</span> <span class="n">direction</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">name</span> <span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="n">ax</span> <span class="p">,</span> <span class="n">strings</span> <span class="o">=</span> <span class="p">[</span><span class="n">strings</span><span class="p">[</span><span class="n">i</span><span class="p">],]</span> <span class="p">)</span>
        <span class="n">expanded_fields</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">F</span><span class="p">(</span><span class="n">new_coord</span><span class="o">*</span><span class="n">F</span><span class="o">.</span><span class="n">gr</span><span class="p">)</span> <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">F</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">fields</span><span class="p">):</span>
        <span class="n">new_coord</span> <span class="o">=</span> <span class="n">Coord</span><span class="p">(</span><span class="n">name</span> <span class="o">=</span> <span class="n">new_coord_name</span><span class="p">,</span><span class="n">value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">i</span><span class="p">]),</span> <span class="n">direction</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">name</span> <span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="n">ax</span>  <span class="p">)</span>
        <span class="n">expanded_fields</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">F</span><span class="p">(</span><span class="n">new_coord</span><span class="o">*</span><span class="n">F</span><span class="o">.</span><span class="n">gr</span><span class="p">)</span> <span class="p">)</span>

    <span class="n">fields</span> <span class="o">=</span> <span class="n">expanded_fields</span>    
    <span class="n">name_suffix</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>

  <span class="c"># EXIT POINT</span>
  <span class="k">return</span> <span class="nb">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">:</span><span class="n">x</span><span class="o">.</span><span class="n">cat</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">name_suffix</span> <span class="o">=</span> <span class="n">name_suffix</span><span class="p">),</span> <span class="n">fields</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="squeeze"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.squeeze">[docs]</a><span class="k">def</span> <span class="nf">squeeze</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">hard</span> <span class="o">=</span> <span class="bp">False</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Equivalent to Numpy squeeze method. Remove dimensions and associated coords in grid of length 1. Reversible operation as squeezed dimensions are recorded. Setting argument hard to True yields an irreversible squeeze where the squeezed dims are not recorded (and cannot be unsqueezed later). </span>
<span class="sd">  &quot;&quot;&quot;</span>

  <span class="n">dims</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">gr</span><span class="p">)</span>
  <span class="n">body</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">value</span>
  
  <span class="n">squeezed_dims</span> <span class="o">=</span> <span class="p">[]</span>

  <span class="k">if</span> <span class="n">hard</span><span class="p">:</span>
    <span class="c"># irreversible squeeze</span>
    <span class="c"># In this case, the squeezed dims are not recorded for later inflation</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">dim</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dims</span><span class="p">):</span>
      <span class="k">if</span> <span class="n">body</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">dims</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">dims</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

  <span class="k">else</span><span class="p">:</span>
    <span class="c"># reversible squeeze</span>
    <span class="c"># In this case, the squeezed dims are ecorded for later inflation</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">dim</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dims</span><span class="p">):</span>
      <span class="k">if</span> <span class="n">body</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">squeezed_dims</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dims</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">dims</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">dims</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
      
   
  <span class="n">body</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">body</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">F</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="n">body</span><span class="p">,</span><span class="n">grid</span> <span class="o">=</span> <span class="n">Gr</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span> <span class="p">,</span> <span class="n">squeezed_dims</span> <span class="o">=</span>  <span class="n">Gr</span><span class="p">(</span><span class="n">squeezed_dims</span><span class="p">)</span> <span class="p">)</span>
</div>
<div class="viewcode-block" id="unsqueeze"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.unsqueeze">[docs]</a><span class="k">def</span> <span class="nf">unsqueeze</span><span class="p">(</span><span class="n">F</span> <span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Opposite of squeeze. Uses the grid stored in squeezed_dims Field attribute to restore the unit-length dimensions (coords) of the Field. </span>
<span class="sd">  </span>
<span class="sd">  &quot;&quot;&quot;</span>

  <span class="n">gr_unsqueezed</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">squeezed_dims</span><span class="o">*</span><span class="n">F</span><span class="o">.</span><span class="n">gr</span>

  <span class="k">return</span> <span class="n">F</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span> <span class="n">value</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">gr_unsqueezed</span><span class="o">.</span><span class="n">shape</span><span class="p">()</span> <span class="p">)</span> <span class="p">,</span> <span class="n">grid</span> <span class="o">=</span> <span class="n">gr_unsqueezed</span><span class="p">,</span> <span class="n">squeezed_dims</span> <span class="o">=</span>  <span class="n">Gr</span><span class="p">(</span> <span class="p">()</span> <span class="p">)</span>  <span class="p">)</span>

 



</div>
<div class="viewcode-block" id="nugget"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.nugget">[docs]</a><span class="k">def</span> <span class="nf">nugget</span><span class="p">(</span><span class="n">path</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">name</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span><span class="n">fields</span> <span class="o">=</span> <span class="p">[]</span> <span class="p">,</span> <span class="n">history</span> <span class="o">=</span> <span class="s">&#39;Created from Spacegrids &#39;</span>  <span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Write.</span>

<span class="sd">    Creates Netcdf file and writes all loaded Field to it, along with their Coord objects.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
      <span class="n">name</span> <span class="o">=</span> <span class="s">&#39;nugget&#39;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;.&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&#39;nc&#39;</span><span class="p">,</span><span class="s">&#39;cdf&#39;</span><span class="p">]:</span>
      <span class="n">name</span> <span class="o">=</span> <span class="n">name</span> <span class="o">+</span><span class="s">&#39;.nc&#39;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">path</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
      <span class="n">name</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span> <span class="n">path</span> <span class="p">,</span> <span class="n">name</span> <span class="p">)</span> 
   
    

    <span class="k">print</span> <span class="s">&#39;Writing Field to file </span><span class="si">%s</span><span class="s">&#39;</span><span class="o">%</span><span class="n">name</span>

    <span class="k">try</span><span class="p">:</span>
      <span class="n">file_handle</span> <span class="o">=</span> <span class="n">netcdf_file</span><span class="p">(</span><span class="n">name</span> <span class="p">,</span> <span class="s">&#39;w&#39;</span><span class="p">)</span>

    <span class="k">except</span> <span class="ne">IOError</span><span class="p">:</span>
      <span class="k">print</span> <span class="s">&#39;Cannot open </span><span class="si">%s</span><span class="s">&#39;</span><span class="o">%</span><span class="n">name</span>

    <span class="k">else</span><span class="p">:</span>

      <span class="k">for</span> <span class="n">fld</span> <span class="ow">in</span> <span class="n">fields</span><span class="p">:</span>

        <span class="n">file_handle</span> <span class="o">=</span> <span class="n">fld</span><span class="o">.</span><span class="n">cdf_insert</span><span class="p">(</span><span class="n">file_handle</span><span class="p">)</span>

      <span class="n">file_handle</span><span class="o">.</span><span class="n">history</span> <span class="o">=</span> <span class="n">history</span> <span class="o">+</span> <span class="s">&#39;</span><span class="si">%s</span><span class="s">&#39;</span><span class="o">%</span><span class="nb">str</span><span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">())</span>
 
<span class="c">#    var_cdf.units = self.units</span>

      <span class="n">file_handle</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>



</div>
<div class="viewcode-block" id="roll"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.roll">[docs]</a><span class="k">def</span> <span class="nf">roll</span><span class="p">(</span><span class="n">F</span><span class="p">,</span><span class="n">shift</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">coord</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">mask</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">keepgrid</span> <span class="o">=</span> <span class="bp">False</span><span class="p">):</span>

  <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Function that rolls a Field similar to np.roll on numpy arrays (sg roll actually calls np.roll). Axis can be picked via coord name. If mask is True, the elements that rolled from the other side of the array are set to nan (appropriate for non re-entrant domains). The rolled coord element of the grid belonging to Field F is replaced by a new Coord object reflecting the roll operation. To disable this Coord replacement, use argument keepgrid = True</span>

<span class="sd">  </span>

<span class="sd">  NOTE: axis here means np array index.</span>

<span class="sd">  &quot;&quot;&quot;</span>

  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">coord</span><span class="p">,</span><span class="n">Ax</span><span class="p">):</span>
    <span class="n">coord</span> <span class="o">=</span> <span class="n">coord</span><span class="o">*</span><span class="n">F</span><span class="o">.</span><span class="n">gr</span>

  <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">axis</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">F</span><span class="o">.</span><span class="n">gr</span><span class="p">:</span>
      
      <span class="n">axis</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">gr</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">coord</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">print</span> <span class="s">&#39;coord not in Field grid&#39;</span>
      <span class="k">return</span> 

<span class="c"># avoid deepcopy for fields</span>
<span class="c"># Fr is the rolled Field.</span>

  <span class="k">if</span> <span class="n">keepgrid</span> <span class="ow">is</span> <span class="bp">True</span><span class="p">:</span>
    <span class="c"># keep the original grid of Field F</span>
    <span class="n">newgr</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">gr</span> 
  <span class="k">elif</span> <span class="n">keepgrid</span> <span class="ow">is</span> <span class="bp">False</span><span class="p">:</span>
    <span class="c"># replace the grid with one with rolled coord</span>
    <span class="n">newgr</span> <span class="o">=</span> <span class="n">coord</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">shift</span> <span class="o">=</span> <span class="n">shift</span><span class="p">)</span><span class="o">*</span><span class="n">F</span><span class="o">.</span><span class="n">gr</span> 
  <span class="k">else</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;Argument error in roll of Field </span><span class="si">%s</span><span class="s">. Provide True or False for keepgrid argument. &#39;</span><span class="p">)</span> <span class="o">%</span> <span class="n">F</span>


  <span class="n">Fr</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">value</span><span class="p">,</span><span class="n">shift</span><span class="o">=</span><span class="n">shift</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">),</span> <span class="n">grid</span> <span class="o">=</span> <span class="n">newgr</span> <span class="p">)</span>
  
  <span class="k">if</span> <span class="n">mask</span><span class="p">:</span>
    <span class="c"># handle the areas in the Field that need to be set to nan</span>
    <span class="n">sl</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="bp">None</span><span class="p">,))</span>
    
    <span class="k">if</span> <span class="n">shift</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
     
      <span class="n">sl_exposed</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">shift</span><span class="p">,</span><span class="bp">None</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">shift</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
<span class="c"># note that shift is negative here, indicating last elements of array.</span>
      <span class="n">sl_exposed</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">shift</span><span class="p">,</span><span class="bp">None</span><span class="p">,</span><span class="bp">None</span><span class="p">)</span>


    <span class="n">L</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">F</span><span class="o">.</span><span class="n">gr</span><span class="p">:</span>
      <span class="n">L</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sl</span><span class="p">)</span>
    <span class="n">L</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">sl_exposed</span>
    <span class="n">Fr</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="n">L</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

  <span class="k">return</span> <span class="n">Fr</span>
</div>
<div class="viewcode-block" id="ones"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.ones">[docs]</a><span class="k">def</span> <span class="nf">ones</span><span class="p">(</span><span class="n">grid</span><span class="p">):</span>

  <span class="k">return</span> <span class="n">Field</span><span class="p">(</span><span class="s">&#39;ones&#39;</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">()),</span><span class="n">grid</span><span class="p">)</span>


</div>
<div class="viewcode-block" id="finer_Field"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.finer_Field">[docs]</a><span class="k">def</span> <span class="nf">finer_Field</span><span class="p">(</span><span class="n">F</span><span class="p">,</span><span class="n">factor</span> <span class="o">=</span><span class="mf">5.</span><span class="p">):</span>

  <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  This is a more UVic specific function to prepare a Field containing the outline of the continents for horizontal plots.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  
  <span class="k">return</span> <span class="n">F</span><span class="p">(</span><span class="n">finer_grid</span><span class="p">(</span><span class="n">grid</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">gr</span><span class="p">,</span><span class="n">factor</span> <span class="o">=</span> <span class="n">factor</span><span class="p">),</span><span class="n">method</span> <span class="o">=</span><span class="s">&#39;nearest&#39;</span><span class="p">)</span>






<span class="c"># ------------- some Coord related functions ----------------------</span>



<span class="c"># used in function cdfsniff</span></div>
<span class="n">cdf_axes</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;X&#39;</span><span class="p">:</span><span class="n">XCoord</span><span class="p">,</span><span class="s">&#39;Y&#39;</span><span class="p">:</span><span class="n">YCoord</span><span class="p">,</span><span class="s">&#39;Z&#39;</span><span class="p">:</span><span class="n">Coord</span><span class="p">,</span><span class="s">&#39;T&#39;</span><span class="p">:</span><span class="n">Coord</span><span class="p">,</span><span class="s">&#39;scalar&#39;</span><span class="p">:</span><span class="n">Coord</span><span class="p">}</span>



<div class="viewcode-block" id="make_dual"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.make_dual">[docs]</a><span class="k">def</span> <span class="nf">make_dual</span><span class="p">(</span><span class="n">crd</span><span class="p">,</span><span class="n">name</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span><span class="n">guess_append</span> <span class="o">=</span> <span class="bp">True</span><span class="p">,</span><span class="n">append_last</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">zero_boundary</span> <span class="o">=</span> <span class="bp">False</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Create a dual Coord by appending one entry, of which the width is guessed based on the adjacent cell width.</span>
<span class="sd">  &quot;&quot;&quot;</span>

  <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">crd</span><span class="o">.</span><span class="n">name</span>

  <span class="k">if</span> <span class="n">guess_append</span><span class="p">:</span>
    <span class="c"># Guesses according to CSIRO  model conventions</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">crd</span><span class="o">.</span><span class="n">direction</span> <span class="o">==</span> <span class="s">&#39;X&#39;</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">crd</span><span class="o">.</span><span class="n">direction</span> <span class="o">==</span> <span class="s">&#39;Y&#39;</span><span class="p">):</span>
      <span class="n">append_last</span> <span class="o">=</span> <span class="bp">False</span> 
    <span class="k">else</span><span class="p">:</span>
      <span class="n">append_last</span> <span class="o">=</span> <span class="bp">True</span>      

  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">crd</span><span class="p">[:])</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">append_last</span><span class="p">:</span>
      <span class="n">value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">crd</span><span class="p">[:]</span> <span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">crd</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">crd</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]))</span>

    <span class="k">else</span><span class="p">:</span>
  
      <span class="n">value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">crd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">crd</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span><span class="n">crd</span><span class="p">[:])</span>

  <span class="k">else</span><span class="p">:</span>
      <span class="n">value</span> <span class="o">=</span> <span class="n">crd</span><span class="p">[:]</span>
 
  <span class="k">return</span> <span class="n">crd</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span> <span class="o">+</span><span class="s">&#39;_edges&#39;</span><span class="p">,</span><span class="n">value</span><span class="o">=</span> <span class="n">value</span><span class="p">,</span> <span class="n">long_name</span> <span class="o">=</span> <span class="n">crd</span><span class="o">.</span><span class="n">long_name</span> <span class="o">+</span> <span class="s">&#39; as edges&#39;</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="find_set_dual"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.find_set_dual">[docs]</a><span class="k">def</span> <span class="nf">find_set_dual</span><span class="p">(</span><span class="n">cstack</span><span class="p">,</span> <span class="n">force</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  This function tries to find duals among a list cstack (argument) of Coord objects.</span>

<span class="sd">  Checks if duals have been defined before. If one such Coord is found, function is aborted (it is assumed it is not needed then). Override with argument force = True.</span>

<span class="sd">  &quot;&quot;&quot;</span>

  <span class="k">if</span> <span class="n">force</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
    <span class="c"># Check if duals have been defined before. If one such Coord is found, function is aborted (it is assumed it is not needed then).</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cstack</span><span class="p">:</span>
      <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">dual</span> <span class="o">!=</span> <span class="n">c</span><span class="p">:</span>
     
        <span class="k">return</span> <span class="n">cstack</span>

  <span class="c"># create grid, and therefore tuple, of all axis objects associated with Coord objects in list cstack.</span>
  <span class="n">axes_available</span> <span class="o">=</span> <span class="nb">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">:</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">,</span> <span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">axis</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cstack</span><span class="p">])</span>


  <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">axes_available</span><span class="p">:</span>
    <span class="c"># L is list of all Coord objects that have same axis.</span>
    <span class="n">L</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cstack</span> <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">axis</span> <span class="o">==</span> <span class="n">a</span><span class="p">]</span>
    
    <span class="c"># if this has two elements, these are considered duals.</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">L</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
  
    <span class="c"># only unique pairs with the same axis will be interpreted as duals.    </span>
      <span class="k">if</span> <span class="n">guess_grid_type</span><span class="p">(</span><span class="n">L</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="s">&#39;ts_grid&#39;</span><span class="p">:</span>
        <span class="n">crd_dual</span> <span class="o">=</span> <span class="n">make_dual</span><span class="p">(</span><span class="n">L</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">name</span> <span class="o">=</span> <span class="n">L</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="p">)</span> 
        <span class="n">L</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dual</span> <span class="o">=</span> <span class="n">crd_dual</span>
      <span class="k">elif</span> <span class="n">guess_grid_type</span><span class="p">(</span><span class="n">L</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="s">&#39;ts_grid&#39;</span><span class="p">:</span>
        <span class="n">crd_dual</span> <span class="o">=</span> <span class="n">make_dual</span><span class="p">(</span><span class="n">L</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">name</span> <span class="o">=</span> <span class="n">L</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="p">)</span> 
        <span class="n">L</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">dual</span> <span class="o">=</span> <span class="n">crd_dual</span>

    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">L</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
       
        <span class="n">crd_dual</span> <span class="o">=</span> <span class="n">make_dual</span><span class="p">(</span><span class="n">L</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">name</span> <span class="o">=</span> <span class="n">L</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="p">)</span> 
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">crd_dual</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
          <span class="n">L</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dual</span> <span class="o">=</span> <span class="n">crd_dual</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="c"># in this case, the Coord is made to be self-dual. this could happen for a time Coord with only 1 time slice. make_dual will return a length 1 dual for a Coord of length 1. Note that for UVic data this else clause is NOT needed to make the Coord self dual. </span>
          <span class="n">L</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dual</span> <span class="o">=</span> <span class="n">L</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        
  <span class="k">return</span> <span class="n">cstack</span>
      



</div>
<div class="viewcode-block" id="find_equal_axes"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.find_equal_axes">[docs]</a><span class="k">def</span> <span class="nf">find_equal_axes</span><span class="p">(</span><span class="n">lstack</span><span class="p">,</span><span class="n">rstack</span><span class="p">):</span>

  <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Expects two lists of Coord objects and determines which Coord objects are equal. This is needed when different Coord objects have identical attributes.</span>

<span class="sd">  &quot;&quot;&quot;</span>

  <span class="k">for</span> <span class="n">lc</span> <span class="ow">in</span> <span class="n">lstack</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">rc</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">rstack</span><span class="p">):</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">lc</span><span class="o">.</span><span class="n">axis</span> <span class="o">==</span> <span class="n">rc</span><span class="o">.</span><span class="n">axis</span><span class="p">):</span>
        <span class="c"># use Coord equality method &amp; (__and__):</span>
        <span class="k">if</span> <span class="n">lc</span><span class="o">&amp;</span><span class="n">rc</span><span class="p">:</span>
          <span class="c"># if all 3 attributes are equal values, replace right stack element with left stack element</span>
          <span class="n">rstack</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">lc</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="c"># in this case the Coord elements only have the same axis attribute, and are merely equivalent.</span>
          <span class="k">if</span> <span class="ow">not</span> <span class="n">rstack</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">^</span><span class="n">lc</span><span class="p">:</span>
            <span class="n">rstack</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">|</span> <span class="n">lc</span>


<span class="c">#  return rstack</span>




<span class="c"># -------- io related Coord functions --------------------</span>

</div>
<div class="viewcode-block" id="cdfsniff"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.cdfsniff">[docs]</a><span class="k">def</span> <span class="nf">cdfsniff</span><span class="p">(</span><span class="n">path_parent</span><span class="p">,</span> <span class="n">file_extensions</span> <span class="o">=</span> <span class="n">cdf_file_extensions</span><span class="p">,</span> <span class="n">verbose</span> <span class="o">=</span> <span class="bp">False</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  This sg function looks inside the path_parent path (path to directory containing the Netcdf files, provided as argument) for Netcdf files and extracts Coord objects from the dim data using sg.cdfsniff_helper.</span>

<span class="sd">  Returns all Coord objects that contain different data, to be used in the Coord stack cstack.</span>
<span class="sd">  &quot;&quot;&quot;</span>

  <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">path_parent</span><span class="p">):</span>
    <span class="c"># In this case, a file path is provided. This occurs when experiment object correspond to (Netcdf) files instead of directories containing Netcdf files.</span>
    <span class="k">return</span> <span class="n">rem_equivs</span><span class="p">(</span><span class="n">cdfsniff_helper</span><span class="p">(</span> <span class="n">path_parent</span> <span class="p">,</span> <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span> <span class="p">))</span>

  <span class="c"># all files within path_parent</span>
  <span class="n">fnames</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">path_parent</span><span class="p">)</span>

  <span class="c"># cstack will contain all Coord objects constructed from dims in Netcdf </span>
  <span class="n">cstack</span> <span class="o">=</span> <span class="p">[]</span>

  <span class="c"># prepare glob patterns to look for Netcdf files</span>
  <span class="n">globfpaths</span> <span class="o">=</span> <span class="p">[</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path_parent</span> <span class="p">,</span> <span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">file_extensions</span><span class="p">]</span>

  <span class="n">cdf_filepaths</span> <span class="o">=</span> <span class="nb">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">,</span> <span class="p">[</span><span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">globfpaths</span>  <span class="p">]</span>  <span class="p">)</span>

  <span class="c"># construct combined cstack out of individual Netcdf files via cdfsniff_helper: </span>
  <span class="k">for</span> <span class="n">cdf_filepath</span> <span class="ow">in</span> <span class="n">cdf_filepaths</span><span class="p">:</span>

    <span class="n">cstack</span> <span class="o">=</span> <span class="n">cstack</span> <span class="o">+</span> <span class="n">cdfsniff_helper</span><span class="p">(</span> <span class="n">cdf_filepath</span> <span class="p">,</span> <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span> <span class="p">)</span>

  <span class="c"># remove equivalent Coord objects (containing the same data) and return    </span>
  <span class="k">return</span> <span class="n">rem_equivs</span><span class="p">(</span><span class="n">cstack</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="cdfsniff_helper"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.cdfsniff_helper">[docs]</a><span class="k">def</span> <span class="nf">cdfsniff_helper</span><span class="p">(</span><span class="n">filepath</span><span class="p">,</span> <span class="n">verbose</span> <span class="o">=</span> <span class="bp">False</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Takes inventory of coords in netcdf file. </span>

<span class="sd">  Input:</span>
<span class="sd">  filepath	total file path the specific Netcdf file.</span>

<span class="sd">  Output:</span>
<span class="sd">  A list of spacegrids Coord objects.</span>

<span class="sd">  Directions and therefore types of Coord objects (e.g. XCoord) are guessed from description and naming of Netcdf vars.</span>


<span class="sd">  &quot;&quot;&quot;</span>

<span class="c"># axis to the possible axes encountered in netcdf: X,Y,Z</span>
  <span class="k">global</span> <span class="n">cdf_axes</span>

  <span class="nb">file</span> <span class="o">=</span> <span class="n">netcdf_file</span><span class="p">(</span><span class="n">filepath</span><span class="p">,</span><span class="s">&#39;r&#39;</span><span class="p">)</span>

  <span class="n">coord_stack</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="n">dimensions</span> <span class="o">=</span> <span class="nb">file</span><span class="o">.</span><span class="n">dimensions</span>
 
  <span class="n">dimensions</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">dimensions</span> <span class="k">if</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">file</span><span class="o">.</span><span class="n">variables</span><span class="p">]</span>

  <span class="k">for</span> <span class="n">dim_name</span> <span class="ow">in</span> <span class="n">dimensions</span><span class="p">:</span>

    <span class="c"># guess which direction the Coord is pointing in, based on netcdf descriptions. The netcdf .axis attribute is included!</span>
    <span class="c"># leave directional_names wild card: no filter on general name (e.g. velocity).</span>

    <span class="c"># maybe rely more on this dictionary in future:</span>
    <span class="n">metadata</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span><span class="nb">file</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">dim_name</span><span class="p">]</span><span class="o">.</span><span class="n">__dict__</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">file</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">dim_name</span><span class="p">]</span><span class="o">.</span><span class="n">__dict__</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&#39;data&#39;</span><span class="p">,</span><span class="s">&#39;dimensions&#39;</span><span class="p">,</span><span class="s">&#39;_shape&#39;</span><span class="p">,</span><span class="s">&#39;_size&#39;</span><span class="p">]</span>  <span class="p">}</span>

    <span class="n">coord_name</span> <span class="o">=</span> <span class="n">dim_name</span>
    
    <span class="n">direction</span> <span class="o">=</span> <span class="n">guess_direction</span><span class="p">(</span><span class="nb">file</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">dim_name</span><span class="p">],</span>  <span class="n">name_atts</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;axis&#39;</span><span class="p">,</span><span class="s">&#39;long_name&#39;</span><span class="p">,</span><span class="s">&#39;standard_name&#39;</span><span class="p">]</span> <span class="p">,</span> <span class="n">x_dir_names</span> <span class="o">=</span> <span class="n">coord_dir_names</span><span class="p">[</span><span class="s">&#39;x_dir_names&#39;</span><span class="p">],</span> <span class="n">y_dir_names</span> <span class="o">=</span> <span class="n">coord_dir_names</span><span class="p">[</span><span class="s">&#39;y_dir_names&#39;</span><span class="p">],</span> <span class="n">z_dir_names</span> <span class="o">=</span> <span class="n">coord_dir_names</span><span class="p">[</span><span class="s">&#39;z_dir_names&#39;</span><span class="p">],</span><span class="n">t_dir_names</span> <span class="o">=</span> <span class="n">coord_dir_names</span><span class="p">[</span><span class="s">&#39;t_dir_names&#39;</span><span class="p">],</span><span class="n">directional_names</span> <span class="o">=</span> <span class="s">&#39;*&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">direction</span> <span class="o">==</span> <span class="s">&#39;scalar&#39;</span><span class="p">:</span>
      <span class="c"># double check that this Coord has no direction by looking at dim_name itself.</span>
      <span class="k">if</span> <span class="n">dim_name</span> <span class="ow">in</span> <span class="n">cdf_axes</span><span class="p">:</span>
        <span class="n">direction</span> <span class="o">=</span> <span class="n">dim_name</span>
        <span class="n">coord_name</span> <span class="o">=</span> <span class="n">dim_name</span> <span class="o">+</span> <span class="s">&#39;_crd&#39;</span>
        <span class="k">print</span> <span class="s">&#39;OK. Inferring direction from dimension name </span><span class="si">%s</span><span class="s"> itself. Renaming Coord to </span><span class="si">%s</span><span class="s">. &#39;</span><span class="o">%</span><span class="p">(</span><span class="n">dim_name</span><span class="p">,</span><span class="n">coord_name</span><span class="p">)</span>

      <span class="k">else</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&#39;No direction inferred for </span><span class="si">%s</span><span class="s">. Guessed direction is scalar.&#39;</span><span class="o">%</span><span class="n">dim_name</span><span class="p">)</span>


    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="nb">file</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">dim_name</span><span class="p">],</span><span class="s">&#39;units&#39;</span><span class="p">):</span>
      <span class="n">units</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="nb">file</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">dim_name</span><span class="p">]</span><span class="o">.</span><span class="n">units</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">units</span> <span class="o">=</span> <span class="s">&#39;?&#39;</span>
      <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&#39;(mild): no units assigned to </span><span class="si">%s</span><span class="s"> in cdfsniff&#39;</span><span class="o">%</span><span class="n">dim_name</span> <span class="p">)</span>

    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="nb">file</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">dim_name</span><span class="p">],</span><span class="s">&#39;long_name&#39;</span><span class="p">):</span>
      <span class="n">long_name</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="nb">file</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">dim_name</span><span class="p">]</span><span class="o">.</span><span class="n">long_name</span> <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">long_name</span> <span class="o">=</span> <span class="s">&#39;?&#39;</span>
      <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>

        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&#39;No long_name for </span><span class="si">%s</span><span class="s">. Assigning </span><span class="si">%s</span><span class="s">&#39;</span><span class="o">%</span><span class="p">(</span><span class="n">dim_name</span><span class="p">,</span> <span class="n">coord_name</span><span class="p">)</span> <span class="p">)</span>
      <span class="n">long_name</span> <span class="o">=</span> <span class="n">coord_name</span>

    <span class="c"># look only at the keys</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="nb">file</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">dim_name</span><span class="p">]</span> <span class="p">,</span> <span class="s">&#39;axis&#39;</span> <span class="p">):</span>
      <span class="c"># If the netcdf vatiable has an axis attribute, as in UVic, we look for edges to determine the dual and assign an axis attribute. </span>

      <span class="c"># only edges Coord objects do not have an axis attribute, so edges</span>
      <span class="c"># Coord objects need to be created simultaneously with their dual.</span>
      <span class="c"># note that time coords have axis attributes but not edges (self-dual).</span>

      <span class="c"># Get the netcdf name of the dual variable (the edges, or bounds). Failure signal is None.</span>
      <span class="n">dual_var_name</span> <span class="o">=</span> <span class="n">get_att</span><span class="p">(</span><span class="nb">file</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">dim_name</span><span class="p">],</span> <span class="n">edge_names</span><span class="p">,</span> <span class="n">fail_val</span> <span class="o">=</span> <span class="bp">None</span><span class="p">)</span>

      <span class="k">if</span> <span class="n">dual_var_name</span> <span class="o">!=</span> <span class="bp">None</span><span class="p">:</span>
        <span class="c"># if edges are defined, we create Coord and its dual in pairs</span>
        <span class="k">if</span> <span class="nb">file</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">dim_name</span><span class="p">]</span><span class="o">.</span><span class="n">axis</span> <span class="ow">in</span> <span class="n">cdf_axes</span><span class="p">:</span>

          <span class="c"># convert the netcdf name of the dual to an actual cdf variable</span>
          <span class="k">if</span> <span class="n">dual_var_name</span> <span class="ow">in</span> <span class="nb">file</span><span class="o">.</span><span class="n">variables</span><span class="p">:</span>
          
            <span class="n">dual_var</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="nb">file</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">dual_var_name</span><span class="p">][:]</span> <span class="p">)</span>
          <span class="k">else</span><span class="p">:</span>

<span class="c"># THIS IS A TEMPORARY FUDGE IN CASE A FILE HINTS AT COORD EDGES BUT DOESN&#39;T STORE THEM:</span>
             <span class="n">dual_var</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="nb">file</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">dim_name</span><span class="p">][:]</span> <span class="p">)</span>           
       
       
          <span class="c"># using call method of Coord object in cdf_axes global</span>

          <span class="n">this_coord</span> <span class="o">=</span> <span class="n">cdf_axes</span><span class="p">[</span><span class="n">direction</span><span class="p">](</span><span class="n">coord_name</span><span class="p">,</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span> <span class="nb">file</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">dim_name</span><span class="p">][:]</span> <span class="p">),</span> <span class="n">axis</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="nb">file</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">dim_name</span><span class="p">]</span><span class="o">.</span><span class="n">axis</span> <span class="p">),</span><span class="n">direction</span> <span class="o">=</span> <span class="n">direction</span><span class="p">,</span> <span class="n">units</span> <span class="o">=</span> <span class="n">units</span><span class="p">,</span> <span class="n">long_name</span> <span class="o">=</span> <span class="n">long_name</span> <span class="p">,</span> <span class="n">metadata</span> <span class="o">=</span> <span class="n">metadata</span><span class="p">)</span>  

          <span class="c">#this_coord = cdf_axes[file.variables[dim_name].axis](dim_name, file.variables[dim_name][:], axis = file.variables[dim_name].axis, units = units)  </span>
          <span class="n">dual_coord</span> <span class="o">=</span> <span class="n">cdf_axes</span><span class="p">[</span><span class="n">direction</span><span class="p">](</span><span class="n">dual_var_name</span><span class="p">,</span><span class="n">prep_dual_array</span><span class="p">(</span><span class="n">dual_var</span><span class="p">),</span><span class="n">dual</span> <span class="o">=</span> <span class="n">this_coord</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="nb">file</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">dim_name</span><span class="p">]</span><span class="o">.</span><span class="n">axis</span> <span class="p">),</span> <span class="n">direction</span> <span class="o">=</span> <span class="n">direction</span><span class="p">,</span> <span class="n">units</span> <span class="o">=</span> <span class="n">units</span><span class="p">,</span> <span class="n">long_name</span> <span class="o">=</span> <span class="n">long_name</span><span class="p">,</span> <span class="n">metadata</span> <span class="o">=</span> <span class="n">metadata</span><span class="p">)</span>

          <span class="n">this_coord</span><span class="o">.</span><span class="n">dual</span> <span class="o">=</span> <span class="n">dual_coord</span>

          <span class="n">coord_stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">this_coord</span><span class="p">)</span>
          <span class="n">coord_stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dual_coord</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
          <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&#39;Unknown axis.&#39;</span><span class="p">,</span><span class="ne">RuntimeWarning</span><span class="p">)</span>

      <span class="k">else</span><span class="p">:</span>
        <span class="c"># this is the case of self-dual objects such as time, so only 1 object needs to be made</span>
        <span class="k">if</span> <span class="nb">file</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">dim_name</span><span class="p">]</span><span class="o">.</span><span class="n">axis</span> <span class="ow">in</span> <span class="n">cdf_axes</span><span class="p">:</span>
          <span class="n">coord_stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cdf_axes</span><span class="p">[</span><span class="n">direction</span><span class="p">](</span><span class="n">coord_name</span><span class="p">,</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="nb">file</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">dim_name</span><span class="p">][:]</span> <span class="p">),</span> <span class="n">axis</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="nb">file</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">dim_name</span><span class="p">]</span><span class="o">.</span><span class="n">axis</span> <span class="p">),</span><span class="n">direction</span> <span class="o">=</span> <span class="n">direction</span><span class="p">,</span> <span class="n">units</span> <span class="o">=</span> <span class="n">units</span><span class="p">,</span> <span class="n">long_name</span> <span class="o">=</span> <span class="n">long_name</span> <span class="p">,</span> <span class="n">metadata</span> <span class="o">=</span> <span class="n">metadata</span> <span class="p">))</span>

    <span class="k">else</span><span class="p">:</span>
    <span class="c"># In this case, no axis attribute has been detected.</span>
      <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="k">print</span> <span class="s">&#39;No Netcdf axis attribute detected. Creating attribute from direction guess.&#39;</span>

      <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="nb">file</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">dim_name</span><span class="p">]</span> <span class="p">,</span> <span class="s">&#39;edges&#39;</span> <span class="p">):</span>
        <span class="c"># if edges are defined, we create coord and its dual in pairs</span>
        <span class="k">if</span> <span class="n">direction</span> <span class="ow">in</span> <span class="n">cdf_axes</span><span class="p">:</span>
          <span class="n">dual_var</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="nb">file</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="nb">file</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">dim_name</span><span class="p">]</span><span class="o">.</span><span class="n">edges</span><span class="p">][:]</span> <span class="p">)</span>

          <span class="c"># using call method of Coord object in cdf_axes global</span>

          <span class="n">this_coord</span> <span class="o">=</span> <span class="n">cdf_axes</span><span class="p">[</span><span class="n">direction</span><span class="p">](</span><span class="n">coord_name</span><span class="p">,</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="nb">file</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">dim_name</span><span class="p">]</span> <span class="p">[:]</span> <span class="p">),</span> <span class="n">axis</span> <span class="o">=</span> <span class="nb">file</span><span class="o">.</span><span class="n">direction</span><span class="p">,</span><span class="n">direction</span> <span class="o">=</span> <span class="n">direction</span><span class="p">,</span> <span class="n">units</span> <span class="o">=</span> <span class="n">units</span><span class="p">,</span> <span class="n">long_name</span> <span class="o">=</span> <span class="n">long_name</span><span class="p">,</span> <span class="n">metadata</span> <span class="o">=</span> <span class="n">metadata</span><span class="p">)</span>  

          <span class="c">#this_coord = cdf_axes[file.variables[dim_name].axis](dim_name, file.variables[dim_name][:], axis = file.variables[dim_name].axis, units = units)  </span>
          <span class="n">dual_coord</span> <span class="o">=</span> <span class="n">cdf_axes</span><span class="p">[</span><span class="n">direction</span><span class="p">](</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span> <span class="nb">file</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">dim_name</span><span class="p">]</span><span class="o">.</span><span class="n">edges</span> <span class="p">),</span><span class="n">prep_dual_array</span><span class="p">(</span><span class="n">dual_var</span><span class="p">),</span><span class="n">dual</span> <span class="o">=</span> <span class="n">this_coord</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="n">direction</span><span class="p">,</span> <span class="n">direction</span> <span class="o">=</span> <span class="n">direction</span><span class="p">,</span> <span class="n">units</span> <span class="o">=</span> <span class="n">units</span><span class="p">,</span> <span class="n">long_name</span> <span class="o">=</span> <span class="n">long_name</span><span class="p">,</span> <span class="n">metadata</span> <span class="o">=</span> <span class="n">metadata</span><span class="p">)</span>


          <span class="n">this_coord</span><span class="o">.</span><span class="n">dual</span> <span class="o">=</span> <span class="n">dual_coord</span>

          <span class="n">coord_stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">this_coord</span><span class="p">)</span>
          <span class="n">coord_stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dual_coord</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
          <span class="n">warnings</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s">&#39;guessed direction not in cdf_axes, strange!&#39;</span><span class="p">)</span>  
      <span class="k">else</span><span class="p">:</span>
        <span class="c"># this is the case of self-dual objects such as time, so only 1 object needs to be made</span>
        <span class="k">if</span> <span class="n">direction</span> <span class="ow">in</span> <span class="n">cdf_axes</span><span class="p">:</span>
          <span class="n">coord_stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cdf_axes</span><span class="p">[</span><span class="n">direction</span><span class="p">](</span><span class="n">coord_name</span><span class="p">,</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="nb">file</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">dim_name</span><span class="p">][:]</span> <span class="p">),</span> <span class="n">axis</span> <span class="o">=</span> <span class="n">direction</span><span class="p">,</span><span class="n">direction</span> <span class="o">=</span> <span class="n">direction</span><span class="p">,</span> <span class="n">units</span> <span class="o">=</span> <span class="n">units</span> <span class="p">,</span><span class="n">long_name</span> <span class="o">=</span><span class="n">long_name</span><span class="p">,</span> <span class="n">metadata</span> <span class="o">=</span> <span class="n">metadata</span><span class="p">))</span>

        <span class="k">else</span><span class="p">:</span>
          <span class="n">warnings</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s">&#39;guessed direction not in cdf_axes, strange!&#39;</span><span class="p">)</span>  
  
  <span class="k">if</span> <span class="n">coord_stack</span><span class="p">:</span>
    <span class="n">bins</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">cdf_axes</span><span class="p">:</span>
      <span class="n">bins</span><span class="p">[</span><span class="n">ax</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
      <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">cc</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">coord_stack</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">ax</span> <span class="o">==</span> <span class="n">cc</span><span class="o">.</span><span class="n">axis</span><span class="p">:</span>
          <span class="n">bins</span><span class="p">[</span><span class="n">ax</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
 
    <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">bins</span><span class="p">:</span>
      <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">[</span><span class="n">name</span><span class="p">])</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">coord_stack</span><span class="p">[</span><span class="n">bins</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="n">i</span><span class="p">]]</span> <span class="o">|</span> <span class="n">coord_stack</span><span class="p">[</span><span class="n">bins</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]]</span>

  <span class="nb">file</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

  <span class="c"># if no duals were defined above, the following function call will detect the absence of duals and try to guess them:</span>


  <span class="k">return</span> <span class="n">coord_stack</span>




</div>
<div class="viewcode-block" id="guess_helper"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.guess_helper">[docs]</a><span class="k">def</span> <span class="nf">guess_helper</span><span class="p">(</span><span class="n">desc</span><span class="p">,</span> <span class="n">guess_names</span><span class="p">,</span> <span class="n">true_val</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">false_val</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Helper function for guess_direction</span>
<span class="sd">  &quot;&quot;&quot;</span>


<span class="c">#  if reduce(lambda x,y: x| y ,[e in desc for e in x_dir_names]):  </span>
<span class="c">#    return &#39;X&#39;</span>

  <span class="n">denied_found</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="ow">in</span> <span class="n">desc</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">guess_names</span> <span class="k">if</span> <span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span><span class="s">&#39;!&#39;</span><span class="p">]</span>
  <span class="k">if</span> <span class="n">denied_found</span><span class="p">:</span>
    <span class="n">deny</span> <span class="o">=</span> <span class="nb">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">:</span> <span class="n">x</span><span class="o">|</span> <span class="n">y</span> <span class="p">,</span> <span class="n">denied_found</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">deny</span> <span class="o">=</span> <span class="bp">False</span>
  <span class="n">allowed_found</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span> <span class="ow">in</span> <span class="n">desc</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">guess_names</span> <span class="k">if</span> <span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span><span class="s">&#39;!&#39;</span><span class="p">]</span>
  <span class="k">if</span> <span class="n">allowed_found</span><span class="p">:</span>
    <span class="n">allow</span> <span class="o">=</span> <span class="nb">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">:</span> <span class="n">x</span><span class="o">|</span> <span class="n">y</span> <span class="p">,</span> <span class="n">allowed_found</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">allow</span> <span class="o">=</span> <span class="bp">False</span>

  <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">deny</span><span class="p">)</span> <span class="ow">and</span> <span class="n">allow</span><span class="p">:</span>  
    <span class="k">return</span> <span class="n">true_val</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">false_val</span>
</div>
<div class="viewcode-block" id="guess_direction"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.guess_direction">[docs]</a><span class="k">def</span> <span class="nf">guess_direction</span><span class="p">(</span><span class="n">cdf_var</span><span class="p">,</span>  <span class="n">name_atts</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;long_name&#39;</span><span class="p">,</span><span class="s">&#39;standard_name&#39;</span><span class="p">],</span> <span class="n">x_dir_names</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;eastward&#39;</span><span class="p">,</span><span class="s">&#39;Eastward&#39;</span><span class="p">,</span><span class="s">&#39;zonal&#39;</span><span class="p">,</span><span class="s">&#39;Zonal&#39;</span><span class="p">],</span> <span class="n">y_dir_names</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;northward&#39;</span><span class="p">,</span><span class="s">&#39;Northward&#39;</span><span class="p">,</span><span class="s">&#39;meridional&#39;</span><span class="p">,</span><span class="s">&#39;Meridional&#39;</span><span class="p">],</span> <span class="n">z_dir_names</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;upward&#39;</span><span class="p">,</span><span class="s">&#39;Upward&#39;</span><span class="p">,</span><span class="s">&#39;vertical&#39;</span><span class="p">,</span><span class="s">&#39;Vertical&#39;</span><span class="p">],</span><span class="n">t_dir_names</span> <span class="o">=</span> <span class="p">[],</span><span class="n">directional_names</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;velocity&#39;</span><span class="p">,</span><span class="s">&#39;stress&#39;</span><span class="p">,</span><span class="s">&#39;momentum flux&#39;</span><span class="p">,</span><span class="s">&#39;momentum_flux&#39;</span><span class="p">]):</span>

  <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Helper function for cdfread. Used to guess, based on keywords in the netcdf data descriptions, whether a Field is a (space-) vector Field component and in what direction it points. The directional_names argument is a list of keywords that might show up in a description that indicates a vector component: e.g. the word velocity. If this list is empty, the function will not search for those keywords (less restrictive). The name_atts argument indicates the possible name of a descriptive attribute in a netcdf file. The {x,y,z}_dir_names correspond to keywords indicating that particular direction (x,y,z).</span>

<span class="sd">  &quot;&quot;&quot;</span>

 <span class="c"># the keywords in the description will indicate a direction Field.</span>
  <span class="c"># i.e. a vector Field component. If found, their direction attribute will be set in the appropriate direction. Otherwise, it is a scalar.</span>

 
  <span class="c"># loop through the possible names the attribute can have</span>

  <span class="k">for</span> <span class="n">na</span> <span class="ow">in</span> <span class="n">name_atts</span><span class="p">:</span>
 
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">cdf_var</span><span class="p">,</span><span class="n">na</span><span class="p">):</span>
    
      <span class="n">desc</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">cdf_var</span><span class="p">,</span><span class="n">na</span><span class="p">)</span>     
      
      <span class="k">if</span> <span class="nb">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">:</span> <span class="n">x</span><span class="o">|</span> <span class="n">y</span> <span class="p">,[</span><span class="n">e</span> <span class="ow">in</span> <span class="n">desc</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">directional_names</span><span class="p">])</span> <span class="o">|</span> <span class="p">(</span><span class="n">directional_names</span> <span class="o">==</span> <span class="s">&#39;*&#39;</span><span class="p">):</span>  
      <span class="c"># directional description found:</span>

        <span class="n">try_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;X&#39;</span><span class="p">:</span><span class="n">x_dir_names</span><span class="p">,</span> <span class="s">&#39;Y&#39;</span><span class="p">:</span><span class="n">y_dir_names</span><span class="p">,</span> <span class="s">&#39;Z&#39;</span><span class="p">:</span> <span class="n">z_dir_names</span><span class="p">,</span> <span class="s">&#39;T&#39;</span><span class="p">:</span><span class="n">t_dir_names</span><span class="p">}</span>

        <span class="k">for</span> <span class="n">XX</span> <span class="ow">in</span> <span class="n">try_dict</span><span class="p">:</span>

          <span class="n">try_dir</span> <span class="o">=</span> <span class="n">guess_helper</span><span class="p">(</span><span class="n">desc</span><span class="p">,</span> <span class="n">try_dict</span><span class="p">[</span><span class="n">XX</span><span class="p">],</span> <span class="n">true_val</span> <span class="o">=</span> <span class="n">XX</span><span class="p">)</span>
        
          <span class="k">if</span> <span class="n">try_dir</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">try_dir</span>
       
 
  <span class="k">return</span> <span class="s">&#39;scalar&#39;</span>

</div>
<div class="viewcode-block" id="cdfread"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.cdfread">[docs]</a><span class="k">def</span> <span class="nf">cdfread</span><span class="p">(</span><span class="n">filepath</span><span class="p">,</span><span class="n">varname</span><span class="p">,</span><span class="n">coord_stack</span><span class="o">=</span><span class="p">[],</span> <span class="n">ax_stack</span> <span class="o">=</span> <span class="p">[],</span> <span class="n">verbose</span> <span class="o">=</span> <span class="bp">True</span><span class="p">,</span><span class="n">squeeze_Field</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Reads data corresponding to variable name varname from netcdf file. Returns Field object. coord_stack is used to provide Field with grid object built from corresponding Coord objects according to information in netcdf.</span>
<span class="sd">  Input filepath is complete path pointing to file.</span>

<span class="sd">  &quot;&quot;&quot;</span>

  <span class="nb">file</span> <span class="o">=</span> <span class="n">netcdf_file</span><span class="p">(</span><span class="n">filepath</span><span class="p">,</span><span class="s">&#39;r&#39;</span><span class="p">)</span>
 
  <span class="k">if</span> <span class="n">varname</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">file</span><span class="o">.</span><span class="n">variables</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
      <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&#39;(moderate) from cdfread: var name not in file.&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="bp">None</span>

  <span class="n">var_cdf_ob</span> <span class="o">=</span> <span class="nb">file</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">varname</span><span class="p">]</span>

  <span class="c"># in future we are going to use this metadata instead of below attributes. For now, it is used when fields are saved.</span>
  <span class="n">metadata</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span><span class="n">var_cdf_ob</span><span class="o">.</span><span class="n">__dict__</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">var_cdf_ob</span><span class="o">.</span><span class="n">__dict__</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&#39;data&#39;</span><span class="p">,</span><span class="s">&#39;dimensions&#39;</span><span class="p">,</span><span class="s">&#39;_shape&#39;</span><span class="p">,</span><span class="s">&#39;_size&#39;</span><span class="p">]</span>  <span class="p">}</span>

  <span class="n">dims</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">var_cdf_ob</span><span class="o">.</span><span class="n">dimensions</span><span class="p">)</span>  
  <span class="n">body</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">var_cdf_ob</span><span class="p">[:])</span>
  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">body</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_array</span><span class="p">):</span>
    <span class="c"># The Netcdf4 module yields masked arrays. Convert to ndarray to work well with sg.</span>
    <span class="c"># fill_value is a standard attribute of masked arrays (no checks):</span>
    <span class="n">mis_val</span> <span class="o">=</span> <span class="n">body</span><span class="o">.</span><span class="n">fill_value</span>

    <span class="n">body</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">body</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">fvn</span> <span class="o">=</span> <span class="n">get_att</span><span class="p">(</span><span class="n">var_cdf_ob</span><span class="p">,</span> <span class="n">fval_names</span><span class="p">,</span><span class="n">fail_val</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">])</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fvn</span><span class="p">,</span><span class="nb">list</span><span class="p">):</span>  
      <span class="n">mis_val</span> <span class="o">=</span> <span class="n">fvn</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> 
    <span class="k">else</span><span class="p">:</span>
      <span class="n">mis_val</span> <span class="o">=</span> <span class="n">fvn</span>

<span class="c">#  mis_val = var_cdf_ob.missing_value[0]</span>
  <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">var_cdf_ob</span><span class="p">,</span><span class="s">&#39;units&#39;</span><span class="p">):</span>
    <span class="n">units</span> <span class="o">=</span> <span class="n">var_cdf_ob</span><span class="o">.</span><span class="n">units</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">units</span> <span class="o">=</span> <span class="s">&#39;?&#39;</span>

  <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">var_cdf_ob</span><span class="p">,</span><span class="s">&#39;long_name&#39;</span><span class="p">):</span>
    <span class="n">long_name</span> <span class="o">=</span> <span class="n">var_cdf_ob</span><span class="o">.</span><span class="n">long_name</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">long_name</span> <span class="o">=</span> <span class="n">varname</span>

 
<span class="c"># attempts at interpreting data by obtaining the string name of the direction. these names are a convention: &#39;X&#39;,&#39;Y&#39;,&#39;Z&#39;. This direction guess is for fields that could be components of a vector fields.</span>

  <span class="n">direction</span> <span class="o">=</span> <span class="n">guess_direction</span><span class="p">(</span><span class="n">var_cdf_ob</span><span class="p">)</span>

  <span class="n">Dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">e</span><span class="o">.</span><span class="n">direction</span><span class="p">:</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">ax_stack</span><span class="p">}</span>
  <span class="n">Dict</span><span class="p">[</span><span class="s">&#39;scalar&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ID</span><span class="p">()</span>

  <span class="n">direction</span> <span class="o">=</span> <span class="n">Dict</span><span class="p">[</span><span class="n">direction</span><span class="p">]</span>


  <span class="k">if</span> <span class="n">squeeze_Field</span><span class="p">:</span>
  <span class="c"># if there are dimensions of length 1, remove them.</span>
    <span class="k">if</span> <span class="mi">1</span> <span class="ow">in</span> <span class="n">body</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
   
      <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">dim</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dims</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">body</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
          <span class="n">dims</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">dims</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
   
    <span class="n">body</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">body</span><span class="p">)</span>

  <span class="k">try</span><span class="p">:</span> 
    <span class="n">body</span><span class="p">[</span><span class="n">body</span> <span class="o">==</span> <span class="n">mis_val</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
  <span class="k">except</span><span class="p">:</span>
    
    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&#39;missing value not set to NaN.&#39;</span><span class="p">)</span>
 
  <span class="n">grid</span> <span class="o">=</span> <span class="p">[]</span>

  <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">dims</span><span class="p">:</span>
    <span class="n">dim_val</span> <span class="o">=</span> <span class="nb">file</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">dim</span><span class="p">][:]</span>
   
    <span class="k">for</span> <span class="n">crd</span> <span class="ow">in</span> <span class="n">coord_stack</span><span class="p">:</span>
   
      <span class="k">if</span> <span class="p">(</span><span class="n">dim</span> <span class="o">==</span> <span class="n">dimname</span><span class="p">(</span><span class="n">crd</span><span class="p">)</span> <span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">dim_val</span> <span class="p">,</span> <span class="n">crd</span><span class="p">[:]):</span>
     
        <span class="n">grid</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">crd</span><span class="p">)</span>
            
  <span class="nb">file</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
<span class="c">#  print &#39;-----&#39;</span>
<span class="c">#  print Gr(tuple(grid)).shape()</span>
<span class="c">#  print body.shape</span>
 
  <span class="k">return</span> <span class="n">Field</span><span class="p">(</span><span class="n">varname</span><span class="p">,</span><span class="n">body</span><span class="p">,</span><span class="n">grid</span><span class="o">=</span><span class="n">Gr</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">grid</span><span class="p">)),</span><span class="n">units</span> <span class="o">=</span> <span class="n">units</span><span class="p">,</span> <span class="n">direction</span> <span class="o">=</span> <span class="n">direction</span><span class="p">,</span> <span class="n">long_name</span> <span class="o">=</span> <span class="n">long_name</span><span class="p">,</span> <span class="n">metadata</span> <span class="o">=</span> <span class="n">metadata</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="dimname"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.dimname">[docs]</a><span class="k">def</span> <span class="nf">dimname</span><span class="p">(</span><span class="n">crd</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Strip off _crd suffix if it had been added because dim name equalled axis name</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">if</span> <span class="p">(</span><span class="s">&#39;_crd&#39;</span> <span class="ow">in</span> <span class="n">crd</span><span class="o">.</span><span class="n">name</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">crd</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;_crd&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">crd</span><span class="o">.</span><span class="n">axis</span><span class="o">.</span><span class="n">name</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">crd</span><span class="o">.</span><span class="n">axis</span><span class="o">.</span><span class="n">name</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">crd</span><span class="o">.</span><span class="n">name</span>

</div>
<div class="viewcode-block" id="delta"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.delta">[docs]</a><span class="k">def</span> <span class="nf">delta</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Function that calls the d method of the Coord object depending on the kind of coordinate (i.e. x or y).</span>

<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">XCoord</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">oth</span> <span class="ow">in</span> <span class="n">x</span><span class="o">.</span><span class="n">others</span><span class="p">:</span>
      <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">oth</span><span class="p">,</span><span class="n">YCoord</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">d</span><span class="p">(</span><span class="n">oth</span><span class="p">)</span>
    <span class="k">print</span> <span class="s">&#39;No y found.&#39;</span>
    <span class="k">return</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">d</span><span class="p">()</span>




</div>
<div class="viewcode-block" id="prep_dual_array"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.prep_dual_array">[docs]</a><span class="k">def</span> <span class="nf">prep_dual_array</span><span class="p">(</span><span class="n">raw_array</span><span class="p">):</span>

  <span class="k">if</span> <span class="n">raw_array</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">raw_array</span>
  <span class="k">elif</span> <span class="n">raw_array</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">raw_array</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">raw_array</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]:</span>
      <span class="c"># assume FAMOUS-type encoding of coord edges.</span>
        <span class="n">new_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">raw_array</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">raw_array</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span> <span class="p">)</span>
    <span class="k">elif</span> <span class="n">raw_array</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">raw_array</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]:</span>
      <span class="c"># assume FAMOUS-type encoding of coord edges.     </span>
        <span class="n">new_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">raw_array</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="p">[</span><span class="n">raw_array</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],]</span> <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&#39;! edge/ boundary var of ndim 2 not recognised.&#39;</span><span class="p">)</span>
 
      <span class="k">print</span> <span class="n">raw_array</span>
      <span class="c"># (un!)lucky guess:</span>
      <span class="n">new_array</span> <span class="o">=</span> <span class="n">raw_array</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>    

  <span class="k">else</span><span class="p">:</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&#39;! edge/ boundary var not recognised.&#39;</span><span class="p">)</span>
    <span class="n">new_array</span> <span class="o">=</span> <span class="n">raw_array</span>    
    
  <span class="k">return</span> <span class="n">new_array</span>


<span class="c"># ------------- some Ax related functions ----------------------</span>
</div>
<div class="viewcode-block" id="guess_grid_type"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.guess_grid_type">[docs]</a><span class="k">def</span> <span class="nf">guess_grid_type</span><span class="p">(</span><span class="n">crd</span><span class="p">,</span> <span class="n">default</span> <span class="o">=</span> <span class="s">&#39;ts_grid&#39;</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Function that guesses the grid type using the keywords contained in the (sg) global dictionary grid_type_names by testing for keywords (contained as lists in that dictionary).</span>

<span class="sd">  Returns None if no grid type is found. </span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">for</span> <span class="n">grtn</span> <span class="ow">in</span> <span class="n">grid_type_names</span><span class="p">:</span>
    <span class="k">if</span> <span class="nb">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">:</span> <span class="n">x</span><span class="o">|</span><span class="n">y</span><span class="p">,</span> <span class="p">[</span><span class="n">e</span> <span class="ow">in</span> <span class="n">crd</span><span class="o">.</span><span class="n">long_name</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">grid_type_names</span><span class="p">[</span><span class="n">grtn</span><span class="p">]]):</span>
      <span class="k">return</span> <span class="n">grtn</span>
  <span class="c"># No grid type found, default is assumed.</span>
  <span class="k">return</span> <span class="n">default</span>





</div>
<div class="viewcode-block" id="make_axes"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.make_axes">[docs]</a><span class="k">def</span> <span class="nf">make_axes</span><span class="p">(</span><span class="n">cstack</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">  Replaces axis attribute of Coord objects if it is a string with newly created (non-repeating) corresponding axis objects.</span>

<span class="sd">  inputs: cstack, a list of Coord objects.</span>
<span class="sd">  outputs: returns a list of all unique (no repeats) Ax objects that have been created to replace the axis attribute of the elements of the Coord list (cstack) argument that were strings. None is returned when all cstack Coord elements already have Ax axis attributes.</span>


<span class="sd">   The Ax objects are created here.</span>

<span class="sd">  Returns list of Ax objects!!</span>

<span class="sd">  NOTE THAT THIS FUNCTION DOES 2 THINGS: IT RETURNS A LIST OF AXES AND MODIFIES THE CSTACK ARGUMENT. </span>

<span class="sd">  &quot;&quot;&quot;</span>
  <span class="c"># No Coord objects will be removed from the cstack list. But cstack argument is modified!</span>
  <span class="c"># created_axes will contain the newly created Ax objects!! So created_axes is NOT cstack!!</span>
  <span class="n">created_axes</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cstack</span><span class="p">:</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="s">&#39;axis&#39;</span><span class="p">):</span>
      <span class="c"># string Ax attribute will be replaced with corresponding Ax object attribute</span>
      <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">axis</span><span class="p">,</span><span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">axis</span><span class="p">,</span><span class="nb">unicode</span><span class="p">):</span>
        <span class="c"># str attr found --&gt; create corresponding Ax object.</span>
        <span class="n">new_ax</span> <span class="o">=</span> <span class="n">Ax</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">axis</span><span class="p">,</span><span class="n">direction</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">direction</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">id_in</span><span class="p">(</span><span class="n">created_axes</span><span class="p">,</span><span class="n">new_ax</span><span class="p">):</span>
          <span class="c"># however, if we already have that Ax object in created_axes, assign existing Ax object instead.</span>
          <span class="n">i</span> <span class="o">=</span> <span class="n">id_index</span><span class="p">(</span><span class="n">created_axes</span><span class="p">,</span><span class="n">new_ax</span><span class="p">)</span>
          <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">direction</span> <span class="o">!=</span> <span class="n">created_axes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">direction</span><span class="p">:</span>
            <span class="c"># if direction inconsistent, proceed but issue warning.</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&#39;Warning! While associating Ax object </span><span class="si">%s</span><span class="s"> with coord </span><span class="si">%s</span><span class="s">. </span><span class="si">%s</span><span class="s">.direction =</span><span class="si">%s</span><span class="s">, </span><span class="si">%s</span><span class="s">.direction = </span><span class="si">%s</span><span class="s"> &#39;</span> <span class="o">%</span><span class="p">(</span><span class="n">created_axes</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">c</span><span class="p">,</span> <span class="n">created_axes</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">created_axes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">direction</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">direction</span><span class="p">)</span> <span class="p">)</span>
          <span class="n">c</span><span class="o">.</span><span class="n">axis</span> <span class="o">=</span> <span class="n">created_axes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
          
        <span class="k">else</span><span class="p">:</span>
          <span class="c"># new Ax object not in created_axes, proceed using new Ax object.</span>
          <span class="n">created_axes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_ax</span><span class="p">)</span>
          <span class="n">c</span><span class="o">.</span><span class="n">axis</span> <span class="o">=</span> <span class="n">new_ax</span> 
        <span class="c"># Ax object equivalent (parallel) to Coord object.</span>
        <span class="n">c</span><span class="o">.</span><span class="n">axis</span> <span class="o">|</span> <span class="n">c</span>     
  <span class="c"># return the list of Ax objects. </span>

  <span class="c"># there might be dual coords associated with coords that still have an axis attribute that hasn&#39;t been converted from str yet. Replace them with elements from the cstack:</span>
  <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">crd</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cstack</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">crd</span><span class="p">,</span><span class="s">&#39;dual&#39;</span><span class="p">):</span>
      <span class="k">if</span> <span class="ow">not</span> <span class="n">crd</span><span class="o">.</span><span class="n">dual</span> <span class="ow">is</span> <span class="n">crd</span><span class="p">:</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">id_index</span><span class="p">(</span><span class="n">cstack</span><span class="p">,</span> <span class="n">crd</span><span class="o">.</span><span class="n">dual</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">i</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
          
          <span class="n">cstack</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">dual</span> <span class="o">=</span> <span class="n">cstack</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

  <span class="k">return</span> <span class="n">created_axes</span>        




<span class="c"># define the scalar axis via a lazy class. Then ID*X = X etc.</span></div>
<div class="viewcode-block" id="GetId"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.GetId">[docs]</a><span class="k">class</span> <span class="nc">GetId</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
  
  <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">ret_id</span> <span class="o">=</span> <span class="bp">None</span>  

  <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ret_id</span><span class="p">):</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">ret_id</span> <span class="o">=</span> <span class="n">Ax</span><span class="p">(</span><span class="s">&#39;scalar&#39;</span><span class="p">)</span>


    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ret_id</span>
</div>
<span class="n">ID</span> <span class="o">=</span> <span class="n">GetId</span><span class="p">()</span>


<span class="c"># ---------------- Gr related functions --------------------</span>

<div class="viewcode-block" id="finer_grid"><a class="viewcode-back" href="../../spacegrids.html#spacegrids.fieldcls.finer_grid">[docs]</a><span class="k">def</span> <span class="nf">finer_grid</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">factor</span> <span class="o">=</span> <span class="mf">5.</span><span class="p">):</span>

  <span class="k">return</span> <span class="nb">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">:</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">,</span> <span class="p">[</span><span class="n">crd</span><span class="o">.</span><span class="n">finer</span><span class="p">(</span><span class="n">factor</span> <span class="o">=</span> <span class="n">factor</span><span class="p">)</span> <span class="k">for</span> <span class="n">crd</span> <span class="ow">in</span> <span class="n">grid</span><span class="p">])</span>





</div>
<span class="kn">from</span> <span class="nn">plotting</span> <span class="kn">import</span> <span class="o">*</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../index.html">spacegrids  documentation</a> &raquo;</li>
          <li><a href="../index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2014, Author.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
  </body>
</html>