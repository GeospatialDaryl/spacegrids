<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>spacegrids Package &mdash; spacegrids  documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="spacegrids  documentation" href="index.html" />
    <link rel="prev" title="Spacegrids data analysis documentation" href="index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="index.html" title="Spacegrids data analysis documentation"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">spacegrids  documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="spacegrids-package">
<h1>spacegrids Package<a class="headerlink" href="#spacegrids-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="id1">
<h2><tt class="xref py py-mod docutils literal"><span class="pre">spacegrids</span></tt> Package<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<span class="target" id="module-spacegrids.__init__"></span></div>
<div class="section" id="module-spacegrids.abstract">
<span id="abstract-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">abstract</span></tt> Module<a class="headerlink" href="#module-spacegrids.abstract" title="Permalink to this headline">¶</a></h2>
<p>Abstract classes to build Coord, Gr, Ax, AxGr and Field class.</p>
<p>Most classes inherit from the abstract base classes Named, Associative, Directional, Membered, Valued contained in abstract.py.</p>
<p>The abstract module contains the following classes:</p>
<div class="section" id="named">
<h3>Named<a class="headerlink" href="#named" title="Permalink to this headline">¶</a></h3>
<p>Base class for most other sg classes, representing objects with copy and same methods.</p>
</div>
<div class="section" id="associative">
<h3>Associative<a class="headerlink" href="#associative" title="Permalink to this headline">¶</a></h3>
<p>Associative class that objects with the equiv method can belong to. Two objects will be equivalent if they belong to the same associative class.</p>
</div>
<div class="section" id="directional">
<h3>Directional<a class="headerlink" href="#directional" title="Permalink to this headline">¶</a></h3>
<p>Base class for derived Coord and Ax classes, representing &#8220;direction&#8221; (e.g. &#8220;latitude&#8221; or &#8220;depth&#8221;). An abstract equivalence relationship is defined among Directional objects where two objects are equivalent when they have the same &#8216;associative&#8217; attribute (pointing to an Associative object). This relationship is generally used to indicate whether two Directional objects have the same direction (e.g. X,Y), but could represent other relationships depending on the user.</p>
</div>
<div class="section" id="membered">
<h3>Membered<a class="headerlink" href="#membered" title="Permalink to this headline">¶</a></h3>
<p>Base class for classes containing members such as a grid (Gr) object containing coordinate (Coord) members, or an AxGr object containing Ax objects, e.g. (X, Y).</p>
</div>
<div class="section" id="valued">
<h3>Valued<a class="headerlink" href="#valued" title="Permalink to this headline">¶</a></h3>
<p>Base class for classes that contain a ndarray value attribute. The Field class is derived from this.</p>
<dl class="class">
<dt id="spacegrids.abstract.Associative">
<em class="property">class </em><tt class="descclassname">spacegrids.abstract.</tt><tt class="descname">Associative</tt><big>(</big><em>name</em><big>)</big><a class="reference internal" href="_modules/spacegrids/abstract.html#Associative"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.abstract.Associative" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spacegrids.abstract.Named" title="spacegrids.abstract.Named"><tt class="xref py py-class docutils literal"><span class="pre">spacegrids.abstract.Named</span></tt></a></p>
<p>Associative class that objects with the equiv method can belong to.</p>
<p>Two objects will be equivalent if they belong to the same associative class.</p>
<p>For Coord objects, this should remain consistent with the axis attribute: two Coord objects belong to the same associative class iff they have the same axis attribute. In this case, the associative class of Coord objects is effectively their direction or axis. The mechanisms for the two remain independent.</p>
<p>For classes using Associative as equivalence principle:</p>
<p>Their copy method should carry over the Associative object of the parent.
Their make_equiv method should make the associate the Associative object of the argument equal to the Associative object of the calling object.
Their __init__ method should create a new Associative class as default behaviour, and assign an argument Associative class if given.</p>
</dd></dl>

<dl class="class">
<dt id="spacegrids.abstract.Directional">
<em class="property">class </em><tt class="descclassname">spacegrids.abstract.</tt><tt class="descname">Directional</tt><big>(</big><em>name='scalar'</em>, <em>direction='scalar'</em>, <em>long_name=''</em>, <em>associative=None</em><big>)</big><a class="reference internal" href="_modules/spacegrids/abstract.html#Directional"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.abstract.Directional" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spacegrids.abstract.Named" title="spacegrids.abstract.Named"><tt class="xref py py-class docutils literal"><span class="pre">spacegrids.abstract.Named</span></tt></a></p>
<p>Base class for derived Coord and Ax classes, representing &#8220;direction&#8221; (e.g. &#8220;latitude&#8221; or &#8220;depth&#8221;).</p>
<p>An abstract equivalence relationship is defined among Directional objects where two objects are equivalent when they have the same &#8216;associative&#8217; attribute (pointing to an Associative object). This relationship is generally used to indicate whether two Directional objects have the same direction (e.g. X,Y), but could represent other relationships depending on the user.</p>
<p>The same method is differentiated from the weaksame method (unlike the parent class), with the more strict additional condition that in addition to &#8220;name&#8221;, the &#8220;direction&#8221; attribute also needs to be the same. therefore, two Directional objects are considered &#8220;same&#8221; when both &#8220;name&#8221; and &#8220;direction&#8221; match. They are &#8220;weaksame&#8221; when only the &#8220;name&#8221; matches.</p>
<p>This base class is closely related to the Ax class. The Coord class is also derived from it.</p>
<dl class="docutils">
<dt>Attributes:</dt>
<dd>name: (str) name of Object
direction: (str) name of direction in which object points
long_name: (str) longer description (e.g. for display or in Netcdf)</dd>
</dl>
<dl class="method">
<dt id="spacegrids.abstract.Directional.eq_in">
<tt class="descname">eq_in</tt><big>(</big><em>collection</em><big>)</big><a class="reference internal" href="_modules/spacegrids/abstract.html#Directional.eq_in"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.abstract.Directional.eq_in" title="Permalink to this definition">¶</a></dt>
<dd><p>Determines whether Coord (self) is equivalent to any of the constituent Coord objects of the argument Gr or GrAx, and returns equivalent object.</p>
<p>Uses: eq_index</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>collection: (Gr or AxGr) object to be checked.</dd>
<dt>Returns:</dt>
<dd>The equivalent object  when crd is equivalent to one of the Coord objects in argument, None otherwise.</dd>
<dt>See also:</dt>
<dd>eq_in method of Ax, GrAx
is_equiv
make_equiv
eq_index
eq_in</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="spacegrids.abstract.Directional.eq_index">
<tt class="descname">eq_index</tt><big>(</big><em>collection</em><big>)</big><a class="reference internal" href="_modules/spacegrids/abstract.html#Directional.eq_index"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.abstract.Directional.eq_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Find index of first element in collection equivalent to self under is_equiv.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>collection: (e.g. List) order collection of Directional objects</dd>
<dt>Returns:</dt>
<dd>Integer if equivalent found (index to equiv element), None otherwise.</dd>
<dt>See also:</dt>
<dd>make_equiv
is_equiv
eq_in</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="spacegrids.abstract.Directional.is_equiv">
<tt class="descname">is_equiv</tt><big>(</big><em>other</em>, <em>checks=False</em><big>)</big><a class="reference internal" href="_modules/spacegrids/abstract.html#Directional.is_equiv"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.abstract.Directional.is_equiv" title="Permalink to this definition">¶</a></dt>
<dd><p>Test for equivalence (under make_equiv) between Directional objects. e.g. xt is equivalent to xu</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>other: (Coord or Ax)</dd>
<dt>Returns:</dt>
<dd>True when equivalent, False otherwise.</dd>
</dl>
<p>Examples:
&gt;&gt;&gt; depth.is_equiv(longitude) # generally different directions.
False</p>
<dl class="docutils">
<dt>See also:</dt>
<dd>make_equiv
eq_index
eq_in</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="spacegrids.abstract.Directional.make_equiv">
<tt class="descname">make_equiv</tt><big>(</big><em>other</em><big>)</big><a class="reference internal" href="_modules/spacegrids/abstract.html#Directional.make_equiv"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.abstract.Directional.make_equiv" title="Permalink to this definition">¶</a></dt>
<dd><p>Register equivalence of two Directional objects.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>other: (Directional)</dd>
<dt>Returns:</dt>
<dd>None</dd>
<dt>See also:</dt>
<dd>is_equiv
eq_index
eq_in</dd>
</dl>
<p>Examples:
&gt;&gt;&gt; depth.is_equiv(longitude) # generally different directions.
False
&gt;&gt;&gt; depth.make_equiv(longitude) # don&#8217;t do this in real work
&gt;&gt;&gt; depth.is_equiv(longitude) # uphysically:
True</p>
</dd></dl>

<dl class="method">
<dt id="spacegrids.abstract.Directional.same">
<tt class="descname">same</tt><big>(</big><em>other</em><big>)</big><a class="reference internal" href="_modules/spacegrids/abstract.html#Directional.same"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.abstract.Directional.same" title="Permalink to this definition">¶</a></dt>
<dd><p>Method to check whether this Directional object has identical main attributes to argument other.</p>
<p>Overrides Name class same method.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>other: (Directional) to check against</dd>
<dt>Returns:</dt>
<dd>True/ False</dd>
<dt>Attributes checked:</dt>
<dd>name: via str ==
direction: via str ==</dd>
<dt>See also:</dt>
<dd>samein method
same_index method</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="spacegrids.abstract.Membered">
<em class="property">class </em><tt class="descclassname">spacegrids.abstract.</tt><tt class="descname">Membered</tt><big>(</big><em>name='scalar'</em>, <em>long_name=''</em><big>)</big><a class="reference internal" href="_modules/spacegrids/abstract.html#Membered"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.abstract.Membered" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spacegrids.abstract.Named" title="spacegrids.abstract.Named"><tt class="xref py py-class docutils literal"><span class="pre">spacegrids.abstract.Named</span></tt></a></p>
<p>Base class for classes containing members such as a grid (Gr) object containing coordinate (Coord) members, or an AxGr object containing Ax objects, e.g. (X, Y).</p>
<p>This class is intended for multiple inheritance with classes that provide container functionality. For example Tuple. The elements inside the tuples are then referred to as &#8220;members&#8221;, hence the name of this class.  Methods relate to general operations with these members. Note that more specific member-related methods are relegated to derived classes.</p>
<p>__init__ method of joint-inheritance class must take a container of elements.</p>
<dl class="method">
<dt id="spacegrids.abstract.Membered.call_on_members">
<tt class="descname">call_on_members</tt><big>(</big><em>method</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/spacegrids/abstract.html#Membered.call_on_members"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.abstract.Membered.call_on_members" title="Permalink to this definition">¶</a></dt>
<dd><p>Call method on all members and construct new Membered object.</p>
</dd></dl>

<dl class="method">
<dt id="spacegrids.abstract.Membered.copy">
<tt class="descname">copy</tt><big>(</big><em>caller</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/spacegrids/abstract.html#Membered.copy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.abstract.Membered.copy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="spacegrids.abstract.Membered.eq_in">
<tt class="descname">eq_in</tt><big>(</big><em>member</em><big>)</big><a class="reference internal" href="_modules/spacegrids/abstract.html#Membered.eq_in"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.abstract.Membered.eq_in" title="Permalink to this definition">¶</a></dt>
<dd><p>Determines whether argument is equivalent to any of the constituent members.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>member: (Membered) object to be checked.</dd>
<dt>Returns:</dt>
<dd>True when member is equivalent to one of the member objects, False otherwise.</dd>
</dl>
<p>See also:
eq_in method of Coord</p>
</dd></dl>

<dl class="method">
<dt id="spacegrids.abstract.Membered.eq_index">
<tt class="descname">eq_index</tt><big>(</big><em>member</em><big>)</big><a class="reference internal" href="_modules/spacegrids/abstract.html#Membered.eq_index"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.abstract.Membered.eq_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns index of argument in members.</p>
</dd></dl>

<dl class="method">
<dt id="spacegrids.abstract.Membered.eq_perm">
<tt class="descname">eq_perm</tt><big>(</big><em>other</em>, <em>verbose=True</em><big>)</big><a class="reference internal" href="_modules/spacegrids/abstract.html#Membered.eq_perm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.abstract.Membered.eq_perm" title="Permalink to this definition">¶</a></dt>
<dd><p>Yields permutation of members going from self to other, where equivalent members are treated as identical.</p>
<p>See also perm.</p>
</dd></dl>

<dl class="method">
<dt id="spacegrids.abstract.Membered.get_from_members">
<tt class="descname">get_from_members</tt><big>(</big><em>att_name</em><big>)</big><a class="reference internal" href="_modules/spacegrids/abstract.html#Membered.get_from_members"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.abstract.Membered.get_from_members" title="Permalink to this definition">¶</a></dt>
<dd><p>Call method on all members and construct new Membered object.</p>
</dd></dl>

<dl class="method">
<dt id="spacegrids.abstract.Membered.is_equiv">
<tt class="descname">is_equiv</tt><big>(</big><em>other</em><big>)</big><a class="reference internal" href="_modules/spacegrids/abstract.html#Membered.is_equiv"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.abstract.Membered.is_equiv" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks member-wise equivalence between Membered objects up to a permutation.</p>
<p>For grids,  objects are equivalent if they define the same physical subspace, based on the equivalence definition for Coord classes. In other words, checks whether the individual Coord elements of the two grid (Gr object) arguments are equivalent up to a permutation. A stricter version of this test is strict_equiv, which allows no permutation.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>other: (Membered) the object to compare with</dd>
<dt>Returns:</dt>
<dd>True if all (self) members are equivalent to a member of other and vice versa and both have equal length. False otherwise</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="spacegrids.abstract.Membered.json">
<tt class="descname">json</tt><big>(</big><em>types_allow=</em><span class="optional">[</span><span class="optional">]</span><big>)</big><a class="reference internal" href="_modules/spacegrids/abstract.html#Membered.json"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.abstract.Membered.json" title="Permalink to this definition">¶</a></dt>
<dd><p>convert self to a json friendly object.</p>
<p>Usage: json.dumps(X.json())</p>
</dd></dl>

<dl class="method">
<dt id="spacegrids.abstract.Membered.perm">
<tt class="descname">perm</tt><big>(</big><em>other</em>, <em>verbose=False</em><big>)</big><a class="reference internal" href="_modules/spacegrids/abstract.html#Membered.perm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.abstract.Membered.perm" title="Permalink to this definition">¶</a></dt>
<dd><p>yields permutation of axes going from self to other.</p>
<p>E.g. for grids gr1 and gr2, g2 = g1.rearrange( g1.perm(g2) )</p>
<p>Returns None if no permutation exists.</p>
<p>See also rearrange.</p>
</dd></dl>

<dl class="method">
<dt id="spacegrids.abstract.Membered.rearrange">
<tt class="descname">rearrange</tt><big>(</big><em>permutation</em><big>)</big><a class="reference internal" href="_modules/spacegrids/abstract.html#Membered.rearrange"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.abstract.Membered.rearrange" title="Permalink to this definition">¶</a></dt>
<dd><p>Rearranges the order of the members of this object via permutation arrgument.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>permutation: (List or Tuple) permutation to rearrange by</dd>
<dt>Returns:</dt>
<dd>object of same type as self with member rearranged.</dd>
</dl>
<p>Examples:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">g1</span> <span class="o">=</span> <span class="n">latitude</span><span class="o">*</span><span class="n">depth</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g1</span><span class="o">.</span><span class="n">rearrange</span><span class="p">(</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="p">)</span> 
<span class="go">(depth, latitude)</span>
</pre></div>
</div>
<p>See also Gr.perm method</p>
</dd></dl>

<dl class="method">
<dt id="spacegrids.abstract.Membered.reverse">
<tt class="descname">reverse</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/spacegrids/abstract.html#Membered.reverse"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.abstract.Membered.reverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Reverse the order of the members.</p>
<p>Examples:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">coord1</span> <span class="o">=</span> <span class="n">sg</span><span class="o">.</span><span class="n">fieldcls</span><span class="o">.</span><span class="n">Coord</span><span class="p">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">&#39;test1&#39;</span><span class="p">,</span><span class="n">direction</span> <span class="o">=</span><span class="s">&#39;X&#39;</span><span class="p">,</span><span class="n">value</span> <span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span><span class="mf">2.</span><span class="p">,</span><span class="mf">3.</span><span class="p">])</span> <span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">coord2</span> <span class="o">=</span> <span class="n">sg</span><span class="o">.</span><span class="n">fieldcls</span><span class="o">.</span><span class="n">Coord</span><span class="p">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">&#39;test2&#39;</span><span class="p">,</span><span class="n">direction</span> <span class="o">=</span><span class="s">&#39;Y&#39;</span><span class="p">,</span><span class="n">value</span> <span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span><span class="mf">2.</span><span class="p">,</span><span class="mf">3.</span><span class="p">,</span><span class="mf">4.</span><span class="p">])</span> <span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">coord1</span><span class="o">*</span><span class="n">coord2</span><span class="p">)</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
<span class="go">(test2, test1)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="spacegrids.abstract.Membered.same">
<tt class="descname">same</tt><big>(</big><em>other</em><big>)</big><a class="reference internal" href="_modules/spacegrids/abstract.html#Membered.same"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.abstract.Membered.same" title="Permalink to this definition">¶</a></dt>
<dd><p>Member-wise same comparison.</p>
</dd></dl>

<dl class="method">
<dt id="spacegrids.abstract.Membered.strict_equiv">
<tt class="descname">strict_equiv</tt><big>(</big><em>other</em><big>)</big><a class="reference internal" href="_modules/spacegrids/abstract.html#Membered.strict_equiv"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.abstract.Membered.strict_equiv" title="Permalink to this definition">¶</a></dt>
<dd><p>Tests whether two Membered objects have equivalent Members at each position.
This is a stricter test than Membered equivalence testing via gr1.is_equiv(gr2), which only tests whether both Membered objects describe the same linear space (elements equivalent up to a permutation).</p>
</dd></dl>

<dl class="method">
<dt id="spacegrids.abstract.Membered.weaksame">
<tt class="descname">weaksame</tt><big>(</big><em>other</em><big>)</big><a class="reference internal" href="_modules/spacegrids/abstract.html#Membered.weaksame"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.abstract.Membered.weaksame" title="Permalink to this definition">¶</a></dt>
<dd><p>Member-wise weaksame comparison.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="spacegrids.abstract.Named">
<em class="property">class </em><tt class="descclassname">spacegrids.abstract.</tt><tt class="descname">Named</tt><big>(</big><em>name='scalar'</em>, <em>long_name=''</em><big>)</big><a class="reference internal" href="_modules/spacegrids/abstract.html#Named"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.abstract.Named" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Base class for most other sg classes, representing objects with copy and same methods.</p>
<p>The &#8220;same&#8221; method indicates when Named objects are &#8220;the same&#8221;, namely when their &#8220;name&#8221; attribute is the same. This method coincides with the &#8220;weaksame&#8221; method. &#8220;Weaksame&#8221; is generally a weaker condition in the derived classes. The &#8220;same&#8221; method allows the implementation of the &#8220;samein&#8221; and &#8220;sameindex&#8221; methods at this abstract level, with generally the &#8220;same&#8221; method overriden in derived classes.</p>
<p>This class provides a copy method that is used by the derived classes.</p>
<dl class="docutils">
<dt>Attributes:</dt>
<dd>name: (str) name of Object</dd>
</dl>
<dl class="method">
<dt id="spacegrids.abstract.Named.copy">
<tt class="descname">copy</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/spacegrids/abstract.html#Named.copy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.abstract.Named.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy method for Named. See __init__ for arguments.</p>
<p>Most child classes should inherit this method.</p>
<dl class="docutils">
<dt>Returns: </dt>
<dd>a copy of the Directional object.</dd>
</dl>
<p>Copy methods in sg work as follows: when no value is selected for an argument, a copy of the self attribute will be used. Otherwise, the <a href="#id2"><span class="problematic" id="id3">**</span></a>kwargs argument value will be used.</p>
</dd></dl>

<dl class="method">
<dt id="spacegrids.abstract.Named.json">
<tt class="descname">json</tt><big>(</big><em>types_allow=</em><span class="optional">[</span><span class="optional">]</span><big>)</big><a class="reference internal" href="_modules/spacegrids/abstract.html#Named.json"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.abstract.Named.json" title="Permalink to this definition">¶</a></dt>
<dd><p>convert self to a json friendly object.</p>
<p>Usage: json.dumps(X.json())</p>
</dd></dl>

<dl class="method">
<dt id="spacegrids.abstract.Named.same">
<tt class="descname">same</tt><big>(</big><em>other</em><big>)</big><a class="reference internal" href="_modules/spacegrids/abstract.html#Named.same"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.abstract.Named.same" title="Permalink to this definition">¶</a></dt>
<dd><p>Method to check whether this Named object has identical main attributes to argument other.</p>
<p>Placeholder identical to weaksame: to be overriden in child classes.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>other: (Named) to check against</dd>
<dt>Returns:</dt>
<dd>True/ False</dd>
<dt>Attributes checked:</dt>
<dd>name: via str ==</dd>
<dt>See also:</dt>
<dd>samein method
same_index method</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="spacegrids.abstract.Named.samein">
<tt class="descname">samein</tt><big>(</big><em>L</em><big>)</big><a class="reference internal" href="_modules/spacegrids/abstract.html#Named.samein"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.abstract.Named.samein" title="Permalink to this definition">¶</a></dt>
<dd><p>Tests whether this Directional is the same as any element in list L, under &#8216;same&#8217; method.</p>
<p>Uses: same method.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>L: (list of Directional objects) to test against</dd>
<dt>returns:</dt>
<dd>True/ False</dd>
<dt>See also:</dt>
<dd>same method
same_index method</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="spacegrids.abstract.Named.sameindex">
<tt class="descname">sameindex</tt><big>(</big><em>L</em><big>)</big><a class="reference internal" href="_modules/spacegrids/abstract.html#Named.sameindex"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.abstract.Named.sameindex" title="Permalink to this definition">¶</a></dt>
<dd><p>Find index of this Directional in list L of Directional objects, under &#8216;same&#8217; method.</p>
<p>Uses: same method.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>L: (list of directional objects) to search</dd>
<dt>returns:</dt>
<dd>None or Integer, the index of the first item it in the list that satisfies self.same(it)</dd>
<dt>See also:</dt>
<dd>same method
samein method</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="spacegrids.abstract.Named.weaksame">
<tt class="descname">weaksame</tt><big>(</big><em>other</em><big>)</big><a class="reference internal" href="_modules/spacegrids/abstract.html#Named.weaksame"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.abstract.Named.weaksame" title="Permalink to this definition">¶</a></dt>
<dd><p>Tests if two Directional objects have the same name.</p>
<p>Weak test to see if two Directional objects are similar.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>other: other Directional object to compare self with</dd>
<dt>Returns: </dt>
<dd>True/ False</dd>
</dl>
<p><strong>See also</strong>
same method
samein method
sameindex method</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="spacegrids.abstract.Valued">
<em class="property">class </em><tt class="descclassname">spacegrids.abstract.</tt><tt class="descname">Valued</tt><big>(</big><em>name='scalar'</em>, <em>value=array([0])</em>, <em>long_name=''</em><big>)</big><a class="reference internal" href="_modules/spacegrids/abstract.html#Valued"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.abstract.Valued" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spacegrids.abstract.Named" title="spacegrids.abstract.Named"><tt class="xref py py-class docutils literal"><span class="pre">spacegrids.abstract.Named</span></tt></a></p>
<p>Base class for classes that contain a ndarray value attribute.</p>
<p>This class derives its name from the presence of an attribute named &#8220;value&#8221; that contains a Numpy ndarray. Methods relate to this attribute.</p>
<dl class="method">
<dt id="spacegrids.abstract.Valued.array_equal">
<tt class="descname">array_equal</tt><big>(</big><em>other</em><big>)</big><a class="reference internal" href="_modules/spacegrids/abstract.html#Valued.array_equal"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.abstract.Valued.array_equal" title="Permalink to this definition">¶</a></dt>
<dd><p>test whether Valued objects contain identically valued ndarrays in value attributes.</p>
<p>This is a common method that should be inherited by child classes.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>other: (Valued object) the Valued to compare with</dd>
<dt>Returns:</dt>
<dd>True/ False (using np.array_equal)</dd>
<dt>Raises:</dt>
<dd>ValueError: when argument is not a Coord object</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="spacegrids.abstract.Valued.get_value">
<tt class="descname">get_value</tt><big>(</big><em>i</em><big>)</big><a class="reference internal" href="_modules/spacegrids/abstract.html#Valued.get_value"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.abstract.Valued.get_value" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="spacegrids.abstract.Valued.same">
<tt class="descname">same</tt><big>(</big><em>other</em><big>)</big><a class="reference internal" href="_modules/spacegrids/abstract.html#Valued.same"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.abstract.Valued.same" title="Permalink to this definition">¶</a></dt>
<dd><p>Tests whether this Valued object contains identical name and value to argument object.</p>
<p>Overrides Named same method and is a stronger condition. Generally to be overriden in child classes.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>other: (Valued) object to compare against.</dd>
<dt>Returns: </dt>
<dd>True/ False</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="spacegrids.abstract.Valued.set_value">
<tt class="descname">set_value</tt><big>(</big><em>value</em><big>)</big><a class="reference internal" href="_modules/spacegrids/abstract.html#Valued.set_value"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.abstract.Valued.set_value" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="spacegrids.abstract.Valued.sliced">
<tt class="descname">sliced</tt><big>(</big><em>slice_obj=None</em>, <em>suffix='_sliced'</em><big>)</big><a class="reference internal" href="_modules/spacegrids/abstract.html#Valued.sliced"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.abstract.Valued.sliced" title="Permalink to this definition">¶</a></dt>
<dd><p>Create new sliced Valued object with sliced value.</p>
<p>The slice argument must match the value dimensions, there are no checks.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>slice_obj: (slice objects or tuple of) to slice value with
suffix: (str) suffix to use for sliced Valued object</dd>
<dt>Returns:</dt>
<dd>Valued object containing sliced value</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
</div>
<div class="section" id="module-spacegrids.expercls">
<span id="expercls-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">expercls</span></tt> Module<a class="headerlink" href="#module-spacegrids.expercls" title="Permalink to this headline">¶</a></h2>
<p>The Exper class and associated functions. Exper represents experiment data sets.</p>
<p>An Exper object corresponds to (collections of) Netcdf File(s).</p>
<p>The general workflow starts with the creation of a Project object (providing a path to a project directory). This will lead sg to look through the project directory for subdirectories and Netcdf files (based on the file suffix). An Exper object is created for each subdir and Netcdf file found, and added to the project. So an Exper object may represent either a subdirectory of a project directory or a specific Netcdf file inside that project directory (recorded in the &#8216;path&#8217; attribute). Each Exper with name attribute &#8216;foo&#8217; can then be accessed via P[&#8216;foo&#8217;]. This procedure provides groundwork by interpreting axis and coordinate date found in the Netcdf files (inside the subdirectories in the case where the Exper object represents a subdirectory) and adding this information to the Exper objects (see Attributes). Once this structure is established, specific data sets can be loaded across experiments using P.load.</p>
<blockquote>
<div><p>Examples:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">spacegrids</span> <span class="kn">as</span> <span class="nn">sg</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D</span> <span class="o">=</span> <span class="n">sg</span><span class="o">.</span><span class="n">info_dict</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">P</span> <span class="o">=</span> <span class="n">sg</span><span class="o">.</span><span class="n">Project</span><span class="p">(</span><span class="n">D</span><span class="p">[</span><span class="s">&#39;my_project&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">E</span> <span class="o">=</span> <span class="n">P</span><span class="p">[</span><span class="s">&#39;DPO&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">E</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
<span class="go">DPO</span>
<span class="go">----------</span>
<span class="go">Exper using 0.01 Mb. 0 fields loaded.  </span>
</pre></div>
</div>
</div></blockquote>
<dl class="class">
<dt id="spacegrids.expercls.Exper">
<em class="property">class </em><tt class="descclassname">spacegrids.expercls.</tt><tt class="descname">Exper</tt><big>(</big><em>path='/home/wim'</em>, <em>name='test'</em>, <em>cstack=</em>, <span class="optional">[</span><span class="optional">]</span><em>params={}</em>, <em>vars={}</em>, <em>descr=None</em><big>)</big><a class="reference internal" href="_modules/spacegrids/expercls.html#Exper"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.expercls.Exper" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Represents experiment data sets. Corresponds to (collections of) Netcdf File(s).</p>
<dl class="docutils">
<dt>Attributes:</dt>
<dd>axes: (list of Ax objects) link to axes list belonging to project (same list for all Exper objects). Generally constructed from Netcdf data
coords: (dictionary of name vs Coord objects) for easy reference, see cstack
cstack: (list of Coord objectd) the coordinate stack of all Coord objects constructed for this experiment
descr: (str) an optional description of this experiment.
name: (str) the name of this experiment. Generally derived from data file name
nbytes: (int) approximate memory usage of experiment in bytes
params: (dictionary of name value pairs) collection of single value named parameters (e.g. co2 vs 280)
path: (str) full path on filesystem to experiment directory or file 
vars: (dictionary of name vs Field objects) contains the loaded Fields (e.g. a 3D dataset of temperature)</dd>
</dl>
<p>The general workflow starts with the creation of a Project object (providing a path to a project directory). This will lead sg to look through the project directory for subdirectories and Netcdf files (based on the file suffix). An Exper object is created for each subdir and Netcdf file found, and added to the project. So an Exper object may represent either a subdirectory of a project directory or a specific Netcdf file inside that project directory (recorded in the &#8216;path&#8217; attribute). Each Exper with name attribute &#8216;foo&#8217; can then be accessed via P[&#8216;foo&#8217;]. This procedure provides groundwork by interpreting axis and coordinate date found in the Netcdf files (inside the subdirectories in the case where the Exper object represents a subdirectory) and adding this information to the Exper objects (see Attributes). Once this structure is established, specific data sets can be loaded across experiments using P.load.</p>
<p>Examples:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">spacegrids</span> <span class="kn">as</span> <span class="nn">sg</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D</span> <span class="o">=</span> <span class="n">sg</span><span class="o">.</span><span class="n">info_dict</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">P</span> <span class="o">=</span> <span class="n">sg</span><span class="o">.</span><span class="n">Project</span><span class="p">(</span><span class="n">D</span><span class="p">[</span><span class="s">&#39;my_project&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">E</span> <span class="o">=</span> <span class="n">P</span><span class="p">[</span><span class="s">&#39;DPO&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">E</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
<span class="go">DPO</span>
<span class="go">----------</span>
<span class="go">Exper using 0.01 Mb. 0 fields loaded.  </span>
</pre></div>
</div>
<dl class="method">
<dt id="spacegrids.expercls.Exper.available">
<tt class="descname">available</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/spacegrids/expercls.html#Exper.available"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.expercls.Exper.available" title="Permalink to this definition">¶</a></dt>
<dd><p>Obtain list of all available Netcdf variable names (strings) for this Exper.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>No args.</dd>
<dt>Returns:</dt>
<dd>List of strings of variable names in experiment Netcdf file(s).</dd>
<dt>Raises:</dt>
<dd>IOError: when Netcdf file cannot be opened.</dd>
</dl>
<p>Called by ls method.</p>
<dl class="docutils">
<dt>See also:</dt>
<dd>ls method.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="spacegrids.expercls.Exper.delvar">
<tt class="descname">delvar</tt><big>(</big><em>varnames</em>, <em>msg=''</em><big>)</big><a class="reference internal" href="_modules/spacegrids/expercls.html#Exper.delvar"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.expercls.Exper.delvar" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete items from the vars Field dict attribute of Exper using del.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>varnames: (str or list) items to delete</dd>
<dt>Returns:</dt>
<dd>None</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="spacegrids.expercls.Exper.get">
<tt class="descname">get</tt><big>(</big><em>varnames</em><big>)</big><a class="reference internal" href="_modules/spacegrids/expercls.html#Exper.get"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.expercls.Exper.get" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Args:</dt>
<dd>varnames: (str or list) simple filter (or list of -) used by fnmatch.fnmatch</dd>
<dt>Returns:</dt>
<dd>None if no match, or one Field if only one Field name matches varnames pattern, otherwise list of Field objects.</dd>
</dl>
<p>Examples:
&gt;&gt;&gt; E = P[&#8216;DPO&#8217;]
&gt;&gt;&gt; P.load([&#8216;O_temp&#8217;,&#8217;O_sal&#8217;] )  
&gt;&gt;&gt; E[&#8216;O_*&#8217;] 
[O_temp, O_sal]</p>
</dd></dl>

<dl class="method">
<dt id="spacegrids.expercls.Exper.insert">
<tt class="descname">insert</tt><big>(</big><em>what</em><big>)</big><a class="reference internal" href="_modules/spacegrids/expercls.html#Exper.insert"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.expercls.Exper.insert" title="Permalink to this definition">¶</a></dt>
<dd><p>Insert Field in Field list (vars attribute), or into params att if argument is a number.</p>
<p>The &#8220;what&#8221; argument is a 2 tuple (pair) of name and value: (name, value). Value can be a Field or a single value. Name must be a string, but can be None in the case of a Field, where the Field name will then be used. For example what = (&#8216;temp&#8217;,TEMP), where TEMP is a Field. If value is a single value (e.g. int or float), a name must be provided.</p>
<p>Argument what can also be a list of (name,value) pairs, in which case the entire collection of pairs will be inserted.</p>
<p>At the moment, &#8216;insert&#8217; forces key van object name to be consistent. Might change in future. Also copies field object to do this.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>what: (length 2 tuple or list thereof) name and value: (name, value).</dd>
<dt>Returns:</dt>
<dd>None</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="spacegrids.expercls.Exper.list_vars">
<tt class="descname">list_vars</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/spacegrids/expercls.html#Exper.list_vars"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.expercls.Exper.list_vars" title="Permalink to this definition">¶</a></dt>
<dd><p>Show report of loaded variables in stdout.</p>
</dd></dl>

<dl class="method">
<dt id="spacegrids.expercls.Exper.load">
<tt class="descname">load</tt><big>(</big><em>varnames</em>, <em>squeeze_field=True</em>, <em>ax=None</em>, <em>name_suffix='_cat'</em>, <em>new_coord_name='gamma'</em>, <em>new_coord=None</em>, <em>slices=None</em>, <em>slice_suffix='_sliced'</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/spacegrids/expercls.html#Exper.load"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.expercls.Exper.load" title="Permalink to this definition">¶</a></dt>
<dd><p>Load a variable or list of variables contained in varnames into Exper.</p>
<p>Takes either a single string or a list of strings. If multiple files inside a directory contain the same variable, this method will attempt to concatenate them (e.g. in the case where there are different time slices).</p>
<p>if self.path is to a file (an Experiment file), the variable will be loaded from that file.
if self.path is to a directory (an experiment dir), the variable will be loaded from Netcdf files inside that directory.</p>
<p><a href="#id4"><span class="problematic" id="id5">*</span></a>args, <a href="#id6"><span class="problematic" id="id7">**</span></a>kwargs are passed on to the &#8216;netcdf_file&#8217; function that handles opening of the file.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>varnames: (str or list) var name or list of the var names to load
squeeze_field (boolean):  Flag to squeeze Field on loading (default True) 
ax (Ax): passed on to the concatenate function                    
name_suffix (str): passed on to the concatenate function
new_coord_name (str): passed on to the concatenate function
new_coord (Coord): passed on to the concatenate function
slices: (tuple of slice, Coord and Ax objects) slices to take. No slicing if None.     
slice_suffix: (str) suffix to add to variable name in case of slicing</dd>
<dt>Returns:</dt>
<dd>None</dd>
<dt>Raises:</dt>
<dd>IOError: if path to Netcdf file not valid (rare under automatic sg usage).</dd>
</dl>
<p>Examples:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">P</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s">&#39;O_temp&#39;</span><span class="p">,</span><span class="n">slices</span><span class="o">=</span><span class="p">(</span><span class="n">Z</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">X</span><span class="p">,</span><span class="mi">50</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">E</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
<span class="go">DPO</span>
<span class="go">----------</span>
<span class="go">O_temp_sliced </span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">TEMP</span> <span class="o">=</span> <span class="n">E</span><span class="p">[</span><span class="s">&#39;O_temp_sliced&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">TEMP</span><span class="o">.</span><span class="n">grid</span>
<span class="go">(latitude)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="spacegrids.expercls.Exper.ls">
<tt class="descname">ls</tt><big>(</big><em>width=20</em><big>)</big><a class="reference internal" href="_modules/spacegrids/expercls.html#Exper.ls"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.expercls.Exper.ls" title="Permalink to this definition">¶</a></dt>
<dd><p>Show list of all available Netcdf variable names (strings) for this Exper to screen.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>width: (int) column width formatting for screen output.</dd>
<dt>Returns:</dt>
<dd>None</dd>
<dt>Raises:</dt>
<dd>IOError: when Netcdf file cannot be opened.</dd>
</dl>
<p>Calling available method.</p>
<dl class="docutils">
<dt>See also:</dt>
<dd>available method.</dd>
</dl>
<p>Variable list method of Exper.
Examine which fields (Netcdf variables) are available of experiment object.</p>
</dd></dl>

<dl class="method">
<dt id="spacegrids.expercls.Exper.show">
<tt class="descname">show</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/spacegrids/expercls.html#Exper.show"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.expercls.Exper.show" title="Permalink to this definition">¶</a></dt>
<dd><p>Shows summary of key Exper specifics.</p>
<p>Shows the experiment name, its memory usage and the number of Field objects loaded.</p>
</dd></dl>

<dl class="method">
<dt id="spacegrids.expercls.Exper.update_nbytes">
<tt class="descname">update_nbytes</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/spacegrids/expercls.html#Exper.update_nbytes"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.expercls.Exper.update_nbytes" title="Permalink to this definition">¶</a></dt>
<dd><p>Recalculate and update memory usage of this Exper.</p>
</dd></dl>

<dl class="method">
<dt id="spacegrids.expercls.Exper.write">
<tt class="descname">write</tt><big>(</big><em>path=None</em>, <em>name=None</em>, <em>history='Created from Spacegrids '</em>, <em>insert_dual=True</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/spacegrids/expercls.html#Exper.write"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.expercls.Exper.write" title="Permalink to this definition">¶</a></dt>
<dd><p>Write Exper to Netcdf file.</p>
<p><a href="#id8"><span class="problematic" id="id9">*</span></a>args, <a href="#id10"><span class="problematic" id="id11">**</span></a>kwargs are passed on to netcdf io function (Dataset() ).</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>path: (str) path to the directory where the file will go (e.g. &#8216;data/&#8217; or &#8216;/home/me/&#8217;, default pwd).
name: (str) file name (e.g. &#8220;foo.nc&#8221;)
history: (str) Brief history or general description of the data.
insert_dual: (Boolean) Flag determining whether to include the duals of the Coord objects in the file.</dd>
<dt>Returns:</dt>
<dd>None</dd>
</dl>
<p>Creates Netcdf file and writes all loaded Field to it, along with their Coord objects (and their duals if requested).</p>
<p>Examples:
&gt;&gt;&gt; E = P[&#8216;DPO&#8217;]
&gt;&gt;&gt; E.write()  # yields DPO.nc in pwd</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">E</span> <span class="o">=</span> <span class="n">P</span><span class="p">[</span><span class="s">&#39;DPO&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">E</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">path</span><span class="o">=</span><span class="s">&#39;TMP/&#39;</span><span class="p">,</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;foo.nc&#39;</span><span class="p">)</span>  <span class="c"># yields TMP/foo.nc with respect to pwd</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="spacegrids.expercls.isexpdir">
<tt class="descclassname">spacegrids.expercls.</tt><tt class="descname">isexpdir</tt><big>(</big><em>path, file_extensions=['*.nc', '*.cdf']</em><big>)</big><a class="reference internal" href="_modules/spacegrids/expercls.html#isexpdir"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.expercls.isexpdir" title="Permalink to this definition">¶</a></dt>
<dd><p>Tests whether the subdirectories in the path contain data files.</p>
<p>Returns the list of those subdirectories (relative path to path argument) that 
contain these known files. To be used by adexp functionality and such.
file_extensions is the list of known filenames in the form of glob expressions, e.g.   
[&#8216;<em>.nc&#8217;,&#8217;</em>.cdf&#8217;] (the default).</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>path: (str) path to directory containing experiment directories or files (usually a project dir). Generally computed by sg
file_extensions: (str) file extensions to look for in path (default .cdf and .nc)</dd>
<dt>Returns:</dt>
<dd>List of directory and file names (not full paths) believed to correspond to experiments.</dd>
<dt>Raises:</dt>
<dd>RuntimeError: when path not valid.</dd>
</dl>
<p>path can be relative to pwd or full path.</p>
<p>Examples:
&gt;&gt;&gt; sg.isexpdir(&#8216;/home/me/PROJECTS/test_project/&#8217;)
[&#8216;DPO&#8217;, &#8216;DPC&#8217;, &#8216;Lev.cdf&#8217;]</p>
</dd></dl>

</div>
<div class="section" id="module-spacegrids.fieldcls">
<span id="fieldcls-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">fieldcls</span></tt> Module<a class="headerlink" href="#module-spacegrids.fieldcls" title="Permalink to this headline">¶</a></h2>
<p>Field and Gr objects represent data defined on grids and reflecting Netcdf data: Coord, Gr, Ax, AxGr and Field.</p>
<p>Gr (grid) objects are constructed from Coord (coordinate) objects as tuples and Membered methods. Similarly, AxGr (axis grid) objects are constructed from Ax (axis, e.g. X or Y) objects. Field objects contain a grid (a Gr object) attribute and a ndarray value attribute of data defined on that grid. Vfield objects (vector fields) are tuples of Field objects with Membered methods.</p>
<p>The fieldcls module contains the following classes:</p>
<div class="section" id="coord">
<h3>Coord<a class="headerlink" href="#coord" title="Permalink to this headline">¶</a></h3>
<p>Represents distrete coordinate collection in a direction (e.g. 10m depth, 20m depth,...). Corresponds to dimension variable in Netcdf.</p>
</div>
<div class="section" id="gr">
<h3>Gr<a class="headerlink" href="#gr" title="Permalink to this headline">¶</a></h3>
<p>Represents Coord grids. Consists of a tuple of Coord objects, with additional Membered and other methods.</p>
</div>
<div class="section" id="ax">
<h3>Ax<a class="headerlink" href="#ax" title="Permalink to this headline">¶</a></h3>
<p>Axis. Represents direction: e.g. the longitudinal direction, X, or the vertical, Z. Coord objects have an attribute that points to an Ax object, representing its direction.</p>
</div>
<div class="section" id="axgr">
<h3>AxGr<a class="headerlink" href="#axgr" title="Permalink to this headline">¶</a></h3>
<p>Same as Gr, but containing Ax objects instead of Coord. Difference is mainly in the multiplication methods.</p>
</div>
<div class="section" id="field">
<h3>Field<a class="headerlink" href="#field" title="Permalink to this headline">¶</a></h3>
<p>Represents a dataset defined on a grid.</p>
<dl class="class">
<dt id="spacegrids.fieldcls.Ax">
<em class="property">class </em><tt class="descclassname">spacegrids.fieldcls.</tt><tt class="descname">Ax</tt><big>(</big><em>name='scalar'</em>, <em>direction='scalar'</em>, <em>long_name=''</em>, <em>associative=None</em><big>)</big><a class="reference internal" href="_modules/spacegrids/fieldcls.html#Ax"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.fieldcls.Ax" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spacegrids.abstract.Directional" title="spacegrids.abstract.Directional"><tt class="xref py py-class docutils literal"><span class="pre">spacegrids.abstract.Directional</span></tt></a></p>
<p>Axis. Represents direction: e.g. the longitudinal direction, X, or the vertical, Z.</p>
<p>Coord objects have an attribute that points to an Ax object, representing its direction.</p>
<p>An abstract equivalence relationship is inherited from the Directional class, where two objects are equivalent when they have the same &#8216;associative&#8217; attribute (pointing to an Associative object). This relationship is generally used to indicate whether two Directional objects have the same direction (e.g. X,Y), but could represent other relationships depending on the user. This means that a Coord object can be equivalent to an Ax object. The usual meaning of this is that both point in the same direction.</p>
<dl class="docutils">
<dt>Attributes: (identical to Directional parent class)</dt>
<dd>name: (str) name of Object
direction: (str) name of direction in which object points
long_name: (str) longer description (e.g. for display or in Netcdf)</dd>
</dl>
<dl class="method">
<dt id="spacegrids.fieldcls.Ax.der">
<tt class="descname">der</tt><big>(</big><em>F</em><big>)</big><a class="reference internal" href="_modules/spacegrids/fieldcls.html#Ax.der"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.fieldcls.Ax.der" title="Permalink to this definition">¶</a></dt>
<dd><p>Derivative method of Ax. Uses entire grid, in case some coords depend on other coords, as with x-coord. e.g. x-differentiation requires knowledge of y-position due to nature of polar coords.</p>
</dd></dl>

<dl class="method">
<dt id="spacegrids.fieldcls.Ax.vcumsum">
<tt class="descname">vcumsum</tt><big>(</big><em>other</em>, <em>upward=True</em><big>)</big><a class="reference internal" href="_modules/spacegrids/fieldcls.html#Ax.vcumsum"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.fieldcls.Ax.vcumsum" title="Permalink to this definition">¶</a></dt>
<dd><p>Calls the Coord cumsum method by picking the right Coord from other.grid.</p>
<p>Fails if Ax not in other.grid Ax objects.</p>
<p>See Coord.cumsum</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="spacegrids.fieldcls.AxGr">
<em class="property">class </em><tt class="descclassname">spacegrids.fieldcls.</tt><tt class="descname">AxGr</tt><big>(</big><em>name='scalar'</em>, <em>long_name=''</em><big>)</big><a class="reference internal" href="_modules/spacegrids/fieldcls.html#AxGr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.fieldcls.AxGr" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">tuple</span></tt>, <a class="reference internal" href="#spacegrids.abstract.Membered" title="spacegrids.abstract.Membered"><tt class="xref py py-class docutils literal"><span class="pre">spacegrids.abstract.Membered</span></tt></a></p>
<p>Same as Gr, but containing Ax objects instead of Coord.</p>
<p>Difference is mainly in the multiplication methods.</p>
<p>Example: (X,Y )</p>
</dd></dl>

<dl class="class">
<dt id="spacegrids.fieldcls.Coord">
<em class="property">class </em><tt class="descclassname">spacegrids.fieldcls.</tt><tt class="descname">Coord</tt><big>(</big><em>name='scalar'</em>, <em>value=array([0])</em>, <em>dual=None</em>, <em>axis='?'</em>, <em>direction='scalar'</em>, <em>units=None</em>, <em>long_name='?'</em>, <em>metadata={}</em>, <em>strings=None</em>, <em>associative=None</em><big>)</big><a class="reference internal" href="_modules/spacegrids/fieldcls.html#Coord"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.fieldcls.Coord" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spacegrids.abstract.Directional" title="spacegrids.abstract.Directional"><tt class="xref py py-class docutils literal"><span class="pre">spacegrids.abstract.Directional</span></tt></a>, <a class="reference internal" href="#spacegrids.abstract.Valued" title="spacegrids.abstract.Valued"><tt class="xref py py-class docutils literal"><span class="pre">spacegrids.abstract.Valued</span></tt></a></p>
<p>Represents distrete coordinate collection in a direction (e.g. 10m depth, 20m depth,...). Corresponds to dimension variable in Netcdf.</p>
<p>Coord objects are defined by a name, value (generally a numpy array) and units. The value of a Coord is a 1D ndarray containing the locations of data points. Coord is the basic building block of Gr (grid) objects.
Examples of Coord objects are xt or yt, corresponding to the tracer grid cells in the x and y directions. Coord objects have a corresponding dual. For xt it is xt_edges and vice versa. The dual generally contains the edges of the grid cells. If no dual argument is given, the Coord object is its own dual.</p>
<p>Coord objects c1 and c2 are considered weakly the same, c1.weaksame(c2) yields True, when the name, value (numpy array) and units attributes are equal.</p>
<p>Being a container of Coord objects, the Gr object (grid) is closely related to Coord. A shorthand for Gr construction is via multiplication of Coord objects. If two Coord objects coord1 and coord2 are not equivalent (generally when they point in different directions, e.g. X and Y), their product is a shorthand for the creation of a 2D grid coord1*coord2 = Gr((coord1, coord2)). By induction, products containing n elements yield Gr objects of dimension &lt;=n. See class documentation.</p>
<p>An abstract equivalence relationship is inherited from the Directional classs where two objects are equivalent when they have the same &#8216;associative&#8217; attribute (pointing to an Associative object). This relationship is generally used to indicate whether two Directional objects have the same direction (e.g. X,Y), but could represent other relationships depending on the user.</p>
<p>The Coord class contains methods related to distances, with the following dependencies. dist is fundamental. delta_dist depends on dist. der depends on dist. d depends on dual Coord and delta_dist. vol depends on d.</p>
<dl class="docutils">
<dt>Attributes:</dt>
<dd>axis: (Ax) axis along which Coord is defined.
dual: (Coord) link to other Coord object, usually representing edges of cells.
direction: (str) name of direction in which Coord is defined.
equivs: (list of Coords) list of links to equivalent Coord objects. Usually coincides with all Coord&#8217;s defined in same direction.
len: (int) length of the value attribute (ndarray)
long_name: (str) a longer description. Usually taken from identically named variable in Netcdf file.
metadata: (dict) name vs value dict of metadata to save into Netcdf. Usually obtained from Netcdf read.
name: (str) name of object (e.g. &#8216;xt&#8217; or &#8216;depth&#8217;).
nbytes: (int) approximate memory usage of Coord object.
strings: (list of strings or None) str labels for coord points. If not None, needs to be of same length as value
units: (str) units (e.g. &#8220;meter&#8221;)
value: (Numpy ndarray) 1D array corresponding to spatial points (e.g. 10 degrees S for a point).</dd>
<dt>Examples:    </dt>
<dd><div class="first last highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">coord1</span> <span class="o">=</span> <span class="n">sg</span><span class="o">.</span><span class="n">fieldcls</span><span class="o">.</span><span class="n">Coord</span><span class="p">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">&#39;test1&#39;</span><span class="p">,</span><span class="n">value</span> <span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span><span class="mf">2.</span><span class="p">,</span><span class="mf">3.</span><span class="p">])</span> <span class="p">,</span><span class="n">axis</span> <span class="o">=</span><span class="n">sg</span><span class="o">.</span><span class="n">fieldcls</span><span class="o">.</span><span class="n">Ax</span><span class="p">(</span><span class="s">&#39;X&#39;</span><span class="p">),</span><span class="n">direction</span> <span class="o">=</span><span class="s">&#39;X&#39;</span><span class="p">,</span> <span class="n">metadata</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;hi&#39;</span><span class="p">:</span><span class="mi">5</span><span class="p">}</span> <span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">coord2</span> <span class="o">=</span> <span class="n">sg</span><span class="o">.</span><span class="n">fieldcls</span><span class="o">.</span><span class="n">Coord</span><span class="p">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">&#39;test2&#39;</span><span class="p">,</span><span class="n">value</span> <span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span><span class="mf">2.</span><span class="p">,</span><span class="mf">3.</span><span class="p">,</span><span class="mf">4.</span><span class="p">]),</span><span class="n">axis</span> <span class="o">=</span><span class="n">sg</span><span class="o">.</span><span class="n">fieldcls</span><span class="o">.</span><span class="n">Ax</span><span class="p">(</span><span class="s">&#39;Y&#39;</span><span class="p">),</span><span class="n">direction</span> <span class="o">=</span><span class="s">&#39;Y&#39;</span><span class="p">,</span> <span class="n">metadata</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;hi&#39;</span><span class="p">:</span><span class="mi">7</span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">coord3</span> <span class="o">=</span> <span class="n">sg</span><span class="o">.</span><span class="n">fieldcls</span><span class="o">.</span><span class="n">Coord</span><span class="p">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">&#39;test3&#39;</span><span class="p">,</span><span class="n">value</span> <span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.5</span><span class="p">,</span><span class="mf">2.5</span><span class="p">,</span><span class="mf">3.5</span><span class="p">,</span><span class="mf">4.5</span><span class="p">]),</span><span class="n">axis</span> <span class="o">=</span><span class="n">sg</span><span class="o">.</span><span class="n">fieldcls</span><span class="o">.</span><span class="n">Ax</span><span class="p">(</span><span class="s">&#39;X&#39;</span><span class="p">),</span><span class="n">direction</span> <span class="o">=</span><span class="s">&#39;X&#39;</span><span class="p">,</span> <span class="n">metadata</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;hi&#39;</span><span class="p">:</span><span class="mi">7</span><span class="p">})</span>
</pre></div>
</div>
</dd>
</dl>
<dl class="method">
<dt id="spacegrids.fieldcls.Coord.cast">
<tt class="descname">cast</tt><big>(</big><em>other=None</em>, <em>index=0</em><big>)</big><a class="reference internal" href="_modules/spacegrids/fieldcls.html#Coord.cast"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.fieldcls.Coord.cast" title="Permalink to this definition">¶</a></dt>
<dd><p>Broadcasts Coord onto grid.</p>
<p>Calling a Coord object with a grid Gr object as argument yields an array with the coord values broadcast onto that grid.</p>
<p>In other words, the resulting array A is defined on that grid where A[:,i,...] = self.value[i] for all i. This leads to an expansion of the Coord value useful for grid operations such as interpolation.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>other: (Gr, Field, None) Gr to broadcast on or Field to slice.
index: (int) index at which to take a slice in case of Field argument.</dd>
<dt>Returns:</dt>
<dd>Field with Coord broadcast onto that grid if Coord is in that Gr. If not, None is returned.</dd>
<dt>Examples:</dt>
<dd><div class="first last highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">R</span> <span class="o">=</span> <span class="n">xt</span><span class="p">(</span><span class="n">xt</span><span class="o">*</span><span class="n">yt</span><span class="o">*</span><span class="n">zt</span><span class="p">)</span>   <span class="c"># obtain Field R</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">R</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">xt</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">yt</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">zt</span><span class="p">))</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">R</span><span class="o">.</span><span class="n">grid</span>
<span class="go">(xt, yt, zt)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Here, the value of R is constant in yt and zt, but equal to xt along the xt axis.</span>
</pre></div>
</div>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="spacegrids.fieldcls.Coord.coord_shift">
<tt class="descname">coord_shift</tt><big>(</big><em>F</em>, <em>shift</em>, <em>keepgrid=False</em>, <em>nan_val=nan</em><big>)</big><a class="reference internal" href="_modules/spacegrids/fieldcls.html#Coord.coord_shift"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.fieldcls.Coord.coord_shift" title="Permalink to this definition">¶</a></dt>
<dd><p>Coord method that shifts the coordinates and value of a field by a number of indices.</p>
<p>The shifted Coord in the grid of the Field argument is replaced with a (different) shifted Coord: disable this behaviour with argument keepgrid = True. Calls roll function.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>F: (Field) field to shift
shift: (int) magnitude (corresponding to array index) of shift
keepgrid: (Boolean, default False) grid not updated if True</dd>
<dt>Returns:</dt>
<dd>The shifted Field.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="spacegrids.fieldcls.Coord.cumsum">
<tt class="descname">cumsum</tt><big>(</big><em>F</em>, <em>upward=False</em>, <em>land_nan=True</em><big>)</big><a class="reference internal" href="_modules/spacegrids/fieldcls.html#Coord.cumsum"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.fieldcls.Coord.cumsum" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute cumulative sum (integral) of input Field F along axis of F corresponding to this Coord object.</p>
<blockquote>
<div>If argument upward is set to true, summing takes place with increasing array index. If it is set to False, summing takes place with decreasing array index starting at index -1. Values of nan are set to 0, and therefore not counted.</div></blockquote>
<dl class="docutils">
<dt>Args:</dt>
<dd>F: (Field) Field to sum
upward: (Boolean) flag to set direction of cumsum
land_nan: (Boolean) flag to set land to nan in the resulting array</dd>
<dt>Returns:</dt>
<dd>Field on same grid containing the cumsum.</dd>
<dt>Raises:</dt>
<dd>ValueError: when Coord (self) is not in F.grid (grid of Field).</dd>
</dl>
<p>Examples:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">coord1</span> <span class="o">=</span> <span class="n">sg</span><span class="o">.</span><span class="n">fieldcls</span><span class="o">.</span><span class="n">Coord</span><span class="p">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">&#39;test1&#39;</span><span class="p">,</span><span class="n">direction</span> <span class="o">=</span><span class="s">&#39;X&#39;</span><span class="p">,</span><span class="n">value</span> <span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span><span class="mf">2.</span><span class="p">,</span><span class="mf">3.</span><span class="p">])</span> <span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">coord2</span> <span class="o">=</span> <span class="n">sg</span><span class="o">.</span><span class="n">fieldcls</span><span class="o">.</span><span class="n">Coord</span><span class="p">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">&#39;test2&#39;</span><span class="p">,</span><span class="n">direction</span> <span class="o">=</span><span class="s">&#39;Y&#39;</span><span class="p">,</span><span class="n">value</span> <span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span><span class="mf">2.</span><span class="p">,</span><span class="mf">3.</span><span class="p">,</span><span class="mf">4.</span><span class="p">])</span> <span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">R</span> <span class="o">=</span> <span class="n">coord1</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">sg</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">coord1</span><span class="o">*</span><span class="n">coord2</span><span class="p">)</span>  <span class="p">);</span><span class="n">R</span><span class="o">.</span><span class="n">value</span>
<span class="go">array([[ 3.,  3.,  3.,  3.],</span>
<span class="go">       [ 2.,  2.,  2.,  2.],</span>
<span class="go">       [ 1.,  1.,  1.,  1.]])</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">R</span> <span class="o">=</span> <span class="n">coord1</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">sg</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">coord1</span><span class="o">*</span><span class="n">coord2</span><span class="p">)</span> <span class="p">,</span> <span class="n">upward</span> <span class="o">=</span> <span class="bp">True</span> <span class="p">);</span><span class="n">R</span><span class="o">.</span><span class="n">value</span>
<span class="go">array([[ 1.,  1.,  1.,  1.],</span>
<span class="go">       [ 2.,  2.,  2.,  2.],</span>
<span class="go">       [ 3.,  3.,  3.,  3.]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="spacegrids.fieldcls.Coord.d">
<tt class="descname">d</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/spacegrids/fieldcls.html#Coord.d"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.fieldcls.Coord.d" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates width of grid cell in direction of Coord (self) using the dual of self (e.g. zt_edges).</p>
<p>Yields grid cell widths. Can be used to compute volumes.</p>
<p>To be overriden in x and y direction to accomodate for sphere.</p>
<p>Calculates self.dual.delta_dist() where it is defined</p>
<dl class="docutils">
<dt>Returns:</dt>
<dd>Field: containing the distances between the adjacent coord cell edges.</dd>
<dt>See also: </dt>
<dd>delta_dist method
der method
dist method 
vol method</dd>
</dl>
<p>Examples:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">coord1</span> <span class="o">=</span> <span class="n">sg</span><span class="o">.</span><span class="n">fieldcls</span><span class="o">.</span><span class="n">Coord</span><span class="p">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">&#39;test1&#39;</span><span class="p">,</span><span class="n">direction</span> <span class="o">=</span><span class="s">&#39;X&#39;</span><span class="p">,</span><span class="n">value</span> <span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span><span class="mf">2.</span><span class="p">,</span><span class="mf">3.</span><span class="p">]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">coord1_edges</span> <span class="o">=</span> <span class="n">sg</span><span class="o">.</span><span class="n">fieldcls</span><span class="o">.</span><span class="n">Coord</span><span class="p">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">&#39;test1_edges&#39;</span><span class="p">,</span><span class="n">direction</span> <span class="o">=</span><span class="s">&#39;X&#39;</span><span class="p">,</span><span class="n">value</span> <span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">1.5</span><span class="p">,</span><span class="mf">2.5</span><span class="p">,</span><span class="mf">3.5</span><span class="p">]),</span> <span class="n">dual</span> <span class="o">=</span> <span class="n">coord1</span> <span class="p">)</span> <span class="c"># specifying the dual here registers coord1_edges also as the dual attribute of coord1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">coord1</span><span class="o">.</span><span class="n">d</span><span class="p">()</span><span class="o">.</span><span class="n">value</span>    <span class="c"># the distance between the cell edges</span>
<span class="go">array([ 1.,  1.,  1.])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="spacegrids.fieldcls.Coord.delta_dist">
<tt class="descname">delta_dist</tt><big>(</big><em>fact=1.0</em><big>)</big><a class="reference internal" href="_modules/spacegrids/fieldcls.html#Coord.delta_dist"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.fieldcls.Coord.delta_dist" title="Permalink to this definition">¶</a></dt>
<dd><p>Method to calculate the distance between adjacent elements of Coord.
Appropriate to vertical direction.
To be over-ridden for hor coords x,y =&gt; derive classes XCoord, YCoord</p>
<p>Calls dist method and applies trans method.</p>
<p>Returns an array as len(result) == len(grid)-1</p>
<p>Calculates self.trans(self.dist())*fact</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>fact: (float) magnification factor if required (e.g. radius of Earth).</dd>
<dt>Returns:</dt>
<dd>Field: containing the distances between the adjacent coord points (i.e. i and i+1).</dd>
<dt>See also:</dt>
<dd>d method 
der method
dist method 
vol method</dd>
</dl>
<p>Examples:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">coord1</span> <span class="o">=</span> <span class="n">sg</span><span class="o">.</span><span class="n">fieldcls</span><span class="o">.</span><span class="n">Coord</span><span class="p">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">&#39;test1&#39;</span><span class="p">,</span><span class="n">direction</span> <span class="o">=</span><span class="s">&#39;X&#39;</span><span class="p">,</span><span class="n">value</span> <span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span><span class="mf">2.</span><span class="p">,</span><span class="mf">3.</span><span class="p">])</span> <span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">R</span> <span class="o">=</span> <span class="n">coord1</span><span class="o">.</span><span class="n">delta_dist</span><span class="p">();</span><span class="n">R</span><span class="o">.</span><span class="n">value</span>
<span class="go">array([ nan,   1.,   1.])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="spacegrids.fieldcls.Coord.der">
<tt class="descname">der</tt><big>(</big><em>F</em><big>)</big><a class="reference internal" href="_modules/spacegrids/fieldcls.html#Coord.der"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.fieldcls.Coord.der" title="Permalink to this definition">¶</a></dt>
<dd><p>Coord derivative method on Field argument F.</p>
<p>If Coord non-cyclical, the first derivative element is nan and the second is the derivative at the first element of the original Coord.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>F: (Field) Field to take derivative of</dd>
<dt>Returns:</dt>
<dd>Field on same grid containing the derivative.</dd>
<dt>Raises:</dt>
<dd>ValueError: when Coord (self) is not in F.grid (grid of Field).</dd>
<dt>See also:</dt>
<dd>d method 
delta_dist method
dist method 
vol method</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="spacegrids.fieldcls.Coord.dist">
<tt class="descname">dist</tt><big>(</big><em>fact=1.0</em><big>)</big><a class="reference internal" href="_modules/spacegrids/fieldcls.html#Coord.dist"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.fieldcls.Coord.dist" title="Permalink to this definition">¶</a></dt>
<dd><p>Distance (signed) along Coord from a certain fixed point (e.g. from ocean surface or from equator along y-direction).</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>fact: (float) magnification factor if required (e.g. radius of Earth).</dd>
<dt>Returns:</dt>
<dd>Field on rid self**2 containing factor*self.value as value. Represents distances of points from a certain point along Coord.</dd>
<dt>See also:</dt>
<dd>d method 
delta_dist method
der method
vol method</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="spacegrids.fieldcls.Coord.eq_index">
<tt class="descname">eq_index</tt><big>(</big><em>grid</em><big>)</big><a class="reference internal" href="_modules/spacegrids/fieldcls.html#Coord.eq_index"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.fieldcls.Coord.eq_index" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="spacegrids.fieldcls.Coord.finer">
<tt class="descname">finer</tt><big>(</big><em>factor=5.0</em><big>)</big><a class="reference internal" href="_modules/spacegrids/fieldcls.html#Coord.finer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.fieldcls.Coord.finer" title="Permalink to this definition">¶</a></dt>
<dd><p>Method of Coord. Refine the coordinate point interval by a given factor.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>factor: (float) factor by which to refined Coord value.</dd>
<dt>Returns:</dt>
<dd>Coord with value refined according to factor.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="spacegrids.fieldcls.Coord.flip">
<tt class="descname">flip</tt><big>(</big><em>F</em><big>)</big><a class="reference internal" href="_modules/spacegrids/fieldcls.html#Coord.flip"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.fieldcls.Coord.flip" title="Permalink to this definition">¶</a></dt>
<dd><p>Reverse order of elements along axis of this Coord (a mirror, or flip).</p>
<p>Grid remains unchanged: strictly, this will lead to an inconsistency between the Field data and the grid, assuming this is what the user wants.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>F: (Field) Field to mirror</dd>
<dt>Returns:</dt>
<dd>Field of equal dimension, mirrored along Coord.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="spacegrids.fieldcls.Coord.give_axis">
<tt class="descname">give_axis</tt><big>(</big><em>axis</em><big>)</big><a class="reference internal" href="_modules/spacegrids/fieldcls.html#Coord.give_axis"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.fieldcls.Coord.give_axis" title="Permalink to this definition">¶</a></dt>
<dd><p>Give axis attribute value and set equivalence to axis.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>axis: (Ax) the axis to provide</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="spacegrids.fieldcls.Coord.give_dual">
<tt class="descname">give_dual</tt><big>(</big><em>dual=None</em><big>)</big><a class="reference internal" href="_modules/spacegrids/fieldcls.html#Coord.give_dual"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.fieldcls.Coord.give_dual" title="Permalink to this definition">¶</a></dt>
<dd><p>Provide Coord with dual Coord (e.g. latitude vs latitude_edges).</p>
<p>If Coord is provided, dual attribute will be set to that Coord and vice versa. Called upon initialization, and therefore by copy method.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>dual: (Coord or None) Coord to make dual</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="spacegrids.fieldcls.Coord.roll">
<tt class="descname">roll</tt><big>(</big><em>shift=0</em><big>)</big><a class="reference internal" href="_modules/spacegrids/fieldcls.html#Coord.roll"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.fieldcls.Coord.roll" title="Permalink to this definition">¶</a></dt>
<dd><p>Yields copy of Coord (self) with value shifted by (int) argument shift using numpy.roll().</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>shift: (int) number of array positions to shift by</dd>
<dt>Returns:</dt>
<dd>Coord: shifted Coord.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="spacegrids.fieldcls.Coord.same">
<tt class="descname">same</tt><big>(</big><em>other</em><big>)</big><a class="reference internal" href="_modules/spacegrids/fieldcls.html#Coord.same"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.fieldcls.Coord.same" title="Permalink to this definition">¶</a></dt>
<dd><p>Coord method to check whether this Coord has identical main attributes (except units) to argument other Coord.</p>
<p>The axis attributes may sometimes be a str. In this case, == is applied and a warning is issued.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>other: (Coord) Coord to check against</dd>
<dt>Returns:</dt>
<dd>True/ False</dd>
<dt>Attributes checked:</dt>
<dd>value: via Coord array_equal method
name: via str ==
axis: same method if Ax object, str == otherwise (axis attribute can sometimes str by choice, although this is not great)
direction: via str == method</dd>
<dt>See also:</dt>
<dd>samein method
same_index method</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="spacegrids.fieldcls.Coord.sliced">
<tt class="descname">sliced</tt><big>(</big><em>slice_obj=None</em>, <em>suffix='_sliced'</em>, <em>slice_dual=True</em><big>)</big><a class="reference internal" href="_modules/spacegrids/fieldcls.html#Coord.sliced"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.fieldcls.Coord.sliced" title="Permalink to this definition">¶</a></dt>
<dd><p>Create new sliced Coord and dual with sliced value.</p>
<p>Also slices &#8216;strings&#8217; attribute if set.</p>
<p>Sliced Coord object and possible dual are not registered with cstack. The sliced dual Coord can be accessed via the sliced Coord.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>slice_obj: (slice object) to slice value with
suffix: (str) suffix to use for sliced Coord 
slice_dual: (Boolean) determines whether dual Coord is sliced too</dd>
<dt>Returns:</dt>
<dd>Coord object containing sliced value, or self if slice(None,None,None)</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="spacegrids.fieldcls.Coord.sort">
<tt class="descname">sort</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/spacegrids/fieldcls.html#Coord.sort"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.fieldcls.Coord.sort" title="Permalink to this definition">¶</a></dt>
<dd><p>Sorts Coord value. Passes arguments on to Numpy sort method.</p>
</dd></dl>

<dl class="method">
<dt id="spacegrids.fieldcls.Coord.start_zero">
<tt class="descname">start_zero</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/spacegrids/fieldcls.html#Coord.start_zero"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.fieldcls.Coord.start_zero" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a copy of this Coord where the coordinate values start at 0.</p>
<p>This is achieved by subtraction of self.value[0] from self.value</p>
</dd></dl>

<dl class="method">
<dt id="spacegrids.fieldcls.Coord.sum">
<tt class="descname">sum</tt><big>(</big><em>F</em>, <em>land_nan=True</em><big>)</big><a class="reference internal" href="_modules/spacegrids/fieldcls.html#Coord.sum"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.fieldcls.Coord.sum" title="Permalink to this definition">¶</a></dt>
<dd><p>Method of Coord  that sums Field F along self Coord direction. Not weighted with grid cell width. Uses masked arrays to handle nan values. nan values can be used to eliminate areas from summing area.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>F: (Field) field of certain dimension n to sum
land_nan: (Boolean)</dd>
<dt>Returns:</dt>
<dd>Field of dimension n-1 or float if n=1.</dd>
<dt>Raises:</dt>
<dd>ValueError: when Coord (self) is not in F.grid (grid of Field).</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="spacegrids.fieldcls.Coord.trans">
<tt class="descname">trans</tt><big>(</big><em>F</em><big>)</big><a class="reference internal" href="_modules/spacegrids/fieldcls.html#Coord.trans"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.fieldcls.Coord.trans" title="Permalink to this definition">¶</a></dt>
<dd><p>Gives the change in Field F upon a Coord shift of 1 index in the direction of the self Coord.</p>
<p>F - self.coord_shift(F,shift=1,keepgrid = True)</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>F: (Field) field to act on</dd>
<dt>Returns:</dt>
<dd>Field: the transformed Field.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="spacegrids.fieldcls.Coord.vcumsum">
<tt class="descname">vcumsum</tt><big>(</big><em>F</em>, <em>upward=True</em><big>)</big><a class="reference internal" href="_modules/spacegrids/fieldcls.html#Coord.vcumsum"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.fieldcls.Coord.vcumsum" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute cumulative sum, weighted with grid cell width, of input Field F along axis of F corresponding to this Coord object.</p>
<blockquote>
<div>If argument upward is set to true, summing takes place with increasing array index. If it is set to False, summing takes place with decreasing array index starting at index -1. Values of nan are set to 0, and therefore not counted. Calls cumsum method. See cumsum.  For grids with grid cell width depending on coordinates, use corresponding Gr methods.</div></blockquote>
<p>Calculation is self.cumsum(F*(self.vol(F.grid)) )</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>F: (Field) Field to sum
upward: (Boolean) flag to set direction of cumsum
land_nan: (Boolean) flag to set land to nan in the resulting array</dd>
<dt>Returns:</dt>
<dd>Field on same grid containing the cumsum.</dd>
<dt>Raises:</dt>
<dd>ValueError: when Coord (self) is not in F.grid (grid of Field).</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="spacegrids.fieldcls.Coord.vol">
<tt class="descname">vol</tt><big>(</big><em>gr</em><big>)</big><a class="reference internal" href="_modules/spacegrids/fieldcls.html#Coord.vol"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.fieldcls.Coord.vol" title="Permalink to this definition">¶</a></dt>
<dd><p>Generalized volume method related to .d() method: self.d() if self in gr, None otherwise.</p>
<p>Determines widths of cells along self Coord. grid argument acts as filter: aborts if self not in grid. The grid argument becomes much more critical in some derived classes (e.g. XCoord), where auxhiliary coordinates are picked from Gr and need to be present.</p>
<p>See .d() method.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>gr: (Gr) grid to test against.</dd>
<dt>Returns:</dt>
<dd>Field or None: self.d() if self in gr, None otherwise.</dd>
<dt>Raises:</dt>
<dd>ValueError: when Coord not in argument gr (so get this right in your scripts).</dd>
<dt>See also: </dt>
<dd>d method 
delta_dist method
der method
dist method</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="spacegrids.fieldcls.Coord.vsum">
<tt class="descname">vsum</tt><big>(</big><em>F</em><big>)</big><a class="reference internal" href="_modules/spacegrids/fieldcls.html#Coord.vsum"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.fieldcls.Coord.vsum" title="Permalink to this definition">¶</a></dt>
<dd><p>Method of Coord .
Sums Field along self Coord, weighted with grid cell width (using self.d(), called by self.vol(F.grid)). Note: due to possible dependence of one Coord on the other, only use mean method of grid. There is no mean method for Coord objects.</p>
<p>Method of Coord  that sums Field F along self Coord direction, weighted with the grid cell width. Calls sum method. See sum method.</p>
<p>Calculation is self.sum(F*(self.vol(F.grid))). For grids with grid cell width depending on coordinates, use corresponding Gr methods.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>F: (Field) field of certain dimension n to sum</dd>
<dt>Returns:</dt>
<dd>Field of dimension n-1 or float if n=1.</dd>
<dt>Raises:</dt>
<dd>ValueError: when Coord (self) is not in F.grid (grid of Field).</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="spacegrids.fieldcls.Coord.weaksame">
<tt class="descname">weaksame</tt><big>(</big><em>other</em><big>)</big><a class="reference internal" href="_modules/spacegrids/fieldcls.html#Coord.weaksame"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.fieldcls.Coord.weaksame" title="Permalink to this definition">¶</a></dt>
<dd><p>Tests whether Coord objects contain identical Coord values, name and direction.</p>
<p>Overrides Directional weaksame method and is a stronger condition.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>other: (Coord) object to compare against.</dd>
<dt>Returns: </dt>
<dd>True/ False</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="spacegrids.fieldcls.Coord.write">
<tt class="descname">write</tt><big>(</big><em>path=None</em>, <em>name=None</em>, <em>history='Created from Spacegrids '</em><big>)</big><a class="reference internal" href="_modules/spacegrids/fieldcls.html#Coord.write"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.fieldcls.Coord.write" title="Permalink to this definition">¶</a></dt>
<dd><p>Writes Coord data to Netcdf file.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>path: (str) path to the directory where the file will go (e.g. &#8216;data/&#8217; or &#8216;/home/me/&#8217;, default pwd).
name: (str) file name (e.g. &#8220;foo.nc&#8221;)
history: (str) Brief history or general description of the data.
insert_dual: (Boolean) Flag determining whether to include the duals of the Coord objects in the file.</dd>
<dt>Returns:</dt>
<dd>None</dd>
</dl>
<p>No error is raised in case of problems (only a message is displayed).</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="spacegrids.fieldcls.Field">
<em class="property">class </em><tt class="descclassname">spacegrids.fieldcls.</tt><tt class="descname">Field</tt><big>(</big><em>name</em>, <em>value</em>, <em>grid</em>, <em>units='?'</em>, <em>direction=None</em>, <em>strict_v=True</em>, <em>long_name='?'</em>, <em>metadata={}</em>, <em>squeezed_dims=()</em><big>)</big><a class="reference internal" href="_modules/spacegrids/fieldcls.html#Field"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.fieldcls.Field" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spacegrids.abstract.Valued" title="spacegrids.abstract.Valued"><tt class="xref py py-class docutils literal"><span class="pre">spacegrids.abstract.Valued</span></tt></a></p>
<p>Represents a dataset defined on a grid.</p>
<p>Field objects contain a grid (a Gr object) attribute and a ndarray value attribute of data defined on that grid.</p>
<p>The call method allows fields to act as function defined on grid objects.
For a 2D scalar corresponding to Field T, say defined on grid yt*xt, T(dy*dx) yields a 2D array of the scalar values.</p>
<p>If Field T is naturally defined on grid yt*xt, then T(zt*yt*xt) yields a 3D array b such that b[k,:,:] = T(yt*xt) for all possible k.</p>
<p>If g is a Gr (grid) or Coord object, left or right multiplication of a Field  object F with Gr Coord results in the grid-cell width weighted summing of the Field over the coords in the multiplicant g (integration, via g.vsum method), resulting in a smaller dimension Field.</p>
<p>If g is a Coord object, g.der(F) yields the derivative of F along g. g.vcumsum(F) yields the grid cell width-weight cumulative sum of F over g.</p>
<p>Shortcuts: if g is a Coord object, g^F yields the derivative of F along g (via g.der method). g|F yields the grid cell width-weight cumulative sum of F over g (primitive, via g.vcumsum).</p>
<p>two fields F1, F2 are considered weakly the same, F1.weaksame(F2) yields True, when their name, value (an numpy array) and Gr (grid) attribute are equal, unless they contain nan values.</p>
<p>NOTE: multiplication works a bit different from addition at the moment. Addition will go ahead even when coords in the grids are differently named (or have other non-value attributes differ) as long as the value (the coord points) are the same: then the (left and right) coords are considered equal. Multiplication treats them as different coords in this case.</p>
<dl class="method">
<dt id="spacegrids.fieldcls.Field.cat">
<tt class="descname">cat</tt><big>(</big><em>other</em>, <em>ax=None</em>, <em>name_suffix='_cat'</em><big>)</big><a class="reference internal" href="_modules/spacegrids/fieldcls.html#Field.cat"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.fieldcls.Field.cat" title="Permalink to this definition">¶</a></dt>
<dd><p>Concatenate with another Field along specified axis.</p>
<p>If ax is None, concatenation takes place along the first encountered common axis with non-equal values.
Grids must be orient along same axes and in same axis order.</p>
<p>Concatenation along direction with same Coord values for both fields leads to the right (other) Field being returned (don&#8217;t use this).</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>other: (Field) to concatenate with
ax: (Ax) axis to concatenate along.
name_suffix: (str) suffix to use in new name.</dd>
<dt>Returns:</dt>
<dd>the concatenated Field.</dd>
<dt>Raises:</dt>
<dd>ValueError: if Field objects not on grids pointing in same directions,  pieces not of consistent dimensions.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="spacegrids.fieldcls.Field.dV">
<tt class="descname">dV</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/spacegrids/fieldcls.html#Field.dV"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.fieldcls.Field.dV" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns Field of same dimension containing ndarray of grid cell volumes, with field nan values (often representing land) set to nan.</p>
</dd></dl>

<dl class="method">
<dt id="spacegrids.fieldcls.Field.der">
<tt class="descname">der</tt><big>(</big><em>ax</em><big>)</big><a class="reference internal" href="_modules/spacegrids/fieldcls.html#Field.der"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.fieldcls.Field.der" title="Permalink to this definition">¶</a></dt>
<dd><p>Calls Ax.der on self.</p>
</dd></dl>

<dl class="method">
<dt id="spacegrids.fieldcls.Field.draw">
<tt class="descname">draw</tt><big>(</big><em>colorbar=True</em>, <em>index=0</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/spacegrids/fieldcls.html#Field.draw"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.fieldcls.Field.draw" title="Permalink to this definition">¶</a></dt>
<dd><p>Quick plot of this Field using the most obvious layout etc.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>colorbar: (Boolean) add colorbar if True
index: (int) index value at which to slice if Field dim &gt; 2
<a href="#id12"><span class="problematic" id="id13">**</span></a>kwargs: further kwargs to be passed on</dd>
<dt>Returns:</dt>
<dd>h, cb: handles to figure and colorbar</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="spacegrids.fieldcls.Field.floodfill">
<tt class="descname">floodfill</tt><big>(</big><em>node=(0</em>, <em>0)</em>, <em>boundary_value=nan</em>, <em>xmin=0</em>, <em>xmax=10000</em>, <em>ymin=0</em>, <em>ymax=10000</em><big>)</big><a class="reference internal" href="_modules/spacegrids/fieldcls.html#Field.floodfill"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.fieldcls.Field.floodfill" title="Permalink to this definition">¶</a></dt>
<dd><p>Fill array (e.g. ocean) from node up to boundary defined by boundary_value (e.g. land) using floodfill.</p>
<p>Creates mask Field to fill array (e.g. ocean) in area contained within boundary_value (e.g. land), containing node.</p>
<p>At the moment only to be used on 2 dimensional Fields.</p>
<p>The node argument can be in hybrid, e.g. (X,10,Y,4), or normal, e.g. (10,4), notation.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>node: (2 tuple of int or Ax/ Coord vs int) coordinates of starting point
boundary_value: (float or nan) value of the boundary of the filled domain
xmin: (int) set mask to boundary value up to this x-index
xmax: (int) set mask to boundary value from this x-index
ymin: (int) set mask to boundary value up to this y-index
ymax: (int) set mask to boundary value from this y-index</dd>
<dt>Returns:</dt>
<dd>Field containing 2 dimension ndarray int mask of filled values</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="spacegrids.fieldcls.Field.get_value">
<tt class="descname">get_value</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/spacegrids/fieldcls.html#Field.get_value"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.fieldcls.Field.get_value" title="Permalink to this definition">¶</a></dt>
<dd><p>Obtain value of Field.</p>
</dd></dl>

<dl class="method">
<dt id="spacegrids.fieldcls.Field.maskout">
<tt class="descname">maskout</tt><big>(</big><em>node=(0</em>, <em>0)</em>, <em>boundary_value=nan</em>, <em>msk_val=nan</em>, <em>xmin=0</em>, <em>xmax=10000</em>, <em>ymin=0</em>, <em>ymax=10000</em>, <em>isurface=0</em>, <em>mask_filter=1</em><big>)</big><a class="reference internal" href="_modules/spacegrids/fieldcls.html#Field.maskout"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.fieldcls.Field.maskout" title="Permalink to this definition">¶</a></dt>
<dd><p>Mask out area outside boundary using floodfill method.</p>
<p>Creates Field with all values outside the boundary containing the node point filled with msk_val.</p>
<p>The node argument can be in hybrid, e.g. (X,10,Y,4), or normal, e.g. (10,4), notation. The hybrid notation is required for Field dimension &gt; 2.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>node: (2 tuple of int or Ax/ Coord vs int) coordinates of starting point
boundary_value: (float or nan) value of the boundary of the filled domain
msk_val: (float or nan) value to assign to all points outside boundary
xmin: (int) set mask to boundary value up to this x-index
xmax: (int) set mask to boundary value from this x-index
ymin: (int) set mask to boundary value up to this y-index
ymax: (int) set mask to boundary value from this y-index
isurface: (int) slice of surface (usually 0, but -1 in some cases)
mask_filter: (int) value to keep in mask from floodfill (keep default)</dd>
<dt>Returns:</dt>
<dd>Field with array nodes that are outside boundary set to msk_val</dd>
<dt>Raises:</dt>
<dd>ValueError for Fields of dimension less than 2</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="spacegrids.fieldcls.Field.mean">
<tt class="descname">mean</tt><big>(</big><em>grid=None</em><big>)</big><a class="reference internal" href="_modules/spacegrids/fieldcls.html#Field.mean"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.fieldcls.Field.mean" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate grid cell volumes-weighted mean.</p>
<p>Calls sum method with grid argument and dV method.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>grid: (Gr) to calculate means over.</dd>
<dt>Returns:</dt>
<dd>Lower dim Field if grid subgrid of self.grid or float if equal.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="spacegrids.fieldcls.Field.ones">
<tt class="descname">ones</tt><big>(</big><em>nan_val=nan</em><big>)</big><a class="reference internal" href="_modules/spacegrids/fieldcls.html#Field.ones"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.fieldcls.Field.ones" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns Field containing domain of this Field: values are 1 in grid locations where Field is defined, nan otherwise. This can be useful for mask creation and the like.</p>
</dd></dl>

<dl class="method">
<dt id="spacegrids.fieldcls.Field.regrid">
<tt class="descname">regrid</tt><big>(</big><em>grid</em>, <em>method='linear'</em><big>)</big><a class="reference internal" href="_modules/spacegrids/fieldcls.html#Field.regrid"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.fieldcls.Field.regrid" title="Permalink to this definition">¶</a></dt>
<dd><p>Regrid (interpolate) Field (self) to grid.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>grid: (Gr) grid to regrid to.
method: (str) interpolation method to use.</dd>
<dt>Returns:</dt>
<dd>Interpolated Field defined on grid from argument.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="spacegrids.fieldcls.Field.roll">
<tt class="descname">roll</tt><big>(</big><em>shift</em>, <em>crd</em><big>)</big><a class="reference internal" href="_modules/spacegrids/fieldcls.html#Field.roll"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.fieldcls.Field.roll" title="Permalink to this definition">¶</a></dt>
<dd><p>Rolls Field along Coord.</p>
<p>Call roll function on self.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>shift: (int) number of index points to roll by
crd: (Coord) coord to shift on</dd>
<dt>Returns:</dt>
<dd>Field: containing the shifted value and grid.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="spacegrids.fieldcls.Field.set_value">
<tt class="descname">set_value</tt><big>(</big><em>k</em>, <em>v</em><big>)</big><a class="reference internal" href="_modules/spacegrids/fieldcls.html#Field.set_value"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.fieldcls.Field.set_value" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="spacegrids.fieldcls.Field.slice_by">
<tt class="descname">slice_by</tt><big>(</big><em>sl_coord=None</em>, <em>slice_obj=slice(1</em>, <em>None</em>, <em>None)</em><big>)</big><a class="reference internal" href="_modules/spacegrids/fieldcls.html#Field.slice_by"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.fieldcls.Field.slice_by" title="Permalink to this definition">¶</a></dt>
<dd><p>Slice along Coord (e.g. xt) using slice_obj as slice, e.g. slice(1,None,None).</p>
</dd></dl>

<dl class="method">
<dt id="spacegrids.fieldcls.Field.sum">
<tt class="descname">sum</tt><big>(</big><em>grid=None</em><big>)</big><a class="reference internal" href="_modules/spacegrids/fieldcls.html#Field.sum"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.fieldcls.Field.sum" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes sum of Field over grid using masked array (nan is not counted).</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>grid: (Gr) grid to sum over. None means the entire Field grid.</dd>
<dt>Returns:</dt>
<dd>Field containing values summed over grid of smaller dimension, or float if grid is self.grid.</dd>
</dl>
<p>Say self.gr is zt*yt*xt and grid is yt*xt.</p>
<p>Examples:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">K</span><span class="o">.</span><span class="n">grid</span> <span class="c"># take a 2D field</span>
<span class="go">(latitude, longitude)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">KS</span> <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">latitude</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="c"># sum on subgrid latitude**2 (**2 yields grid)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">KS</span><span class="o">.</span><span class="n">grid</span> <span class="c"># the result is a series of sums along longitude.</span>
<span class="go">(longitude)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="spacegrids.fieldcls.Field.transpose">
<tt class="descname">transpose</tt><big>(</big><em>grid=None</em><big>)</big><a class="reference internal" href="_modules/spacegrids/fieldcls.html#Field.transpose"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.fieldcls.Field.transpose" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns Field with view of value array with axes transposed.</p>
<p>Calls Numpy transpose on value.</p>
<p>For a 1-D Field, this has no effect. For a 2-D Field, this is the usual matrix transpose on value and the 2 Gr members switched. For an n-D Field, if an argument grid is given, the Field is regridded to that grid using the regrid method. If axes are not provided and a.shape = (i[0],i[1], ... , i[n-1]), then a.transpose().shape = (i[n-1],i[n-2], ... ,i[1],i[0]), and the grid members are reversed accordingly.</p>
<p>See the Numpy .transpose method.</p>
<p>Note that grid-data consistency is forced in spacegrids, and so no method exists to transpose without affecting the grid.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>grid: (Gr) optional. The grid to which to transpose</dd>
<dt>Returns:</dt>
<dd>Field containing transposed value and re-arranged grid.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="spacegrids.fieldcls.Field.vcumsum">
<tt class="descname">vcumsum</tt><big>(</big><em>coord</em>, <em>upward=True</em><big>)</big><a class="reference internal" href="_modules/spacegrids/fieldcls.html#Field.vcumsum"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.fieldcls.Field.vcumsum" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply vcumsum method of coord on Field.</p>
<p>See Coord.vcumsum</p>
</dd></dl>

<dl class="method">
<dt id="spacegrids.fieldcls.Field.vol">
<tt class="descname">vol</tt><big>(</big><em>grid=None</em><big>)</big><a class="reference internal" href="_modules/spacegrids/fieldcls.html#Field.vol"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.fieldcls.Field.vol" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute total volume (area/ length) of non-nan grid cells.</p>
<p>Uses sum method, see sum.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>grid: (Gr) to use in sum method.  None means the entire Field grid.</dd>
<dt>Returns:</dt>
<dd>float: the total volume.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="spacegrids.fieldcls.Field.vsum">
<tt class="descname">vsum</tt><big>(</big><em>grid=None</em><big>)</big><a class="reference internal" href="_modules/spacegrids/fieldcls.html#Field.vsum"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.fieldcls.Field.vsum" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute grid cell volume-weighted sum of Field.</p>
<p>Calls sum. Method sum uses masked arrays. See sum.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>grid: (Gr) grid to sum over.  None means the entire Field grid.</dd>
<dt>Returns:</dt>
<dd>Field containing values summed over grid of smaller dimension, or float if grid is self.grid.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="spacegrids.fieldcls.Field.weaksame">
<tt class="descname">weaksame</tt><big>(</big><em>other</em><big>)</big><a class="reference internal" href="_modules/spacegrids/fieldcls.html#Field.weaksame"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.fieldcls.Field.weaksame" title="Permalink to this definition">¶</a></dt>
<dd><p>Tests whether fields contain equal name, value and grid. At the moment, if the value contains nan, this function will return false.</p>
</dd></dl>

<dl class="method">
<dt id="spacegrids.fieldcls.Field.write">
<tt class="descname">write</tt><big>(</big><em>path=None</em>, <em>name=None</em>, <em>history='Created from Spacegrids '</em>, <em>insert_dual=True</em>, <em>force_squeeze=False</em><big>)</big><a class="reference internal" href="_modules/spacegrids/fieldcls.html#Field.write"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.fieldcls.Field.write" title="Permalink to this definition">¶</a></dt>
<dd><p>Write method of Field .</p>
<p>Creates Netcdf file and writes Field to it, along with its Coord objects.</p>
<p>Fields are unsqueezed before saving, along Coord objects of single length to be saved as well (override with force_squeeze = True).</p>
<p>If path and name are not specified, the file will be located in the working directory.
If only name is specified, the file will be in the wd under that name
If path is specified, the wd is replaced by the path in the above 2 scenarios.</p>
<p>insert_dual determines whether the edges of a the Coord objects are saved as well (the default).</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>path: (str) path to the directory containing the file.
name: (str) filename, to be joined with path.
history: (str) description of file.
insert_dual: (Boolean) insert the dual Coord objects as well if True
force_squeeze: (Boolean) do not call unsqueeze method if True</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="spacegrids.fieldcls.GetId">
<em class="property">class </em><tt class="descclassname">spacegrids.fieldcls.</tt><tt class="descname">GetId</tt><a class="reference internal" href="_modules/spacegrids/fieldcls.html#GetId"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.fieldcls.GetId" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Define the scalar axis via a lazy class. Then ID*X = X etc.</p>
</dd></dl>

<dl class="class">
<dt id="spacegrids.fieldcls.Gr">
<em class="property">class </em><tt class="descclassname">spacegrids.fieldcls.</tt><tt class="descname">Gr</tt><big>(</big><em>name='scalar'</em>, <em>long_name=''</em><big>)</big><a class="reference internal" href="_modules/spacegrids/fieldcls.html#Gr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.fieldcls.Gr" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">tuple</span></tt>, <a class="reference internal" href="#spacegrids.abstract.Membered" title="spacegrids.abstract.Membered"><tt class="xref py py-class docutils literal"><span class="pre">spacegrids.abstract.Membered</span></tt></a></p>
<p>The Gr (grid) class represents Coord grids. A Gr object consists of a tuple of Coord objects, with additional Membered and other methods.</p>
<p>Gr object behave like tuples of Coord objects, and indexing is done as in tuples: if g = Gr((coord1,coord2)), then g[0] is coord1 etc.</p>
<p>The multiplication methods of Coord and Gr objects are such that Gr objects can be built via multiplication as follows: coord1*coord2 yields Gr((coord1,coord2)) etc. For instance, depth*latitude*longitude represents a 3 dimensional grid, and is essentially a Coord tuple of length 3 with extra methods.</p>
<p>Gr objects g1 and g2 are considered weaksame, g1.weaksame(g2) yields True, when the individual Coord elements are weaksame.</p>
<dl class="method">
<dt id="spacegrids.fieldcls.Gr.array_equal">
<tt class="descname">array_equal</tt><big>(</big><em>other</em><big>)</big><a class="reference internal" href="_modules/spacegrids/fieldcls.html#Gr.array_equal"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.fieldcls.Gr.array_equal" title="Permalink to this definition">¶</a></dt>
<dd><p>Grid component-wise test whether the Coord objects contain the same grid point location values. Input another grid.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>other: (Gr) grid to compare with.</dd>
<dt>Returns:</dt>
<dd>List. List element corresponds to Coord in Gr and is True if Coord.array_equal True, False otherwise.</dd>
<dt>Raises:</dt>
<dd>ValueError if Gr objects not defined along same axes. E.g. (X,Y ) vs (Y,Z )</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="spacegrids.fieldcls.Gr.axis">
<tt class="descname">axis</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/spacegrids/fieldcls.html#Gr.axis"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.fieldcls.Gr.axis" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an AxGr object containing the axis properties of the Coord elements of this grid.</p>
</dd></dl>

<dl class="method">
<dt id="spacegrids.fieldcls.Gr.der">
<tt class="descname">der</tt><big>(</big><em>crd</em>, <em>F</em><big>)</big><a class="reference internal" href="_modules/spacegrids/fieldcls.html#Gr.der"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.fieldcls.Gr.der" title="Permalink to this definition">¶</a></dt>
<dd><p>Method of grid object. Often the wider context of the grid needs to be known to take the derivative along a Coord, hence a Gr method.</p>
<p>Finds args to feed Coord member der methods, which is called on F.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>crd: (Coord) along which to differentiate (e.g. latitude)
F: (Field) to differentiate (e.g. temperature)</dd>
<dt>Returns:</dt>
<dd>Field containing the result.</dd>
<dt>Raises:</dt>
<dd>ValueError: when crd not in (self) grid.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="spacegrids.fieldcls.Gr.dual">
<tt class="descname">dual</tt><big>(</big><em>caller</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/spacegrids/fieldcls.html#Gr.dual"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.fieldcls.Gr.dual" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="spacegrids.fieldcls.Gr.expand">
<tt class="descname">expand</tt><big>(</big><em>A</em>, <em>other</em><big>)</big><a class="reference internal" href="_modules/spacegrids/fieldcls.html#Gr.expand"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.fieldcls.Gr.expand" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds dimensions specified in Gr other at the beginning of array A</p>
<dl class="docutils">
<dt>Args: </dt>
<dd>A: (ndarray) of shape consistent with self
other: (Gr) grid to expand over</dd>
<dt>Returns: </dt>
<dd>An ndarray of shape (other/self)*self containing identical copies of A along other/self</dd>
</dl>
<p>Example.</p>
<p>SAT = P[&#8216;DPO&#8217;][&#8216;A_sat&#8217;]
SAT.shape is (100,100)
W=SAT.grid.expand(SAT[:],depth**2)
W.shape is (19,100,100)
W contains 19 identical copies (slices) of SAT[:]</p>
<p>Note that the other grid is appended on the left side.</p>
<p>Example 2.</p>
<p>(zt*yt*xt).shape() is (46, 110, 200)</p>
<p>A = np.ones((xt**2).shape())</p>
<p>K=(xt**2).expand(A,zt*yu*xt  )
K.shape is (46, 110, 200)</p>
<p>K=(xt**2).expand(A,zt*xt*yt  )
K.shape is (46, 110, 200)</p>
<p>Warning: method requires Gr argument, do not use coord argument. Instead, for a single coord (e.g.) xt, use xt**2.</p>
</dd></dl>

<dl class="method">
<dt id="spacegrids.fieldcls.Gr.function">
<tt class="descname">function</tt><big>(</big><em>func</em><big>)</big><a class="reference internal" href="_modules/spacegrids/fieldcls.html#Gr.function"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.fieldcls.Gr.function" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a Field containing the values of function argument func on the grid points defined in this grid.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>func: (function) function defined on domain of same dimension as grid (self).</dd>
<dt>Returns:</dt>
<dd>Field: Evaulated function. The Field name is the name of the function.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="spacegrids.fieldcls.Gr.inflate">
<tt class="descname">inflate</tt><big>(</big><em>type='array'</em>, <em>force=False</em><big>)</big><a class="reference internal" href="_modules/spacegrids/fieldcls.html#Gr.inflate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.fieldcls.Gr.inflate" title="Permalink to this definition">¶</a></dt>
<dd><p>Broadcast members onto (self) grid using their cast method and return list of results.</p>
<p>This method can return the result in two formats: a list of Field objects or of ndarrays. Default behaviour caches values.</p>
<p>Each element in the list corresponds to a Coord member object in the called grid, where the array equals the content of the Coord along the array index corresponding to that Coord, and is constant otherwise.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>type: (str) desired output type. -&#8216;array&#8217; in arguments will return a list of arrays. -&#8216;Field&#8217; in arguments will return a list of fields.
force: (Boolean) do not use cached value if True.</dd>
<dt>Returns: </dt>
<dd>A list of arrays or fields of the dimension of the grid being called.</dd>
</dl>
<p>For example, a grid defined by (yt,xt) (equal to yt*xt) yields [YT,XT] where YT = yt(yt*xt) and XT = XT(yt*xt). We refer to XT as the inflated version of xt. Here, the Coord object has been called on the grid object: this yields an array defined on the argument grid and constant in all Coord axes other than the calling Coord. The array equals the value of the calling Coord object along that axis.</p>
</dd></dl>

<dl class="method">
<dt id="spacegrids.fieldcls.Gr.mean">
<tt class="descname">mean</tt><big>(</big><em>F</em><big>)</big><a class="reference internal" href="_modules/spacegrids/fieldcls.html#Gr.mean"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.fieldcls.Gr.mean" title="Permalink to this definition">¶</a></dt>
<dd><p>Determines mean of Field argument F weighted with grid cell width, returning Field.</p>
<p>Uses vsum</p>
</dd></dl>

<dl class="method">
<dt id="spacegrids.fieldcls.Gr.nbytes">
<tt class="descname">nbytes</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/spacegrids/fieldcls.html#Gr.nbytes"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.fieldcls.Gr.nbytes" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute and return memory usage by this object.</p>
</dd></dl>

<dl class="method">
<dt id="spacegrids.fieldcls.Gr.ones">
<tt class="descname">ones</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/spacegrids/fieldcls.html#Gr.ones"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.fieldcls.Gr.ones" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns Field with value np.nones of shape self.shape.</p>
</dd></dl>

<dl class="method">
<dt id="spacegrids.fieldcls.Gr.regrid">
<tt class="descname">regrid</tt><big>(</big><em>other</em>, <em>method='linear'</em><big>)</big><a class="reference internal" href="_modules/spacegrids/fieldcls.html#Gr.regrid"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.fieldcls.Gr.regrid" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes another Gr object argument and yields a function F from ndarray to ndarray.</p>
<p>The regrid method of a Gr object takes another Gr object, other, and yields a function F. This function F takes an array A and re-arranges the order of   the indices to match the input Gr object (other). If the length of the input object exceeds that of the calling object, F(A) also expands the array along the additional axes by creating copies of it along those axes (using the expand method). Note that the coords of the calling Gr object need to be a subset of the argument Gr object.</p>
<dl class="docutils">
<dt>Args: </dt>
<dd>Other Gr object (grid).</dd>
<dt>Returns: </dt>
<dd>A transformation on fields going from self grid to other grid.</dd>
</dl>
<p>E.g. xt*yt(yt*xt) yields a tranpose operation on an array
xt*yt(xu*yu) yields an interpolation acting on fields.</p>
<p>yt*xt(zt*yt*xt) yields a functions transforming a 2D array corresponding to the values of a Field defined on yt*xt to a 3D array constant in the zt direction.</p>
<p>If self is longer than other, calling will lead to a reduction. E.g.</p>
<p>R=(zt*yt*xt)((yt**2))(A) where A.shape = (len(zt),len(yt),len(xt))
Leads to a list of length len(yt) containing arrays of dimension len(zt) by len(xt).
Then for S=array(R) we get S.shape is (len(yt), len(zt), len(xt))</p>
<p>For R=(zt*yt*xt)((xt*yt))(A) we get a list of lists and S.shape is (len(xt), len(yt), len(zt))
Note that yt,xt appear in different order in self and other.</p>
</dd></dl>

<dl class="method">
<dt id="spacegrids.fieldcls.Gr.shape">
<tt class="descname">shape</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/spacegrids/fieldcls.html#Gr.shape"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.fieldcls.Gr.shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Determines shape of grid by calculating Coord member lengths.</p>
</dd></dl>

<dl class="method">
<dt id="spacegrids.fieldcls.Gr.sliced">
<tt class="descname">sliced</tt><big>(</big><em>slices</em><big>)</big><a class="reference internal" href="_modules/spacegrids/fieldcls.html#Gr.sliced"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.fieldcls.Gr.sliced" title="Permalink to this definition">¶</a></dt>
<dd><p>Create new sliced Gr object.</p>
<p>Calls sliced methods on each Coord member using slice object arguments.</p>
<p>Arguments can be of the form e.g. (slice(1,None,None),slice(1,None,None)slice(1,None,None)) or (X,slice(1,None,None)) etc.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>slices: (tuple or list of) Coord, Ax or slice objects.</dd>
<dt>Returns:</dt>
<dd>A Gr object with sliced Coord members</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="spacegrids.fieldcls.Gr.squeeze">
<tt class="descname">squeeze</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/spacegrids/fieldcls.html#Gr.squeeze"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.fieldcls.Gr.squeeze" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove Coord members of length 1 and return reduced Gr and removed Coord objects as a Gr.</p>
<dl class="docutils">
<dt>Returns:</dt>
<dd>self/squeezed, squeezed for Gr object squeezed containing squeezed Coord objects.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="spacegrids.fieldcls.Gr.to_slices">
<tt class="descname">to_slices</tt><big>(</big><em>A</em>, <em>other</em><big>)</big><a class="reference internal" href="_modules/spacegrids/fieldcls.html#Gr.to_slices"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.fieldcls.Gr.to_slices" title="Permalink to this definition">¶</a></dt>
<dd><p>yields a list of slices along the coords defined in self.</p>
<p>E.g.
zt(zt*yt*xt) = [A[0,:,:],A[1,:,:],...] where A.shape is (zt*yt*xt).shape()</p>
<p>Expects self coords to be subset of other, and appearing in same order in both.
other must appear in the left side of self (i.e. self is self*(other/self)  ).
For instance, zt*yt(zt*yt*xt) is valid,  yt*xt(zt*yt*xt) and zt(yt*xt) are not.
The indexing in the output list (as list of lists) is of opposite order to the Coord elements in self.</p>
<p>No checks are done on consistency between A or other or self and other.</p>
<p>The opposite of expand. Used by call method of fields on Gr objects of lower dimension that the Field.</p>
<dl class="docutils">
<dt>Args: </dt>
<dd>A: (ndarray) to be sliced. Has shape other.shape()
other: (Gr) another larger grid containing self (self members are subset of other)</dd>
<dt>Returns:</dt>
<dd>A list of nparrays being slices of input A along the self Gr.</dd>
</dl>
<p>Note that argument is longer than self. This is opposite to __call__ method, where a longer self leads to a reduction.</p>
</dd></dl>

<dl class="method">
<dt id="spacegrids.fieldcls.Gr.vol">
<tt class="descname">vol</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/spacegrids/fieldcls.html#Gr.vol"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.fieldcls.Gr.vol" title="Permalink to this definition">¶</a></dt>
<dd><p>Determines volumes (areas/ lengths) of grid members, returns Field.</p>
<p>Calls Coord member d method.</p>
<dl class="docutils">
<dt>Returns:</dt>
<dd>Field defined on same (self) grid (therefore of same dimension) containing value ndarray of individual cell volumes.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="spacegrids.fieldcls.Gr.vsum">
<tt class="descname">vsum</tt><big>(</big><em>F</em><big>)</big><a class="reference internal" href="_modules/spacegrids/fieldcls.html#Gr.vsum"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.fieldcls.Gr.vsum" title="Permalink to this definition">¶</a></dt>
<dd><p>Sum weighted with Coord grid cell widths (integration) over self grid.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>F: (Field) to weight-sum over.</dd>
<dt>Returns:</dt>
<dd>Smaller dimensional Field, or float if result dim 0, containing the result.</dd>
</dl>
<p>The returned Field has grid made up of remaining Coord objects or a float. E.g. if F.grid == (&#8216;zt&#8217;,&#8217;yt&#8217;,&#8217;xt&#8217;), (xt*yt).vsum(F) yields a Field defined on grid (&#8216;zt&#8217;,).</p>
<p>Note that when Coord elements with direction attribute &#8216;X&#8217; and &#8216;Y&#8217; both appear in the Gr object, vsum will check whether the &#8216;X&#8217; Coord appears after the &#8216;Y&#8217; Coord. If so, they will be interchanged when performing the calculation as otherwise no y-coord is available when the x grid cell width is required. This is a small detail.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="spacegrids.fieldcls.VField">
<em class="property">class </em><tt class="descclassname">spacegrids.fieldcls.</tt><tt class="descname">VField</tt><big>(</big><em>name='scalar'</em>, <em>long_name=''</em><big>)</big><a class="reference internal" href="_modules/spacegrids/fieldcls.html#VField"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.fieldcls.VField" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">tuple</span></tt>, <a class="reference internal" href="#spacegrids.abstract.Membered" title="spacegrids.abstract.Membered"><tt class="xref py py-class docutils literal"><span class="pre">spacegrids.abstract.Membered</span></tt></a></p>
<p>vector Field. A tuple of fields with extra rules. Allows multiplication.</p>
<dl class="method">
<dt id="spacegrids.fieldcls.VField.der">
<tt class="descname">der</tt><big>(</big><em>caller</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/spacegrids/fieldcls.html#VField.der"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.fieldcls.VField.der" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="spacegrids.fieldcls.VField.direction">
<tt class="descname">direction</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/spacegrids/fieldcls.html#VField.direction"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.fieldcls.VField.direction" title="Permalink to this definition">¶</a></dt>
<dd><p>Method that returns a tuple of the directions of the tuple components of this vector Field by examining these components.</p>
<p>For example, if U.direction is X and V.direction is Y, then (U*V).direction is X*Y</p>
</dd></dl>

<dl class="method">
<dt id="spacegrids.fieldcls.VField.draw">
<tt class="descname">draw</tt><big>(</big><em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/spacegrids/fieldcls.html#VField.draw"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.fieldcls.VField.draw" title="Permalink to this definition">¶</a></dt>
<dd><p>Quick and easy plotting of this object. Only 2D VFields.</p>
</dd></dl>

<dl class="method">
<dt id="spacegrids.fieldcls.VField.innersum">
<tt class="descname">innersum</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/spacegrids/fieldcls.html#VField.innersum"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.fieldcls.VField.innersum" title="Permalink to this definition">¶</a></dt>
<dd><p>Return sum of all members</p>
</dd></dl>

<dl class="method">
<dt id="spacegrids.fieldcls.VField.vcumsum">
<tt class="descname">vcumsum</tt><big>(</big><em>caller</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/spacegrids/fieldcls.html#VField.vcumsum"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.fieldcls.VField.vcumsum" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="spacegrids.fieldcls.VField.vsum">
<tt class="descname">vsum</tt><big>(</big><em>caller</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/spacegrids/fieldcls.html#VField.vsum"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.fieldcls.VField.vsum" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="spacegrids.fieldcls.XCoord">
<em class="property">class </em><tt class="descclassname">spacegrids.fieldcls.</tt><tt class="descname">XCoord</tt><big>(</big><em>name='scalar'</em>, <em>value=array([0])</em>, <em>dual=None</em>, <em>axis='?'</em>, <em>direction='scalar'</em>, <em>units=None</em>, <em>long_name='?'</em>, <em>metadata={}</em>, <em>strings=None</em>, <em>associative=None</em><big>)</big><a class="reference internal" href="_modules/spacegrids/fieldcls.html#XCoord"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.fieldcls.XCoord" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spacegrids.fieldcls.Coord" title="spacegrids.fieldcls.Coord"><tt class="xref py py-class docutils literal"><span class="pre">spacegrids.fieldcls.Coord</span></tt></a></p>
<p>Specialized Coord class for representing longitudinal direction in spherical coordinates. A re-entrant geometry is assumed. See Coord.</p>
<p>The XCoord class contains methods related to distances, with the following dependencies. dist and delta_dist are fundamental (no link, in contrast to Coord). The rest is the same as Coord: der depends on dist. d depends on dual Coord and delta_dist. vol depends on d.</p>
<dl class="method">
<dt id="spacegrids.fieldcls.XCoord.coord_shift">
<tt class="descname">coord_shift</tt><big>(</big><em>F</em>, <em>shift</em>, <em>keepgrid=False</em><big>)</big><a class="reference internal" href="_modules/spacegrids/fieldcls.html#XCoord.coord_shift"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.fieldcls.XCoord.coord_shift" title="Permalink to this definition">¶</a></dt>
<dd><p>XCoord method that shifts the coordinates and value of a field by a number of indices.</p>
<p>Overides Coord coord_shift method. Here, mask is False, so that the array elements are (1D) rotated: this is the simple way in which this method differs from its Coord counterpart.</p>
<p>Note that because this method overrides, the trans method also behaves differently because it calls coord_shift, even though the trans method itself is not overriden!</p>
<p>The shifted Coord in the grid of the Field argument is replaced with a (different) shifted Coord: disable this behaviour with argument keepgrid = True. Calls roll function.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>F: (Field) field to shift
shift: (int) magnitude (corresponding to array index) of shift
keepgrid: (Boolean, default False) grid not updated if True</dd>
<dt>Returns:</dt>
<dd>The shifted Field, where elements at the very beginning or end of the value array re-appear at the other side of the array (1D-rotation).</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="spacegrids.fieldcls.XCoord.d">
<tt class="descname">d</tt><big>(</big><em>y_coord</em><big>)</big><a class="reference internal" href="_modules/spacegrids/fieldcls.html#XCoord.d"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.fieldcls.XCoord.d" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Calculates width of grid cell in direction of XCoord (self) using the dual of self (e.g. xt_edges).</p>
<p>Yields grid cell widths. Can be used to compute volumes.</p>
<p>Overides the d method of the Coord class.</p>
<p>Calculates self.dual.delta_dist() where it is defined</p>
</div></blockquote>
<dl class="docutils">
<dt>Args:</dt>
<dd><blockquote class="first">
<div>y_coord: (YCoord) latitudinal coordinate positions (usually component in grid context).</div></blockquote>
<dl class="docutils">
<dt>Returns:</dt>
<dd>Field: of shape (len(yt_coord),len(self)), defined on grid y_coord*self, containing the distances between the adjacent coord cell edges.</dd>
<dt>See also:</dt>
<dd>delta_dist method
der method
dist method 
vol method</dd>
</dl>
<p>Examples:</p>
<div class="last highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">y_step</span><span class="o">=</span><span class="mi">30</span><span class="p">;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">xcoord1</span> <span class="o">=</span> <span class="n">sg</span><span class="o">.</span><span class="n">fieldcls</span><span class="o">.</span><span class="n">XCoord</span><span class="p">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">&#39;testx&#39;</span><span class="p">,</span><span class="n">direction</span> <span class="o">=</span><span class="s">&#39;X&#39;</span><span class="p">,</span><span class="n">value</span> <span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span><span class="mf">360.</span><span class="p">,</span><span class="mf">90.</span><span class="p">)</span> <span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ycoord1</span> <span class="o">=</span> <span class="n">sg</span><span class="o">.</span><span class="n">fieldcls</span><span class="o">.</span><span class="n">YCoord</span><span class="p">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">&#39;testy&#39;</span><span class="p">,</span><span class="n">direction</span> <span class="o">=</span><span class="s">&#39;Y&#39;</span><span class="p">,</span><span class="n">value</span> <span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="mf">90.</span><span class="p">,</span><span class="mf">90.</span><span class="o">+</span><span class="n">y_step</span><span class="p">,</span><span class="n">y_step</span><span class="p">)</span> <span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">xcoord1_edges</span> <span class="o">=</span> <span class="n">sg</span><span class="o">.</span><span class="n">fieldcls</span><span class="o">.</span><span class="n">XCoord</span><span class="p">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">&#39;testx_edges&#39;</span><span class="p">,</span><span class="n">direction</span> <span class="o">=</span><span class="s">&#39;X&#39;</span><span class="p">,</span><span class="n">value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span><span class="mi">360</span><span class="o">+</span><span class="mf">45.</span><span class="p">,</span><span class="mf">90.</span><span class="p">)</span> <span class="o">-</span><span class="mf">45.</span> <span class="p">,</span> <span class="n">dual</span> <span class="o">=</span> <span class="n">xcoord1</span>  <span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">K</span> <span class="o">=</span> <span class="n">xcoord1</span><span class="o">.</span><span class="n">d</span><span class="p">(</span><span class="n">ycoord1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">K</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(7, 4)</span>
</pre></div>
</div>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="spacegrids.fieldcls.XCoord.delta_dist">
<tt class="descname">delta_dist</tt><big>(</big><em>y_coord</em>, <em>fact=6370000.0</em><big>)</big><a class="reference internal" href="_modules/spacegrids/fieldcls.html#XCoord.delta_dist"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.fieldcls.XCoord.delta_dist" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes distances between adjacent spherical longitudinal coordinate points of XCoord (self) taking into account latitudinal positions.</p>
<p>Overrides delta_dist method of Coord class. Does not call dist method (unlike Coord method), but assumes self.value to be an array of longitudinal polar coord values in degrees.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>y_coord: (YCoord) latitudinal coordinate positions (usually component in grid context).
fact: (float) factor by which to multiply result: this should be radius of sphere.</dd>
<dt>Returns:</dt>
<dd>Field: defined on grid y_coord*self (2D), containing the longitudinal distances.</dd>
<dt>See also: </dt>
<dd>d method 
der method
dist method 
vol method</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="spacegrids.fieldcls.XCoord.der">
<tt class="descname">der</tt><big>(</big><em>F</em>, <em>y_coord</em><big>)</big><a class="reference internal" href="_modules/spacegrids/fieldcls.html#XCoord.der"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.fieldcls.XCoord.der" title="Permalink to this definition">¶</a></dt>
<dd><p>XCoord derivative method on Field F.</p>
<p>XCoord is cyclical, the first derivative element is not nan.</p>
<p>Overrides Coord der method. Differs in that this method takes an extra y_coord argument, which is required for the calculation of cell distances.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>F: (Field) Field to take derivative of
y_coord: (YCoord) latitudinal Coord (usually component in grid context).</dd>
<dt>Returns:</dt>
<dd>Field on same grid containing the derivative.</dd>
<dt>Raises:</dt>
<dd>ValueError: when Coord (self) is not in F.grid (grid of Field).</dd>
<dt>See also: </dt>
<dd>d method 
delta_dist method
dist method 
vol method</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="spacegrids.fieldcls.XCoord.dist">
<tt class="descname">dist</tt><big>(</big><em>y_coord</em>, <em>fact=6370000.0</em><big>)</big><a class="reference internal" href="_modules/spacegrids/fieldcls.html#XCoord.dist"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.fieldcls.XCoord.dist" title="Permalink to this definition">¶</a></dt>
<dd><p>Distance (signed) along XCoord (self) in only one direction (increasing index) from a fixed point.</p>
<p>The fixed point is usually 0 longitude, but depends on the Coord.</p>
<p>Overrides dist method of Coord class. Assumes self.value to be an array of longitudinal polar coord values in degrees.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>y_coord: (YCoord) latitudinal Coord (usually component in grid context).
fact: (float) factor by which to multiply result: this should be radius of sphere.</dd>
<dt>Returns:</dt>
<dd>Field: of shape (len(yt_coord),len(self)), defined on grid y_coord*self, containing the distances.</dd>
<dt>See also: </dt>
<dd>d method 
delta_dist method
der method
vol method</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="spacegrids.fieldcls.XCoord.roll">
<tt class="descname">roll</tt><big>(</big><em>shift=0</em><big>)</big><a class="reference internal" href="_modules/spacegrids/fieldcls.html#XCoord.roll"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.fieldcls.XCoord.roll" title="Permalink to this definition">¶</a></dt>
<dd><p>Yields copy of XCoord (self) with value shifted by integer using numpy.roll().</p>
<p>Values are modulo 720 degrees from -360.</p>
<p>Overrides .copy method of Coord</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>shift: (int) number of array positions to shift by</dd>
<dt>Returns:</dt>
<dd>Coord: shifted Coord.</dd>
</dl>
<p>Examples:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">xcoord1</span> <span class="o">=</span> <span class="n">sg</span><span class="o">.</span><span class="n">fieldcls</span><span class="o">.</span><span class="n">XCoord</span><span class="p">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">&#39;test1&#39;</span><span class="p">,</span><span class="n">direction</span> <span class="o">=</span><span class="s">&#39;X&#39;</span><span class="p">,</span><span class="n">value</span> <span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span><span class="mf">2.</span><span class="p">,</span><span class="mf">3.</span><span class="p">])</span> <span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">xcoord1</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">value</span>
<span class="go">array([-357.,    1.,    2.])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="spacegrids.fieldcls.XCoord.vol">
<tt class="descname">vol</tt><big>(</big><em>gr</em><big>)</big><a class="reference internal" href="_modules/spacegrids/fieldcls.html#XCoord.vol"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.fieldcls.XCoord.vol" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Generalized volume method related to d method of XCoord: yields self.d(y_coord) if self and a y-coord y_coord in gr, None otherwise.</p>
<p>Determines widths (1D &#8220;volumes&#8221;) of cells along self Coord. grid argument acts as filter: aborts if self not in grid. The grid argument is more critical in derived classes (e.g. x_coord), where auxhiliary coordinates are picked from Gr and need to be present.</p>
<p>Overrides vol method of Coord.</p>
<p>Picks auxiliary coordinate (as when x-widths depend on y) from grid argument gr (y grid is chosen on the same grid as x-coord) depending on what inspect module finds in d method interface</p>
</div></blockquote>
<p>.</p>
<blockquote>
<div><dl class="docutils">
<dt>Args:</dt>
<dd>gr: (Gr) grid to test against.</dd>
<dt>Returns:</dt>
<dd>Field or None: self.d() if self in gr, None otherwise.</dd>
<dt>Raises:</dt>
<dd>RuntimeError if no matching (e.g. y_coord) Coord can be found for d method argument.</dd>
<dt>See also:</dt>
<dd>d method 
delta_dist method
der method
dist method</dd>
</dl>
</div></blockquote>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="spacegrids.fieldcls.YCoord">
<em class="property">class </em><tt class="descclassname">spacegrids.fieldcls.</tt><tt class="descname">YCoord</tt><big>(</big><em>name='scalar'</em>, <em>value=array([0])</em>, <em>dual=None</em>, <em>axis='?'</em>, <em>direction='scalar'</em>, <em>units=None</em>, <em>long_name='?'</em>, <em>metadata={}</em>, <em>strings=None</em>, <em>associative=None</em><big>)</big><a class="reference internal" href="_modules/spacegrids/fieldcls.html#YCoord"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.fieldcls.YCoord" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spacegrids.fieldcls.Coord" title="spacegrids.fieldcls.Coord"><tt class="xref py py-class docutils literal"><span class="pre">spacegrids.fieldcls.Coord</span></tt></a></p>
<p>Specialized Coord class for representing latitudinal direction in spherical coordinates. See Coord.</p>
<p>The YCoord class contains methods related to distances, with dependencies identical to Coord (as opposed to XCoord). dist is overriden, working through into der, delta_dist, d and vol (even though these affected methods are inherited from Coord).</p>
<dl class="method">
<dt id="spacegrids.fieldcls.YCoord.dist">
<tt class="descname">dist</tt><big>(</big><em>fact=6370000.0</em><big>)</big><a class="reference internal" href="_modules/spacegrids/fieldcls.html#YCoord.dist"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.fieldcls.YCoord.dist" title="Permalink to this definition">¶</a></dt>
<dd><p>Distance (signed) along YCoord (self) in only one direction (increasing index) from a fixed point.</p>
<p>That fixed point is usually 0 latitude (yielding positive and negative distances), but depends on the Coord.</p>
<p>Overrides dist method of Coord class. Assumes self.value to be an array of latitudinal polar coord values in degrees. This affects the Coord (parent) methods that depend on it: der, delta_dist, d and vol.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>fact: (float) factor by which to multiply result: this should be radius of sphere.</dd>
<dt>Returns:</dt>
<dd>Field: of shape (len(self),), defined on 1D grid self**2, containing the distances.</dd>
<dt>See also: </dt>
<dd>d method 
delta_dist method
der method
dist method 
vol method</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="spacegrids.fieldcls.cdfread">
<tt class="descclassname">spacegrids.fieldcls.</tt><tt class="descname">cdfread</tt><big>(</big><em>filepath</em>, <em>varname</em>, <em>coord_stack=</em>, <span class="optional">[</span><span class="optional">]</span><em>ax_stack=</em>, <span class="optional">[</span><span class="optional">]</span><em>verbose=True</em>, <em>squeeze_Field=False</em>, <em>slices=None</em>, <em>slice_suffix='_sliced'</em><big>)</big><a class="reference internal" href="_modules/spacegrids/fieldcls.html#cdfread"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.fieldcls.cdfread" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads data corresponding to variable name varname from netcdf file and returns Field.</p>
<p>coord_stack is used to provide Field with grid object built from corresponding Coord objects according to information in netcdf.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>filepath: (str) complete path pointing to file.
varname: (str) variable name in Netcdf file
coord_stack: (list of Coord) to use when reading
ax_stack: (list of Ax) to use when reading
squeeze_Field: (Boolean) if True, hard- squeeze the Field at this point of the reading process (fully removing the 1-dimensional dims). Generally not used.
slices: (tuple of slice, Coord and Ax objects) slices to take. No slicing if None.
slice_suffix: (str) suffix to add to variable name in case of slicing</dd>
<dt>Returns: </dt>
<dd>Field that was read.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="spacegrids.fieldcls.cdfsniff">
<tt class="descclassname">spacegrids.fieldcls.</tt><tt class="descname">cdfsniff</tt><big>(</big><em>path_parent, file_extensions=['*.nc', '*.cdf'], verbose=False</em><big>)</big><a class="reference internal" href="_modules/spacegrids/fieldcls.html#cdfsniff"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.fieldcls.cdfsniff" title="Permalink to this definition">¶</a></dt>
<dd><p>Looks inside the path_parent path for Netcdf files and extracts Coord objects from the dim data.</p>
<p>Path is to directory containing the Netcdf files, provided as argument.</p>
<p>Uses sg._cdfsniff_helper.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>path_parent: (str) path to directory containing the Netcdf files
file_extensions: (list of str) containing patterns to match Netcdf files</dd>
<dt>Returns:</dt>
<dd>List of all Coord objects that contain different data, to be used in the Coord stack cstack.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="spacegrids.fieldcls.concatenate">
<tt class="descclassname">spacegrids.fieldcls.</tt><tt class="descname">concatenate</tt><big>(</big><em>fields</em>, <em>ax=None</em>, <em>name_suffix='_cat'</em>, <em>new_coord_name='gamma'</em>, <em>new_coord=None</em>, <em>strings=None</em><big>)</big><a class="reference internal" href="_modules/spacegrids/fieldcls.html#concatenate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.fieldcls.concatenate" title="Permalink to this definition">¶</a></dt>
<dd><p>Joins a sequence of Field objects together.</p>
<p>concatenate((a1,a2,...),ax=None)</p>
<p>The Field value ndarrays must have the same shape, except in the direction of concatenation if present in the grid.
Default behaviour (CASE A0) when ax = None picks the concatenation direction as the first direction with unequal Coord point values (indicating pieces of a dimension). For instance, SAT1.shape is (50,100) and SAT2.shape is (50,100) would concatenate to shape (100,100) by concatenating along index 0.</p>
<p>If ax is already in grid directions (in Field.grid.axis(), CASE A1 ), and Field grids have equal Coord member in that direction, as per Field.cat method, the last Field is returned: don&#8217;t use this.</p>
<p>A new Coord is created (CASE A2) if new_coord argument is None and if none of the grid members axis point in the direction of the ax argument (e.g. X,Y vs Z). Then, &#8220;new_coord_name&#8221; is used. 
The above behaviour is overridden if the &#8220;new_coord&#8221; argument is given (CASE B). This is a Coord object that will be used to construct one Field from the fields list argument. The list elements become slices (at single Coord values) and the new_coord values are the corresponding coordinates.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>fields: (container of Field objects, e.g. list) Field objects to concat.
ax: (Gr) axis along which to concatenate, optional.
name_suffix: (str) suffix to use for returned Field object name
new_coord_name: (str) name to be used for creation of new Coord in case ax not in Field grid
new_coord: (Coord) overrides default behaviour if set by concatenating along that new Coord.
strings: (container of strings) used as strings argument in Coord creation with new_coord_name</dd>
<dt>Returns:</dt>
<dd>The concatenated Field.</dd>
<dt>Raises:</dt>
<dd>ValueError if Field sequence is empty or, if new_coord is not None, if the Field list is of unequal length to new_coord.</dd>
</dl>
<p>Examples:</p>
<p>Obtain X,Y,.. for project P via:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">P</span><span class="p">[</span><span class="s">&#39;DPO&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">axes</span><span class="p">:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">exec</span> <span class="n">c</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s">&#39; = c&#39;</span>
</pre></div>
</div>
<p>CASE A0:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">SAT</span> <span class="o">=</span> <span class="n">P</span><span class="p">[</span><span class="s">&#39;DPO&#39;</span><span class="p">][</span><span class="s">&#39;A_sat&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">SAT1</span> <span class="o">=</span> <span class="n">SAT</span><span class="p">[</span><span class="n">Y</span><span class="p">,:</span><span class="mi">50</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">SAT2</span> <span class="o">=</span> <span class="n">SAT</span><span class="p">[</span><span class="n">Y</span><span class="p">,</span><span class="mi">50</span><span class="p">:]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">SAT_combined</span> <span class="o">=</span> <span class="n">sg</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">SAT1</span><span class="p">,</span><span class="n">SAT2</span> <span class="p">]</span> <span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">SAT_combined</span><span class="o">.</span><span class="n">shape</span> <span class="c"># we get the old Field back via automatic Y-concatenation</span>
<span class="go">(100, 100)</span>
</pre></div>
</div>
<p>CASE A2: ax not in grid.axis(), a new Coord will be created</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">SAT</span> <span class="o">=</span> <span class="n">P</span><span class="p">[</span><span class="s">&#39;DPO&#39;</span><span class="p">][</span><span class="s">&#39;A_sat&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">SAT1</span> <span class="o">=</span> <span class="n">SAT</span><span class="p">[</span><span class="n">Y</span><span class="p">,:</span><span class="mi">50</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">SAT2</span> <span class="o">=</span> <span class="n">SAT</span><span class="p">[</span><span class="n">Y</span><span class="p">,</span><span class="mi">50</span><span class="p">:]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">W</span> <span class="o">=</span> <span class="n">sg</span><span class="o">.</span><span class="n">Ax</span><span class="p">(</span><span class="s">&#39;W&#39;</span><span class="p">)</span> <span class="c"># Create test Coord to concatenate along.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">SAT_combined</span> <span class="o">=</span> <span class="n">sg</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">SAT1</span><span class="p">,</span><span class="n">SAT2</span> <span class="p">],</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">W</span> <span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">SAT_combined</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(2,50,100)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">SAT_combined</span><span class="o">.</span><span class="n">grid</span>
<span class="go">(gamma, latitude_sliced, longitude)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">SAT_combined</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">value</span>  <span class="c"># a new Coord has been created</span>
<span class="go">array([0, 1])</span>
</pre></div>
</div>
<p>CASE B: use new_coord to create new grid</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">SAT</span> <span class="o">=</span> <span class="n">P</span><span class="p">[</span><span class="s">&#39;DPO&#39;</span><span class="p">][</span><span class="s">&#39;A_sat&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">SAT1</span> <span class="o">=</span> <span class="n">SAT</span><span class="p">[</span><span class="n">Y</span><span class="p">,:</span><span class="mi">50</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">SAT2</span> <span class="o">=</span> <span class="n">SAT</span><span class="p">[</span><span class="n">Y</span><span class="p">,</span><span class="mi">50</span><span class="p">:]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">W</span> <span class="o">=</span> <span class="n">sg</span><span class="o">.</span><span class="n">Ax</span><span class="p">(</span><span class="s">&#39;W&#39;</span><span class="p">)</span> <span class="c"># Create test Coord to concatenate along.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">w</span> <span class="o">=</span> <span class="n">sg</span><span class="o">.</span><span class="n">Coord</span><span class="p">(</span><span class="s">&#39;w&#39;</span> <span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="n">W</span><span class="p">,</span> <span class="n">direction</span> <span class="o">=</span> <span class="s">&#39;W&#39;</span><span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">SAT_combined</span> <span class="o">=</span> <span class="n">sg</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">SAT1</span><span class="p">,</span><span class="n">SAT2</span> <span class="p">],</span> <span class="n">new_coord</span> <span class="o">=</span> <span class="n">w</span> <span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">SAT_combined</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(2,50,100)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">SAT_combined</span><span class="o">.</span><span class="n">grid</span>
<span class="go">(w, latitude_sliced, longitude)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">SAT_combined</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">value</span>  <span class="c"># we get the value of w</span>
<span class="go">array([0, 1])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="spacegrids.fieldcls.delta">
<tt class="descclassname">spacegrids.fieldcls.</tt><tt class="descname">delta</tt><big>(</big><em>x</em><big>)</big><a class="reference internal" href="_modules/spacegrids/fieldcls.html#delta"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.fieldcls.delta" title="Permalink to this definition">¶</a></dt>
<dd><p>Function that calls the d method of the Coord object depending on the kind of coordinate (i.e. x or y).</p>
</dd></dl>

<dl class="function">
<dt id="spacegrids.fieldcls.find_equal_axes">
<tt class="descclassname">spacegrids.fieldcls.</tt><tt class="descname">find_equal_axes</tt><big>(</big><em>lstack</em>, <em>rstack</em><big>)</big><a class="reference internal" href="_modules/spacegrids/fieldcls.html#find_equal_axes"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.fieldcls.find_equal_axes" title="Permalink to this definition">¶</a></dt>
<dd><p>Expects two lists of Coord objects and determines which Coord objects are equal.</p>
<p>This is needed when different Coord objects have identical attributes. Acts directly on the Coord stack arguments. This function is generally called before axis attributes are converted from str to Ax objects.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>lstack: (list of Coord objects), the first Coord stack
rstack: (list of Coord objects), the second Coord stack</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="spacegrids.fieldcls.find_set_dual">
<tt class="descclassname">spacegrids.fieldcls.</tt><tt class="descname">find_set_dual</tt><big>(</big><em>cstack</em>, <em>force=None</em><big>)</big><a class="reference internal" href="_modules/spacegrids/fieldcls.html#find_set_dual"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.fieldcls.find_set_dual" title="Permalink to this definition">¶</a></dt>
<dd><p>This function tries to find duals among a list cstack (argument) of Coord objects.</p>
<p>Checks if duals have been defined before. If one such Coord is found, function is aborted (it is assumed it is not needed then). Override with argument force = True.</p>
</dd></dl>

<dl class="function">
<dt id="spacegrids.fieldcls.finer_field">
<tt class="descclassname">spacegrids.fieldcls.</tt><tt class="descname">finer_field</tt><big>(</big><em>F</em>, <em>factor=5.0</em><big>)</big><a class="reference internal" href="_modules/spacegrids/fieldcls.html#finer_field"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.fieldcls.finer_field" title="Permalink to this definition">¶</a></dt>
<dd><p>This is a more UVic specific function to prepare a Field containing the outline of the continents for horizontal plots.</p>
</dd></dl>

<dl class="function">
<dt id="spacegrids.fieldcls.finer_grid">
<tt class="descclassname">spacegrids.fieldcls.</tt><tt class="descname">finer_grid</tt><big>(</big><em>grid</em>, <em>factor=5.0</em><big>)</big><a class="reference internal" href="_modules/spacegrids/fieldcls.html#finer_grid"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.fieldcls.finer_grid" title="Permalink to this definition">¶</a></dt>
<dd><p>Call finer method on Gr members.</p>
</dd></dl>

<dl class="function">
<dt id="spacegrids.fieldcls.guess_direction">
<tt class="descclassname">spacegrids.fieldcls.</tt><tt class="descname">guess_direction</tt><big>(</big><em>cdf_var, name_atts=['long_name', 'standard_name'], x_dir_names=['eastward', 'Eastward', 'zonal', 'Zonal'], y_dir_names=['northward', 'Northward', 'meridional', 'Meridional'], z_dir_names=['upward', 'Upward', 'vertical', 'Vertical'], t_dir_names=[], directional_names=['velocity', 'stress', 'momentum flux', 'momentum_flux']</em><big>)</big><a class="reference internal" href="_modules/spacegrids/fieldcls.html#guess_direction"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.fieldcls.guess_direction" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function for cdfread to guess, based on keywords in the netcdf data descriptions, whether a Field is a (space-) vector Field component and in what direction it points.</p>
<p>The directional_names argument is a list of keywords that might show up in a description that indicates a vector component: e.g. the word velocity. If this list is empty, the function will not search for those keywords (less restrictive). The name_atts argument indicates the possible name of a descriptive attribute in a netcdf file. The {x,y,z}_dir_names correspond to keywords indicating that particular direction (x,y,z).</p>
</dd></dl>

<dl class="function">
<dt id="spacegrids.fieldcls.interpret_slices">
<tt class="descclassname">spacegrids.fieldcls.</tt><tt class="descname">interpret_slices</tt><big>(</big><em>L</em>, <em>grid</em>, <em>others=slice(None</em>, <em>None</em>, <em>None)</em>, <em>as_int=False</em><big>)</big><a class="reference internal" href="_modules/spacegrids/fieldcls.html#interpret_slices"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.fieldcls.interpret_slices" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpret slice argument passed from __getitem__</p>
<p>For example passed from TEMP[X,:,Y,:50] or TEMP[:,50:]</p>
<p>Case 1: Coord or Ax objects are given. E.g. TEMP[X,:,Y,:50]. Not all Coords in the grid need to be given.</p>
<p>Case 2: No Coord/ Ax objects are given. In this case, a normal Numpy slice argument is expected, and all Coords indices need to be specified.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>L: (list or tuple) of slice, Ax or Coord ojbects or ints to interpret
grid: (Gr) grid to slice on
others: (slice) slice object to fill into non-given Coords in Case 1  
as_int: (Boolean) slices of length 1 are represented as integer if True</dd>
<dt>Returns:</dt>
<dd>A list of standard slice objects that can be used to slice ndarrays or Netcdf vars</dd>
<dt>Raises:</dt>
<dd>ValueError, RuntimeError</dd>
</dl>
<p>Examples:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">sg</span><span class="o">.</span><span class="n">interpret_slices</span><span class="p">((</span><span class="n">X</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span><span class="mi">10</span><span class="p">),</span><span class="n">latitude</span><span class="o">*</span><span class="n">longitude</span><span class="p">)</span>
<span class="go">(slice(10, 11, None), slice(1, 2, None))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sg</span><span class="o">.</span><span class="n">interpret_slices</span><span class="p">((</span><span class="n">X</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span><span class="mi">10</span><span class="p">),</span><span class="n">latitude</span><span class="o">*</span><span class="n">longitude</span><span class="p">,</span><span class="n">as_int</span> <span class="o">=</span> <span class="bp">True</span><span class="p">)</span>
<span class="go">(10, 1)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="spacegrids.fieldcls.make_axes">
<tt class="descclassname">spacegrids.fieldcls.</tt><tt class="descname">make_axes</tt><big>(</big><em>cstack</em><big>)</big><a class="reference internal" href="_modules/spacegrids/fieldcls.html#make_axes"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.fieldcls.make_axes" title="Permalink to this definition">¶</a></dt>
<dd><p>Replaces axis attribute of Coord objects if it is a string with newly created (non-repeating) corresponding axis objects.</p>
<blockquote>
<div>The Ax objects are created here.</div></blockquote>
<p>Returns list of Ax objects!!</p>
<p>NOTE THAT THIS FUNCTION DOES 2 THINGS: IT RETURNS A LIST OF AXES AND MODIFIES THE CSTACK ARGUMENT.</p>
<dl class="docutils">
<dt>Args: </dt>
<dd>cstack: (list of Coord) to act on.</dd>
<dt>Returns: </dt>
<dd>List of all unique (no repeats) Ax objects that have been created to replace the axis attribute of the elements of the Coord list (cstack) argument that were strings. None is returned when all cstack Coord elements already have Ax axis attributes.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="spacegrids.fieldcls.make_dual">
<tt class="descclassname">spacegrids.fieldcls.</tt><tt class="descname">make_dual</tt><big>(</big><em>crd</em>, <em>name=None</em>, <em>guess_append=True</em>, <em>append_last=True</em>, <em>zero_boundary=False</em><big>)</big><a class="reference internal" href="_modules/spacegrids/fieldcls.html#make_dual"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.fieldcls.make_dual" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a dual Coord by appending one entry, of which the width is guessed based on the adjacent cell width.</p>
</dd></dl>

<dl class="function">
<dt id="spacegrids.fieldcls.nugget">
<tt class="descclassname">spacegrids.fieldcls.</tt><tt class="descname">nugget</tt><big>(</big><em>path=None</em>, <em>name=None</em>, <em>fields=</em>, <span class="optional">[</span><span class="optional">]</span><em>history='Created from Spacegrids '</em><big>)</big><a class="reference internal" href="_modules/spacegrids/fieldcls.html#nugget"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.fieldcls.nugget" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates Netcdf file and writes all loaded Field to it, along with their Coord objects.</p>
</dd></dl>

<dl class="function">
<dt id="spacegrids.fieldcls.ones">
<tt class="descclassname">spacegrids.fieldcls.</tt><tt class="descname">ones</tt><big>(</big><em>grid</em><big>)</big><a class="reference internal" href="_modules/spacegrids/fieldcls.html#ones"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.fieldcls.ones" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a Field with value np.ones(grid.shape) and grid attribute grid.</p>
<p>No nans.</p>
</dd></dl>

<dl class="function">
<dt id="spacegrids.fieldcls.roll">
<tt class="descclassname">spacegrids.fieldcls.</tt><tt class="descname">roll</tt><big>(</big><em>F</em>, <em>shift=1</em>, <em>coord=None</em>, <em>axis=None</em>, <em>mask=False</em>, <em>keepgrid=False</em>, <em>nan_val=nan</em><big>)</big><a class="reference internal" href="_modules/spacegrids/fieldcls.html#roll"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.fieldcls.roll" title="Permalink to this definition">¶</a></dt>
<dd><p>Function that rolls a Field similar to np.roll on numpy arrays.</p>
<p>sg.roll actually calls np.roll. Axis can be picked via coord name. If mask is True, the elements that rolled from the other side of the array are set to nan (appropriate for non re-entrant domains). The rolled coord element of the grid belonging to Field F is replaced by a new Coord object reflecting the roll operation. To disable this Coord replacement, use argument keepgrid = True</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>F: (Field) to roll
shift: (int) to roll by
coord: (Coord) to roll along (e.g. latitude)
axis: (int) indicates np.array index to roll by: generally not set.
mask: (Boolean) if True, handle exposed areas that need to be set to nan
keepgrid: (Boolean) if True, keep the original Field grid (replaced with shifted by default)  
nan_val: (np.nan) value to indicate nan</dd>
<dt>Returns:</dt>
<dd>Rolled Field.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="spacegrids.fieldcls.squeeze">
<tt class="descclassname">spacegrids.fieldcls.</tt><tt class="descname">squeeze</tt><big>(</big><em>F</em>, <em>hard=False</em><big>)</big><a class="reference internal" href="_modules/spacegrids/fieldcls.html#squeeze"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.fieldcls.squeeze" title="Permalink to this definition">¶</a></dt>
<dd><p>Equivalent to Numpy squeeze method. Remove dimensions and associated coords in grid of length 1. Reversible operation as squeezed dimensions are stored in different attribute (squeezed_dims). Setting argument &#8220;hard&#8221; to True yields an irreversible squeeze where the squeezed dims are not recorded (and cannot be unsqueezed later).</p>
<p>See also: Field.unsqueeze</p>
</dd></dl>

<dl class="function">
<dt id="spacegrids.fieldcls.unsqueeze">
<tt class="descclassname">spacegrids.fieldcls.</tt><tt class="descname">unsqueeze</tt><big>(</big><em>F</em><big>)</big><a class="reference internal" href="_modules/spacegrids/fieldcls.html#unsqueeze"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.fieldcls.unsqueeze" title="Permalink to this definition">¶</a></dt>
<dd><p>Opposite of squeeze. Uses the grid stored in squeezed_dims Field attribute to restore the unit-length dimensions (coords) of the Field.</p>
<p>See also: Field.squeeze</p>
</dd></dl>

</div>
</div>
<div class="section" id="module-spacegrids.ops">
<span id="ops-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">ops</span></tt> Module<a class="headerlink" href="#module-spacegrids.ops" title="Permalink to this headline">¶</a></h2>
<p>Mathematical operators based on Field and Gr operations.</p>
<p>The mathematical operators defined here, such as Der, provide basic building blocks for the user to define more detailed Operators. Arithmatic operations such as addition and multiplication among these operators yield new operators. These new operators can be called on Field objects later, performing the intended operation.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">ddX</span> <span class="o">=</span> <span class="n">sg</span><span class="o">.</span><span class="n">Der</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="c"># create Operator that would take X-derivative on Field args</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ddY</span> <span class="o">=</span> <span class="n">sg</span><span class="o">.</span><span class="n">Der</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span> <span class="c"># similar</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ddXddY</span> <span class="o">=</span> <span class="n">ddX</span><span class="o">*</span><span class="n">ddY</span>  <span class="c"># create composite operator</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ddXddY</span><span class="p">(</span><span class="n">F</span><span class="p">)</span> <span class="c"># differentiation in X direction following differentiation in Y</span>
</pre></div>
</div>
<dl class="class">
<dt id="spacegrids.ops.Add">
<em class="property">class </em><tt class="descclassname">spacegrids.ops.</tt><tt class="descname">Add</tt><big>(</big><em>left</em>, <em>right</em><big>)</big><a class="reference internal" href="_modules/spacegrids/ops.html#Add"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.ops.Add" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spacegrids.ops.Operator" title="spacegrids.ops.Operator"><tt class="xref py py-class docutils literal"><span class="pre">spacegrids.ops.Operator</span></tt></a></p>
<p>Operator for addition among Operator objects.</p>
<p>Stores left and right Operator __init__ arguments, that will both act on Field __call__ argument and then added there.</p>
</dd></dl>

<dl class="class">
<dt id="spacegrids.ops.Der">
<em class="property">class </em><tt class="descclassname">spacegrids.ops.</tt><tt class="descname">Der</tt><big>(</big><em>Xi</em><big>)</big><a class="reference internal" href="_modules/spacegrids/ops.html#Der"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.ops.Der" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spacegrids.ops.Operator" title="spacegrids.ops.Operator"><tt class="xref py py-class docutils literal"><span class="pre">spacegrids.ops.Operator</span></tt></a></p>
<p>Directional derivative Operator.</p>
<dl class="docutils">
<dt>Attributes:</dt>
<dd>ax: (Ax) axis in which direction __call__ will take the derivative.</dd>
</dl>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">ddX</span> <span class="o">=</span> <span class="n">sg</span><span class="o">.</span><span class="n">Der</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="c"># create Operator that would take X-derivative on Field args</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ddY</span> <span class="o">=</span> <span class="n">sg</span><span class="o">.</span><span class="n">Der</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span> <span class="c"># similar</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ddXddY</span> <span class="o">=</span> <span class="n">ddX</span><span class="o">*</span><span class="n">ddY</span>  <span class="c"># create composite operator</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ddXddY</span><span class="p">(</span><span class="n">F</span><span class="p">)</span> <span class="c"># differentiation in X direction following differentiation in Y</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="spacegrids.ops.FieldMul">
<em class="property">class </em><tt class="descclassname">spacegrids.ops.</tt><tt class="descname">FieldMul</tt><big>(</big><em>F</em><big>)</big><a class="reference internal" href="_modules/spacegrids/ops.html#FieldMul"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.ops.FieldMul" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spacegrids.ops.Operator" title="spacegrids.ops.Operator"><tt class="xref py py-class docutils literal"><span class="pre">spacegrids.ops.Operator</span></tt></a></p>
<p>Operator storing a Field and multiplying (V)Field argument with that Field when called.</p>
</dd></dl>

<dl class="class">
<dt id="spacegrids.ops.FloatMul">
<em class="property">class </em><tt class="descclassname">spacegrids.ops.</tt><tt class="descname">FloatMul</tt><big>(</big><em>value</em><big>)</big><a class="reference internal" href="_modules/spacegrids/ops.html#FloatMul"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.ops.FloatMul" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spacegrids.ops.Operator" title="spacegrids.ops.Operator"><tt class="xref py py-class docutils literal"><span class="pre">spacegrids.ops.Operator</span></tt></a></p>
<p>Operator that is initalized with a float, and multiplies a Field argument with that float on calling.</p>
</dd></dl>

<dl class="class">
<dt id="spacegrids.ops.Identity">
<em class="property">class </em><tt class="descclassname">spacegrids.ops.</tt><tt class="descname">Identity</tt><a class="reference internal" href="_modules/spacegrids/ops.html#Identity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.ops.Identity" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spacegrids.ops.Operator" title="spacegrids.ops.Operator"><tt class="xref py py-class docutils literal"><span class="pre">spacegrids.ops.Operator</span></tt></a></p>
<p>Operator representing the identity.</p>
<p>No change upon __call__</p>
</dd></dl>

<dl class="class">
<dt id="spacegrids.ops.If">
<em class="property">class </em><tt class="descclassname">spacegrids.ops.</tt><tt class="descname">If</tt><big>(</big><em>Cond_Op</em>, <em>True_Op</em>, <em>Else_Op=&lt;spacegrids.ops.Identity object at 0xac65eec&gt;</em><big>)</big><a class="reference internal" href="_modules/spacegrids/ops.html#If"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.ops.If" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spacegrids.ops.Operator" title="spacegrids.ops.Operator"><tt class="xref py py-class docutils literal"><span class="pre">spacegrids.ops.Operator</span></tt></a></p>
<p>If Operator as in If then.</p>
<p>The state of the system is defined by the Field(s) vF. Therefore, the condition can be internal to the call function and must be defined in terms of vF (e.g. &#8216;len(vF.grid) == 3&#8217;).</p>
</dd></dl>

<dl class="class">
<dt id="spacegrids.ops.Innprod">
<em class="property">class </em><tt class="descclassname">spacegrids.ops.</tt><tt class="descname">Innprod</tt><a class="reference internal" href="_modules/spacegrids/ops.html#Innprod"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.ops.Innprod" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spacegrids.ops.Operator" title="spacegrids.ops.Operator"><tt class="xref py py-class docutils literal"><span class="pre">spacegrids.ops.Operator</span></tt></a></p>
<p>Inner product on two (V)Fields.</p>
<p>Both fields must be in same linear space: their direction must match up to a permutation. Can be extended later to include non-trivial inner products.</p>
</dd></dl>

<dl class="class">
<dt id="spacegrids.ops.Integ">
<em class="property">class </em><tt class="descclassname">spacegrids.ops.</tt><tt class="descname">Integ</tt><big>(</big><em>Xi</em><big>)</big><a class="reference internal" href="_modules/spacegrids/ops.html#Integ"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.ops.Integ" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spacegrids.ops.Operator" title="spacegrids.ops.Operator"><tt class="xref py py-class docutils literal"><span class="pre">spacegrids.ops.Operator</span></tt></a></p>
<p>Compute total integral in ax direction.</p>
<dl class="docutils">
<dt>Attributes:</dt>
<dd>ax: (Ax) axis direction in which to integrate.</dd>
<dt>See also:</dt>
<dd>vsum method.</dd>
</dl>
</dd></dl>

<dl class="class">
<dt id="spacegrids.ops.Lazy">
<em class="property">class </em><tt class="descclassname">spacegrids.ops.</tt><tt class="descname">Lazy</tt><big>(</big><em>op_fctn</em><big>)</big><a class="reference internal" href="_modules/spacegrids/ops.html#Lazy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.ops.Lazy" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spacegrids.ops.Operator" title="spacegrids.ops.Operator"><tt class="xref py py-class docutils literal"><span class="pre">spacegrids.ops.Operator</span></tt></a></p>
<p>Operator created with a function argument. The function yields an operator, and is called only in __call__, where an operator attribute is assigned to self with that return value. From then on, that operator will act on the __call__ Field argument.</p>
</dd></dl>

<dl class="class">
<dt id="spacegrids.ops.Mean">
<em class="property">class </em><tt class="descclassname">spacegrids.ops.</tt><tt class="descname">Mean</tt><big>(</big><em>Xi</em><big>)</big><a class="reference internal" href="_modules/spacegrids/ops.html#Mean"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.ops.Mean" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spacegrids.ops.Operator" title="spacegrids.ops.Operator"><tt class="xref py py-class docutils literal"><span class="pre">spacegrids.ops.Operator</span></tt></a></p>
<p>Calculate mean of (V)Field object using stored Ax object.</p>
</dd></dl>

<dl class="class">
<dt id="spacegrids.ops.Mul">
<em class="property">class </em><tt class="descclassname">spacegrids.ops.</tt><tt class="descname">Mul</tt><big>(</big><em>left</em>, <em>right</em><big>)</big><a class="reference internal" href="_modules/spacegrids/ops.html#Mul"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.ops.Mul" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spacegrids.ops.Operator" title="spacegrids.ops.Operator"><tt class="xref py py-class docutils literal"><span class="pre">spacegrids.ops.Operator</span></tt></a></p>
<p>Operator for multiplication among Operator objects.</p>
<p>Stores left and right Operator __init__ arguments, that will both act on Field __call__ argument and then multiplied there.</p>
</dd></dl>

<dl class="class">
<dt id="spacegrids.ops.Operator">
<em class="property">class </em><tt class="descclassname">spacegrids.ops.</tt><tt class="descname">Operator</tt><a class="reference internal" href="_modules/spacegrids/ops.html#Operator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.ops.Operator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Operator base class that is called on Field objects.</p>
<p>Has addition and multiplication-related operations, and empty ___call___.</p>
</dd></dl>

<dl class="class">
<dt id="spacegrids.ops.Pick">
<em class="property">class </em><tt class="descclassname">spacegrids.ops.</tt><tt class="descname">Pick</tt><big>(</big><em>Xi</em><big>)</big><a class="reference internal" href="_modules/spacegrids/ops.html#Pick"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.ops.Pick" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spacegrids.ops.Operator" title="spacegrids.ops.Operator"><tt class="xref py py-class docutils literal"><span class="pre">spacegrids.ops.Operator</span></tt></a></p>
<p>Constructed with argument Xi, picks the VField component with direction matching that Xi and returns it.</p>
</dd></dl>

<dl class="class">
<dt id="spacegrids.ops.Prim">
<em class="property">class </em><tt class="descclassname">spacegrids.ops.</tt><tt class="descname">Prim</tt><big>(</big><em>Xi</em><big>)</big><a class="reference internal" href="_modules/spacegrids/ops.html#Prim"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.ops.Prim" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spacegrids.ops.Operator" title="spacegrids.ops.Operator"><tt class="xref py py-class docutils literal"><span class="pre">spacegrids.ops.Operator</span></tt></a></p>
<p>Take primitive (antiderivative) of (V)Field along axis.</p>
<p>Calls vcumsum.</p>
</dd></dl>

<dl class="class">
<dt id="spacegrids.ops.SetDirection">
<em class="property">class </em><tt class="descclassname">spacegrids.ops.</tt><tt class="descname">SetDirection</tt><big>(</big><em>Xi</em><big>)</big><a class="reference internal" href="_modules/spacegrids/ops.html#SetDirection"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.ops.SetDirection" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spacegrids.ops.Operator" title="spacegrids.ops.Operator"><tt class="xref py py-class docutils literal"><span class="pre">spacegrids.ops.Operator</span></tt></a></p>
<p>Operator class to set the direction on a Field to self.ax.</p>
</dd></dl>

<dl class="class">
<dt id="spacegrids.ops.Slice">
<em class="property">class </em><tt class="descclassname">spacegrids.ops.</tt><tt class="descname">Slice</tt><big>(</big><em>tup</em><big>)</big><a class="reference internal" href="_modules/spacegrids/ops.html#Slice"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.ops.Slice" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spacegrids.ops.Operator" title="spacegrids.ops.Operator"><tt class="xref py py-class docutils literal"><span class="pre">spacegrids.ops.Operator</span></tt></a></p>
<p>Slice Operator storing tuple of Coord vs slice object pairs to slice (V)Field arguments with on __call__.</p>
<dl class="docutils">
<dt>Attributes:</dt>
<dd>tup: (tuple of Coord vs slice objects) to slice Field with</dd>
</dl>
</dd></dl>

<dl class="class">
<dt id="spacegrids.ops.Sum">
<em class="property">class </em><tt class="descclassname">spacegrids.ops.</tt><tt class="descname">Sum</tt><a class="reference internal" href="_modules/spacegrids/ops.html#Sum"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.ops.Sum" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spacegrids.ops.Operator" title="spacegrids.ops.Operator"><tt class="xref py py-class docutils literal"><span class="pre">spacegrids.ops.Operator</span></tt></a></p>
<p>Operator adding the vector components of a VField and returning the resulting Field.</p>
</dd></dl>

<dl class="class">
<dt id="spacegrids.ops.Try">
<em class="property">class </em><tt class="descclassname">spacegrids.ops.</tt><tt class="descname">Try</tt><big>(</big><em>Op</em><big>)</big><a class="reference internal" href="_modules/spacegrids/ops.html#Try"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.ops.Try" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spacegrids.ops.Operator" title="spacegrids.ops.Operator"><tt class="xref py py-class docutils literal"><span class="pre">spacegrids.ops.Operator</span></tt></a></p>
<p>Operator storing an Operator that is called with except on (V)Field argument in __call__</p>
<p>If successful, return result, otherwise return original (V)Field argument.</p>
<p>Similar to If Operator</p>
</dd></dl>

<dl class="class">
<dt id="spacegrids.ops.While">
<em class="property">class </em><tt class="descclassname">spacegrids.ops.</tt><tt class="descname">While</tt><big>(</big><em>True_Op</em>, <em>Cond_Op</em><big>)</big><a class="reference internal" href="_modules/spacegrids/ops.html#While"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.ops.While" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spacegrids.ops.Operator" title="spacegrids.ops.Operator"><tt class="xref py py-class docutils literal"><span class="pre">spacegrids.ops.Operator</span></tt></a></p>
<p>Similar to If Operator</p>
</dd></dl>

<dl class="function">
<dt id="spacegrids.ops.make_lin_form">
<tt class="descclassname">spacegrids.ops.</tt><tt class="descname">make_lin_form</tt><big>(</big><em>Xi</em><big>)</big><a class="reference internal" href="_modules/spacegrids/ops.html#make_lin_form"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.ops.make_lin_form" title="Permalink to this definition">¶</a></dt>
<dd><p>pass</p>
</dd></dl>

</div>
<div class="section" id="module-spacegrids.plotting">
<span id="plotting-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">plotting</span></tt> Module<a class="headerlink" href="#module-spacegrids.plotting" title="Permalink to this headline">¶</a></h2>
<p>Functions relating to plotting Fields.</p>
<p>Field objects contain more information than Numpy ndarrays. For instance, information about grids is stored alongside the actual data defined on that grid. This information can be used to automatically choose figure axes and labels etc. This is done in the plot, contour and contourf functions contained in this module. These functions take Field arguments, and call their plt counterparts by the same name. Arguments can be passed on directly to these counterparts.</p>
<dl class="function">
<dt id="spacegrids.plotting.add_kmt">
<tt class="descclassname">spacegrids.plotting.</tt><tt class="descname">add_kmt</tt><big>(</big><em>kmt</em><big>)</big><a class="reference internal" href="_modules/spacegrids/plotting.html#add_kmt"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.plotting.add_kmt" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot 1 contour of ndarray argument kmt.</p>
<p>Used in plotting bathymetry. Calls treat_kmt.</p>
</dd></dl>

<dl class="function">
<dt id="spacegrids.plotting.auto_cont">
<tt class="descclassname">spacegrids.plotting.</tt><tt class="descname">auto_cont</tt><big>(</big><em>m</em>, <em>M</em>, <em>num_cont</em>, <em>max_try=5</em><big>)</big><a class="reference internal" href="_modules/spacegrids/plotting.html#auto_cont"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.plotting.auto_cont" title="Permalink to this definition">¶</a></dt>
<dd><p>Automatically pick contours.</p>
<p>Pick a quantity of around num_cont contours between integers m and M.</p>
<p>Int max_try indicates how many times to try and refine the boundaries of the interval.</p>
<dl class="docutils">
<dt>Returns:</dt>
<dd>1D ndarray containing the desired contours: np.arange(m_new,M_new,step)</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="spacegrids.plotting.contour">
<tt class="descclassname">spacegrids.plotting.</tt><tt class="descname">contour</tt><big>(</big><em>fld</em>, <em>num_cont=15</em>, <em>xlabel=True</em>, <em>ylabel=True</em>, <em>minus_z=True</em>, <em>xl=None</em>, <em>yl=None</em>, <em>xscale=1.0</em>, <em>yscale=1.0</em>, <em>ax_units=True</em>, <em>num_xticks=6</em>, <em>num_yticks=6</em>, <em>greyshade='0.65'</em>, <em>showland=False</em>, <em>grid=None</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/spacegrids/plotting.html#contour"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.plotting.contour" title="Permalink to this definition">¶</a></dt>
<dd><p>Returned function for _scale_prep_deco decorator.</p>
<p>Wraps contour and contourf, who take slightly different args: arguments specific to only one function:</p>
<p>contourf
greyshade = &#8216;0.65&#8217;</p>
<p>contour
showland = False</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>fld: (Field) to be plotted
num_cont: (int) number of contours to be plotted
xlabel: (Boolean) show x label if True
ylabel: (Boolean) show y label if True  
minus_z: (Boolean) display negative numbers on vertical scale (Z) if True
xl: (None, list/ tuple of length 2) plot limits in the x-direction
yl: (None, list/ tuple of length 2) plot limits in the y-direction
xscale: (float) scale in x direction
yscale: (float) scale in y direction
ax_units: (Boolean) display units on axes if True
num_xticks: (None or int) number of ticks on x-axis, or disabled
num_yticks: (None or int) number of ticks on y-axis, or disabled
greyshade: (str) shade of grey to use for land
showland: (Boolean) show land (nan) is True
grid: (None or Gr) grid to draw information from.
<a href="#id14"><span class="problematic" id="id15">*</span></a>args,**kwargs: normal kw arguments that can be passed on to contour(f).</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="spacegrids.plotting.contourf">
<tt class="descclassname">spacegrids.plotting.</tt><tt class="descname">contourf</tt><big>(</big><em>fld</em>, <em>num_cont=15</em>, <em>xlabel=True</em>, <em>ylabel=True</em>, <em>minus_z=True</em>, <em>xl=None</em>, <em>yl=None</em>, <em>xscale=1.0</em>, <em>yscale=1.0</em>, <em>ax_units=True</em>, <em>num_xticks=6</em>, <em>num_yticks=6</em>, <em>greyshade='0.65'</em>, <em>showland=False</em>, <em>grid=None</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/spacegrids/plotting.html#contourf"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.plotting.contourf" title="Permalink to this definition">¶</a></dt>
<dd><p>Returned function for _scale_prep_deco decorator.</p>
<p>Wraps contour and contourf, who take slightly different args: arguments specific to only one function:</p>
<p>contourf
greyshade = &#8216;0.65&#8217;</p>
<p>contour
showland = False</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>fld: (Field) to be plotted
num_cont: (int) number of contours to be plotted
xlabel: (Boolean) show x label if True
ylabel: (Boolean) show y label if True  
minus_z: (Boolean) display negative numbers on vertical scale (Z) if True
xl: (None, list/ tuple of length 2) plot limits in the x-direction
yl: (None, list/ tuple of length 2) plot limits in the y-direction
xscale: (float) scale in x direction
yscale: (float) scale in y direction
ax_units: (Boolean) display units on axes if True
num_xticks: (None or int) number of ticks on x-axis, or disabled
num_yticks: (None or int) number of ticks on y-axis, or disabled
greyshade: (str) shade of grey to use for land
showland: (Boolean) show land (nan) is True
grid: (None or Gr) grid to draw information from.
<a href="#id16"><span class="problematic" id="id17">*</span></a>args,**kwargs: normal kw arguments that can be passed on to contour(f).</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="spacegrids.plotting.plot">
<tt class="descclassname">spacegrids.plotting.</tt><tt class="descname">plot</tt><big>(</big><em>fld0=None</em>, <em>fld1=None</em>, <em>minus_z=True</em>, <em>xlbl=''</em>, <em>ylbl=''</em>, <em>grid=None</em>, <em>start_zero=False</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/spacegrids/plotting.html#plot"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.plotting.plot" title="Permalink to this definition">¶</a></dt>
<dd><p>Function that calls Matplotlib plot, but takes fields as arguments (instead of numpy arrays).</p>
<p>Adds additional plot elements based on iformation from Field.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>fld0: (Field) to be plotted if Field fld1 is None, otherwise x-coord with fld1 as y-coord
minus_z: (Boolean) z-axis points downard if true
xlbl, ylbl: (str) override Field labels if not &#8216;&#8217;
grid: (None or Gr) replaces Field grid if not None
start_zero: (Boolean) if True, x-axis starts at 0  
<a href="#id18"><span class="problematic" id="id19">**</span></a>kwargs: additional args to pass to plot function.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="spacegrids.plotting.quiver">
<tt class="descclassname">spacegrids.plotting.</tt><tt class="descname">quiver</tt><big>(</big><em>vfld</em>, <em>showland=True</em>, <em>xlabel=True</em>, <em>ylabel=True</em>, <em>minus_z=True</em>, <em>xl=None</em>, <em>yl=None</em>, <em>xscale=1.0</em>, <em>yscale=1.0</em>, <em>ax_units=True</em>, <em>ax=None</em>, <em>greyshade='0.65'</em>, <em>kmt=None</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/spacegrids/plotting.html#quiver"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.plotting.quiver" title="Permalink to this definition">¶</a></dt>
<dd><p>Function that calls Matplotlib quiver and passes on arguments, but takes a Field as argument (instead of an ndarray)</p>
<p>Assuming that z vs x and z vs y quiver plots are rare: expects x-y plots.</p>
<dl class="docutils">
<dt>Args: </dt>
<dd>vfld: (VField) to be plotted
showland: (Boolean) show land (nan) is True (not working yet)
xlabel: (Boolean) show x label if True
ylabel: (Boolean) show y label if True  
minus_z: (Boolean) display negative numbers on vertical scale (Z) if True
xl: (None, list/ tuple of length 2) plot limits in the x-direction
yl: (None, list/ tuple of length 2) plot limits in the y-direction
xscale: (float) scale in x direction
yscale: (float) scale in y direction
ax_units: (Boolean) display units on axes if True
ax: (None or figure axis handle) set to plt.gca() if argument is None
greyshade: (str) shade of grey to use for land
<a href="#id20"><span class="problematic" id="id21">**</span></a><a href="#id22"><span class="problematic" id="id23">*</span></a>kwargs: normal kw arguments that can be passed on to quiver.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="spacegrids.plotting.treat_kmt">
<tt class="descclassname">spacegrids.plotting.</tt><tt class="descname">treat_kmt</tt><big>(</big><em>kmt</em><big>)</big><a class="reference internal" href="_modules/spacegrids/plotting.html#treat_kmt"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.plotting.treat_kmt" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a finer (interpolated) version of ndarray argument kmt.</p>
<p>Used in plotting bathymetry.</p>
</dd></dl>

</div>
<div class="section" id="module-spacegrids.projectcls">
<span id="projectcls-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">projectcls</span></tt> Module<a class="headerlink" href="#module-spacegrids.projectcls" title="Permalink to this headline">¶</a></h2>
<p>Projects represent experiment data organized in project directories.</p>
<dl class="docutils">
<dt>Netcdf data must be organised in a projects directory tree. Create a directory named PROJECTS inside your home directory (name default), to contain all the data for all the projects. Then create a subdirectory for each of your projects, say one is called test_project. When using sg.info() and sg.Project with the nonick = True argument (see documentation), this is all that is needed to allow the sg module to recognise these subdirectories as representing projects. </dt>
<dd><p class="first">This will allow the sg Python code to regard all Netcdf files placed directly inside test_project as belonging to individual experiments. Alternatively, instead of a single file, a subdirectory may represent an experiment. So directories inside the test_project directory are associated with output from a single experiment each, where all Netcdf files contained within are interpreted as belonging to that same experiment.</p>
<p>To get started in ipython (bring up with sg.overview() ):</p>
<div class="last highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">spacegrids</span> <span class="kn">as</span> <span class="nn">sg</span>           
<span class="gp">&gt;&gt;&gt; </span><span class="n">D</span> <span class="o">=</span> <span class="n">sg</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">nonick</span> <span class="o">=</span> <span class="bp">True</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">P</span> <span class="o">=</span> <span class="n">sgPproject</span><span class="p">(</span><span class="n">D</span><span class="p">[</span><span class="s">&#39;my_project&#39;</span><span class="p">]</span> <span class="p">,</span> <span class="n">nonick</span> <span class="o">=</span> <span class="bp">True</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">P</span><span class="o">.</span><span class="n">load</span><span class="p">([</span><span class="s">&#39;temperature&#39;</span><span class="p">,</span><span class="s">&#39;u&#39;</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="c"># obtain the axes under their names T, X, Y, Z in namespace:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">P</span><span class="p">[</span><span class="s">&#39;some_experiment&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">axes</span><span class="p">:</span>
<span class="gp">&gt;&gt;&gt; </span>  <span class="k">exec</span> <span class="n">c</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s">&#39; = c&#39;</span>    
</pre></div>
</div>
</dd>
</dl>
<dl class="class">
<dt id="spacegrids.projectcls.Project">
<em class="property">class </em><tt class="descclassname">spacegrids.projectcls.</tt><tt class="descname">Project</tt><big>(</big><em>path='/home/wim', expnames=['*'], varnames=[], msk_grid='', name=None, nonick=False, descr=None, verbose=False</em><big>)</big><a class="reference internal" href="_modules/spacegrids/projectcls.html#Project"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.projectcls.Project" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Represents experiment data organized in project directories.</p>
<p>Data directory tree:</p>
<p>Before using projects, Netcdf data must be organised in a projects directory tree. Create a directory named PROJECTS inside your home directory (name default), to contain all the data for all the projects. Then create a subdirectory for each of your projects, say one is called test_project. When using sg.info() and sg.Project with the nonick = True argument (see documentation), this is all that is needed to allow the sg module to recognise these subdirectories as representing projects. 
This will allow the sg Python code to regard all Netcdf files placed directly inside test_project as belonging to individual experiments. Alternatively, instead of a single file, a subdirectory may represent an experiment. So directories inside the test_project directory are associated with output from a single experiment each, where all Netcdf files contained within are interpreted as belonging to that same experiment.</p>
<p>To get started in ipython (bring up with sg.overview() ):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">spacegrids</span> <span class="kn">as</span> <span class="nn">sg</span>           
<span class="gp">&gt;&gt;&gt; </span><span class="n">D</span> <span class="o">=</span> <span class="n">sg</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">nonick</span> <span class="o">=</span> <span class="bp">True</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">P</span> <span class="o">=</span> <span class="n">sgPproject</span><span class="p">(</span><span class="n">D</span><span class="p">[</span><span class="s">&#39;my_project&#39;</span><span class="p">]</span> <span class="p">,</span> <span class="n">nonick</span> <span class="o">=</span> <span class="bp">True</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">P</span><span class="o">.</span><span class="n">load</span><span class="p">([</span><span class="s">&#39;temperature&#39;</span><span class="p">,</span><span class="s">&#39;u&#39;</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="c"># obtain the axes under their names T, X, Y, Z in namespace:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">P</span><span class="p">[</span><span class="s">&#39;some_experiment&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">axes</span><span class="p">:</span>
<span class="gp">&gt;&gt;&gt; </span>  <span class="k">exec</span> <span class="n">c</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s">&#39; = c&#39;</span>    
</pre></div>
</div>
<dl class="method">
<dt id="spacegrids.projectcls.Project.ad_mask">
<tt class="descname">ad_mask</tt><big>(</big><em>sub_dir='/masks/'</em>, <em>grid=False</em>, <em>msk_val=2</em><big>)</big><a class="reference internal" href="_modules/spacegrids/projectcls.html#Project.ad_mask"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.projectcls.Project.ad_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>Read text file masks from file and add to project.</p>
</dd></dl>

<dl class="method">
<dt id="spacegrids.projectcls.Project.adexp">
<tt class="descname">adexp</tt><big>(</big><em>expnames=['*'], descr='An experiment.'</em><big>)</big><a class="reference internal" href="_modules/spacegrids/projectcls.html#Project.adexp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.projectcls.Project.adexp" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds an experiment to this Project.</p>
<p>Also looks for a sub-directory &#8220;masks&#8221; for masks. If it can&#8217;t find that, it will use the mask inherited from the Project.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>expnames: (str or list of str) of experiment name patterns to match
descr: (str) optional description of experiment</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="spacegrids.projectcls.Project.cat">
<tt class="descname">cat</tt><big>(</big><em>fld_name</em>, <em>new_ax_name='exper'</em>, <em>new_coord_name=None</em>, <em>new_coord=None</em><big>)</big><a class="reference internal" href="_modules/spacegrids/projectcls.html#Project.cat"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.projectcls.Project.cat" title="Permalink to this definition">¶</a></dt>
<dd><p>Concatenate the Field fld_name for all experiments where that Field is loaded.</p>
<p>If new_coord coord object argument is given, other arguments are overridden and that argument is used as the new coord along which the different experiments are lined up.</p>
<p>if no new_coord argument is given, a new Coord will be constructed.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><p class="first">fld_name: (str) name of Field objects to concatenate
new_ax_name: (str) name of new Ax object to create to concat along if desired</p>
<p class="last">new_coord_name: (str) name to be used for creation of new Coord in case ax not in Field grid
new_coord: (Coord) overrides default behaviour if set by concatenating along that new Coord.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="spacegrids.projectcls.Project.delexp">
<tt class="descname">delexp</tt><big>(</big><em>expnames</em>, <em>msg=' '</em><big>)</big><a class="reference internal" href="_modules/spacegrids/projectcls.html#Project.delexp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.projectcls.Project.delexp" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="spacegrids.projectcls.Project.delvar">
<tt class="descname">delvar</tt><big>(</big><em>varname</em><big>)</big><a class="reference internal" href="_modules/spacegrids/projectcls.html#Project.delvar"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.projectcls.Project.delvar" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="spacegrids.projectcls.Project.get">
<tt class="descname">get</tt><big>(</big><em>expnames</em>, <em>varnames</em><big>)</big><a class="reference internal" href="_modules/spacegrids/projectcls.html#Project.get"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.projectcls.Project.get" title="Permalink to this definition">¶</a></dt>
<dd><p>Fetch fields from a Project.</p>
<p>expnames will be matched against the available project experiment names using fnmatch, allowing patterns such as wild cards. The same with varnames.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>expnames: (str or list of str) containing experiment name patterns to load from. 
varnames: (list of str) of variable name patterns to match against</dd>
<dt>Returns:</dt>
<dd>List of Field objects from Project with matching attributes.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="spacegrids.projectcls.Project.incdf">
<tt class="descname">incdf</tt><big>(</big><em>varname</em>, <em>expname=''</em><big>)</big><a class="reference internal" href="_modules/spacegrids/projectcls.html#Project.incdf"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.projectcls.Project.incdf" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether variable name is in the Netcdf files.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>varname: (str) variable name to check</dd>
<dt>Returns:</dt>
<dd>True/ False depending on whether the variable name is in the netcdf database.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="spacegrids.projectcls.Project.insert">
<tt class="descname">insert</tt><big>(</big><em>func</em><big>)</big><a class="reference internal" href="_modules/spacegrids/projectcls.html#Project.insert"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.projectcls.Project.insert" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply function func to each Exper object in self and insert the result into Project.</p>
<p>The result of func must be a tuple (name, value) or a list of such tuples (as taken by the Exper insert method). Conform the Exper insert method, name must be a string, and value a Field or ordinary float/ int kind of datatype.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>func: (function) taking Exper argument and returning list of (name,value) pairs.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="spacegrids.projectcls.Project.load">
<tt class="descname">load</tt><big>(</big><em>varnames</em>, <em>descr=0</em>, <em>chk_loaded=False</em>, <em>ax=None</em>, <em>name_suffix='_cat'</em>, <em>new_coord_name='gamma'</em>, <em>new_coord=None</em>, <em>slices=None</em><big>)</big><a class="reference internal" href="_modules/spacegrids/projectcls.html#Project.load"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.projectcls.Project.load" title="Permalink to this definition">¶</a></dt>
<dd><p>Load Field into Project from Netcdf files.</p>
<p>Loads a variable (or list of variables) for all experiments belonging to the Project instance. E.g. P.load(&#8216;salinity&#8217;).</p>
<p>Attempts to concatenate if the same variable name is found in multiple files.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>varnames: (str or list of str) of variable names to load
descr: (str) optional description     
chk_loaded: (Boolean)  if True (default False), makes load method check whether the Field is already loaded. If so, it is not loaded.
ax (Ax): passed on to the concatenate function from Exper.load
name_suffix: (str) suffix to apply to name
new_coord_name (str): passed on to the concatenate function
new_coord (Coord): passed on to the concatenate function</dd>
</dl>
<p>Examples:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">P</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s">&#39;salinity&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">E</span> <span class="o">=</span> <span class="n">P</span><span class="p">[</span><span class="s">&#39;CNTRL_2200p&#39;</span><span class="p">]</span>    <span class="c"># pick this particular experiment</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S</span> <span class="o">=</span> <span class="n">E</span><span class="p">[</span><span class="s">&#39;salinity&#39;</span><span class="p">]</span>               <span class="c"># create Field object and assign it to S</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="spacegrids.projectcls.Project.loaded">
<tt class="descname">loaded</tt><big>(</big><em>varname</em><big>)</big><a class="reference internal" href="_modules/spacegrids/projectcls.html#Project.loaded"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.projectcls.Project.loaded" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks whether variable by name of (str) varname is loaded.</p>
</dd></dl>

<dl class="method">
<dt id="spacegrids.projectcls.Project.ls">
<tt class="descname">ls</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/spacegrids/projectcls.html#Project.ls"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.projectcls.Project.ls" title="Permalink to this definition">¶</a></dt>
<dd><p>Display experiments belonging to Project in columns.</p>
</dd></dl>

<dl class="method">
<dt id="spacegrids.projectcls.Project.param2gr">
<tt class="descname">param2gr</tt><big>(</big><em>param_name</em>, <em>func</em>, <em>name_filter=None</em>, <em>sort=True</em>, <em>new_Ax_name=None</em>, <em>add2cstack=True</em><big>)</big><a class="reference internal" href="_modules/spacegrids/projectcls.html#Project.param2gr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.projectcls.Project.param2gr" title="Permalink to this definition">¶</a></dt>
<dd><p>Use a param from the experiments to construct a Coord, and so construct a new concatenated Field defined on a new grid with this new Coord.</p>
<p>func is a function that must yield a Field and take an Exper object as argument.
it should return None for elements that are not desired. This method is somewhat different from its near-opposite method insert, where the function argument is allowed to yield fields or single values (float/ int).</p>
<p>The idea is: a parameter belongs to an Exper, so any function taking an Exper argument and returning a Field of certain dimensions allows us to concatenate these Field objects along a new Coord constructed from the parameters.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>param_name: (str) parameter name
func: (function) that must yield a Field and take Exper object as argument
name_filter: (str) pattern to filter only certain Exper names.
sort: (Boolean) if True, sorts the Coord
new_Ax_name: (str) name for new Ax object corresponding to new param-based Coord, can be None (it will then be constructed)
add2cstack: (Boolean) determines whether new Coord will be added to the Exper coordinate stacks.</dd>
<dt>Returns:</dt>
<dd>The concatenated Field.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="spacegrids.projectcls.Project.pattern2gr">
<tt class="descname">pattern2gr</tt><big>(</big><em>fld_name</em>, <em>pattern</em>, <em>parname=None</em>, <em>name_filter=None</em>, <em>nomatch_fill=None</em><big>)</big><a class="reference internal" href="_modules/spacegrids/projectcls.html#Project.pattern2gr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.projectcls.Project.pattern2gr" title="Permalink to this definition">¶</a></dt>
<dd><p>Use rexexp patterns on experiment file names to extract parameters and apply param2gr.</p>
<p>The first grouping in the regexp will be used to yield the parameter.</p>
<dl class="docutils">
<dt>Args: (as in param2gr, except one)</dt>
<dd>pattern: (str) regular expression to apply to file names.</dd>
<dt>Returns:</dt>
<dd>The concatenated Field.</dd>
</dl>
<p>Examples:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">regexp</span> <span class="o">=</span> <span class="s">&#39;[\w_]+_(\d+)ppm[\w]+&#39;</span> <span class="c"># the grouping between brackets yields the value</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bigfield_DP</span><span class="o">=</span><span class="n">P</span><span class="o">.</span><span class="n">pattern2gr</span><span class="p">(</span><span class="n">fld_name</span> <span class="o">=</span> <span class="s">&#39;temp&#39;</span><span class="p">,</span><span class="n">pattern</span> <span class="o">=</span> <span class="n">regexp</span><span class="p">,</span><span class="n">parname</span><span class="o">=</span><span class="s">&#39;co2&#39;</span><span class="p">,</span> <span class="n">name_filter</span> <span class="o">=</span> <span class="s">&#39;DP*&#39;</span><span class="p">,</span> <span class="n">nomatch_fill</span> <span class="o">=</span> <span class="mf">280.</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># this is for filenames with co2 values in their file name.</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="spacegrids.projectcls.Project.show">
<tt class="descname">show</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/spacegrids/projectcls.html#Project.show"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.projectcls.Project.show" title="Permalink to this definition">¶</a></dt>
<dd><p>Display summary of experiments and fields loaded in Project.</p>
</dd></dl>

<dl class="method">
<dt id="spacegrids.projectcls.Project.write">
<tt class="descname">write</tt><big>(</big><em>path=None</em>, <em>name=None</em>, <em>force=False</em>, <em>history='Created from Spacegrids '</em>, <em>insert_dual=True</em><big>)</big><a class="reference internal" href="_modules/spacegrids/projectcls.html#Project.write"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.projectcls.Project.write" title="Permalink to this definition">¶</a></dt>
<dd><p>Write entire loaded Project to disk.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="spacegrids.projectcls.avg_temp">
<tt class="descclassname">spacegrids.projectcls.</tt><tt class="descname">avg_temp</tt><big>(</big><em>P</em>, <em>varname='O_temp'</em><big>)</big><a class="reference internal" href="_modules/spacegrids/projectcls.html#avg_temp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.projectcls.avg_temp" title="Permalink to this definition">¶</a></dt>
<dd><p>Example function to create avg ocean temperature from expers</p>
</dd></dl>

<dl class="function">
<dt id="spacegrids.projectcls.info">
<tt class="descclassname">spacegrids.projectcls.</tt><tt class="descname">info</tt><big>(</big><em>rootdir='/home/wim'</em>, <em>projdirname='PROJECTS'</em>, <em>fname='projname'</em>, <em>nonick=False</em>, <em>verbose=True</em><big>)</big><a class="reference internal" href="_modules/spacegrids/projectcls.html#info"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.projectcls.info" title="Permalink to this definition">¶</a></dt>
<dd><p>Simple function to take inventory of all Project directories based on contents of projname text files inside project directories.</p>
<p>This way, no specific paths need to be used, and projects can be referred to by their nicknames defined in a file called projname in each directory containing the experiment directories.</p>
<dl class="docutils">
<dt>Args: </dt>
<dd>rootdir: (str) dir in which to look for main PROJECTS dir
projdirname: (str) dir in which to look for specific Project directories. Default is &#8216;PROJECTS&#8217;. So by default, projects are expected in &#8216;~/PROJECTS/&#8217;).
fname: (str) the filename to look for and read the content of to determine nickname of specific Project. Disabled with nonick = True</dd>
<dt>Returns:</dt>
<dd>D, dictionary of Project nicknames vs full paths</dd>
</dl>
<p>If nonick is False:  finds all dir paths with file called fname in them, reads that file for each dir to find the nickname of that Project and builds a dictionary of nicknames vs paths. Otherwise, just takes inventory of all sub directories of projects (~/PROJECTS)</p>
<p>Example of use when projects are in default location ~/PROJECTS/ (spacegrids loaded as sg):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">D</span><span class="o">=</span><span class="n">sg</span><span class="o">.</span><span class="n">info</span><span class="p">()</span>
</pre></div>
</div>
<p>Say this gives keys &#8216;test&#8217; and &#8216;TKE&#8217;. To open the Project with nickname test:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">P</span> <span class="o">=</span> <span class="n">sg</span><span class="o">.</span><span class="n">Project</span><span class="p">(</span><span class="n">D</span><span class="p">[</span><span class="s">&#39;test&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>and start working with P. No specific path had to be identified, only a sufficiently specific top.</p>
</dd></dl>

<dl class="function">
<dt id="spacegrids.projectcls.info_dict">
<tt class="descclassname">spacegrids.projectcls.</tt><tt class="descname">info_dict</tt><big>(</big><em>rootdir='/home/wim'</em>, <em>projdirname='PROJECTS'</em>, <em>fname='projname'</em>, <em>nonick=False</em><big>)</big><a class="reference internal" href="_modules/spacegrids/projectcls.html#info_dict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.projectcls.info_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>See info method.</p>
</dd></dl>

<dl class="function">
<dt id="spacegrids.projectcls.ls">
<tt class="descclassname">spacegrids.projectcls.</tt><tt class="descname">ls</tt><big>(</big><em>rootdir='/home/wim'</em>, <em>projdirname='PROJECTS'</em>, <em>fname='projname'</em>, <em>nonick=False</em><big>)</big><a class="reference internal" href="_modules/spacegrids/projectcls.html#ls"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.projectcls.ls" title="Permalink to this definition">¶</a></dt>
<dd><p>Simple function to display all Project directories vs their projname nicknames.</p>
<p>See info method for details.</p>
<p>Calls info_dict.</p>
</dd></dl>

<dl class="function">
<dt id="spacegrids.projectcls.overview">
<tt class="descclassname">spacegrids.projectcls.</tt><tt class="descname">overview</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/spacegrids/projectcls.html#overview"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.projectcls.overview" title="Permalink to this definition">¶</a></dt>
<dd><p>Prints quick overview of sg to screen.</p>
</dd></dl>

<dl class="function">
<dt id="spacegrids.projectcls.parse_fname_func">
<tt class="descclassname">spacegrids.projectcls.</tt><tt class="descname">parse_fname_func</tt><big>(</big><em>pattern</em>, <em>parname=None</em>, <em>value_type=&lt;type 'float'&gt;</em>, <em>nomatch_fill=None</em><big>)</big><a class="reference internal" href="_modules/spacegrids/projectcls.html#parse_fname_func"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.projectcls.parse_fname_func" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="spacegrids.projectcls.project">
<em class="property">class </em><tt class="descclassname">spacegrids.projectcls.</tt><tt class="descname">project</tt><big>(</big><em>path='/home/wim', expnames=['*'], varnames=[], msk_grid='UVic2.8_t', name=None, nonick=False, descr=None, verbose=False</em><big>)</big><a class="reference internal" href="_modules/spacegrids/projectcls.html#project"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.projectcls.project" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Legacy class to generate error when initialized by depricated code.</p>
</dd></dl>

<dl class="function">
<dt id="spacegrids.projectcls.read_control_func">
<tt class="descclassname">spacegrids.projectcls.</tt><tt class="descname">read_control_func</tt><big>(</big><em>filename</em><big>)</big><a class="reference internal" href="_modules/spacegrids/projectcls.html#read_control_func"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.projectcls.read_control_func" title="Permalink to this definition">¶</a></dt>
<dd><p>function that yields a useful function that can be used in the Project insert method: it reads a control file in the MOM 2 control file format (as used by UVic) and outputs it in the list of (name, value) tuples format required by the Exper insert method. Think of it as inserting a parameter to each Exper, although it can be a Field too.</p>
<p>The argument filename is the file name of the control file to be read, usually control.in.</p>
<p>For example: P.insert(sg.read_control_func(&#8216;control.in&#8217;)) goes through all experiment directories and looks for, and parses, the file control.in, and then inserts the result as Exper parameters.</p>
<p>The user could construct similar functions for their own use: the function must take an experiment as argument, and return None or a list of (name, value) pairs (2 tuples).</p>
</dd></dl>

<dl class="function">
<dt id="spacegrids.projectcls.read_projnick">
<tt class="descclassname">spacegrids.projectcls.</tt><tt class="descname">read_projnick</tt><big>(</big><em>f</em><big>)</big><a class="reference internal" href="_modules/spacegrids/projectcls.html#read_projnick"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.projectcls.read_projnick" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads project nickname file (usually &#8220;projname&#8221;) in project directory.</p>
</dd></dl>

</div>
<div class="section" id="module-spacegrids.utilsg">
<span id="utilsg-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">utilsg</span></tt> Module<a class="headerlink" href="#module-spacegrids.utilsg" title="Permalink to this headline">¶</a></h2>
<p>Useful general functions and utilities.</p>
<dl class="class">
<dt id="spacegrids.utilsg.Report">
<em class="property">class </em><tt class="descclassname">spacegrids.utilsg.</tt><tt class="descname">Report</tt><big>(</big><em>value=''</em><big>)</big><a class="reference internal" href="_modules/spacegrids/utilsg.html#Report"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.utilsg.Report" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Reporting class containing useful method for building a string containing messages.</p>
<p>Attributes</p>
<blockquote>
<div>value : <cite>str</cite> The reporting string being built</div></blockquote>
<p>Examples:</p>
</div></blockquote>
<dl class="method">
<dt id="spacegrids.utilsg.Report.block">
<tt class="descname">block</tt><big>(</big><em>L</em>, <em>delim='\ '</em>, <em>width=12</em>, <em>cols=4</em><big>)</big><a class="reference internal" href="_modules/spacegrids/utilsg.html#Report.block"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.utilsg.Report.block" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates string to display list of strings as a deliminated rows x cols block.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>L: list of strings
delim: delimiter character passed to block method
width: width in characters of each cell (int)
cols: number of columns of block (int)</dd>
<dt>Returns:</dt>
<dd>None</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="spacegrids.utilsg.Report.echo">
<tt class="descname">echo</tt><big>(</big><em>what=''</em>, <em>delim=' '</em>, <em>maxlen=10</em>, <em>width=12</em>, <em>cols=4</em><big>)</big><a class="reference internal" href="_modules/spacegrids/utilsg.html#Report.echo"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.utilsg.Report.echo" title="Permalink to this definition">¶</a></dt>
<dd><p>Insert a string into Report value.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>what: string to insert (default &#8216;&#8217;) or list/ tuple of strings
delim: delimiter character passed to block method
maxlen: max length (int) passed to block method
width: int passed to block method
cols: int passed to block method</dd>
<dt>Returns:</dt>
<dd>None</dd>
</dl>
<p>If &#8216;what&#8217; is a list of strings, the block method will be used to embed a table of the strings into the Report value.</p>
<p><strong>See Also</strong>
echoln method</p>
</dd></dl>

<dl class="method">
<dt id="spacegrids.utilsg.Report.echoln">
<tt class="descname">echoln</tt><big>(</big><em>what=''</em>, <em>delim=' '</em>, <em>maxlen=10</em>, <em>width=12</em>, <em>cols=4</em><big>)</big><a class="reference internal" href="_modules/spacegrids/utilsg.html#Report.echoln"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.utilsg.Report.echoln" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Insert a string on a new line into Report value.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>what: string to insert (default &#8216;&#8217;) or list/ tuple of strings
delim: delimiter character passed to block method
maxlen: max length (int) passed to block method
width: int passed to block method
cols: int passed to block method</dd>
<dt>Returns:</dt>
<dd>A Report object with updated value attribute.</dd>
</dl>
<p>This is the echo method with a &#8216;</p>
</div></blockquote>
<p>&#8216; appended.</p>
<blockquote>
<div><strong>See Also</strong>
echo method</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="spacegrids.utilsg.Report.line">
<tt class="descname">line</tt><big>(</big><em>char='-'</em>, <em>times=10</em><big>)</big><a class="reference internal" href="_modules/spacegrids/utilsg.html#Report.line"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.utilsg.Report.line" title="Permalink to this definition">¶</a></dt>
<dd><p>Insert a line of &#8212; characters on a new line into Report value.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>char: string containing character used for line (default &#8216;-&#8216;)
times: the number of times char is repeated</dd>
<dt>Returns:</dt>
<dd>None.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="spacegrids.utilsg.Report.table">
<tt class="descname">table</tt><big>(</big><em>D</em>, <em>cols=4</em><big>)</big><a class="reference internal" href="_modules/spacegrids/utilsg.html#Report.table"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.utilsg.Report.table" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a table based on dictionary D.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>D: dictionary of name:value pairs to be included in table
cols: number of columns of table (int)</dd>
<dt>Returns:</dt>
<dd>None</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="spacegrids.utilsg.add_alias">
<tt class="descclassname">spacegrids.utilsg.</tt><tt class="descname">add_alias</tt><big>(</big><em>L</em><big>)</big><a class="reference internal" href="_modules/spacegrids/utilsg.html#add_alias"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.utilsg.add_alias" title="Permalink to this definition">¶</a></dt>
<dd><p>Create alias attribute based on name attribute, and identify objects that have identical name attributes to yield corresponding numbered alias attributes to tell them apart.</p>
<blockquote>
<div><dl class="docutils">
<dt>Args:</dt>
<dd>L: list of Coord objects (or any objects with a name attribute).</dd>
<dt>Returns: </dt>
<dd>A list &#8211; the list L with alias attributes added</dd>
</dl>
<p>Takes list L of objects with name attribute. Assigns alias attribute.
Some of these names might be the same. To yield unique identifiers, a unique
alias attribute can be assigned to the objects, to be used in practice instead
of the names (as the names might need to correspond to the netcdf names). E.g. (&#8216;latitude&#8217;,&#8217;latitude&#8217;,&#8217;latitude&#8217;,&#8217;longitude&#8217;,&#8217;depth&#8217;) yields aliases: (&#8216;latitude&#8217;,&#8217;latitude2&#8217;,&#8217;latitude3&#8217;,&#8217;longitude&#8217;,&#8217;depth&#8217;)</p>
<p>This is useful when Coord names are used interactively in the namespace of
e.g. ipython, and allows the user to tell the Coord objects that have the 
same name apart.  Coord and Gr __repr__ methods will display alias attribute 
instead of name if the alias attribute is available.</p>
<p>Examples:</p>
<p>For example, we could apply add_alias to a list of 4 test Coord objects, two of which have the same name.</p>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="spacegrids.utilsg.affix">
<tt class="descclassname">spacegrids.utilsg.</tt><tt class="descname">affix</tt><big>(</big><em>coord_name</em>, <em>affix=''</em>, <em>kind='suffix'</em><big>)</big><a class="reference internal" href="_modules/spacegrids/utilsg.html#affix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.utilsg.affix" title="Permalink to this definition">¶</a></dt>
<dd><p>Append affix to string, ignore when affix already present.</p>
<p>Can replace this with a nillpotent decorator.</p>
</dd></dl>

<dl class="function">
<dt id="spacegrids.utilsg.end_of_filepath">
<tt class="descclassname">spacegrids.utilsg.</tt><tt class="descname">end_of_filepath</tt><big>(</big><em>path</em><big>)</big><a class="reference internal" href="_modules/spacegrids/utilsg.html#end_of_filepath"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.utilsg.end_of_filepath" title="Permalink to this definition">¶</a></dt>
<dd><p>Little function that finds the last element of a path, without using os module.
e.g. /foo/bar yields bar, as does /foo/bar/</p>
</dd></dl>

<dl class="function">
<dt id="spacegrids.utilsg.find_perm">
<tt class="descclassname">spacegrids.utilsg.</tt><tt class="descname">find_perm</tt><big>(</big><em>left</em>, <em>right</em>, <em>verbose=True</em><big>)</big><a class="reference internal" href="_modules/spacegrids/utilsg.html#find_perm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.utilsg.find_perm" title="Permalink to this definition">¶</a></dt>
<dd><p>Find a permutation to obtain tuple (iterable) argument &#8220;right&#8221; from &#8220;left&#8221;.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>left: a tuple (or list)
right: a tuple (or list)</dd>
<dt>Returns: </dt>
<dd>None or perm, a permutation such that [left[i] for i in perm] = right</dd>
</dl>
<p>If left and right are of equal length and contain the same elements up to their order, a permutation will be returned.</p>
</dd></dl>

<dl class="function">
<dt id="spacegrids.utilsg.floodfill">
<tt class="descclassname">spacegrids.utilsg.</tt><tt class="descname">floodfill</tt><big>(</big><em>A</em>, <em>node=(0</em>, <em>0)</em>, <em>boundary_value=nan</em>, <em>xmin=0</em>, <em>xmax=10000</em>, <em>ymin=0</em>, <em>ymax=10000</em>, <em>x_cyclic=False</em>, <em>y_cyclic=False</em>, <em>mask_val=2</em><big>)</big><a class="reference internal" href="_modules/spacegrids/utilsg.html#floodfill"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.utilsg.floodfill" title="Permalink to this definition">¶</a></dt>
<dd><p>Fill array (e.g. ocean) from node up to boundary defined by boundary_value (e.g. land) using floodfill.</p>
<p>Creates mask to fill array (e.g. ocean) in area contained within boundary_value (e.g. land), containing node.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>A: (ndarray) 2 dimensional array to use fill on
node: (2 tuple of int) coordinates of starting point: (y,x) values.
boundary_value: (float or nan) value of the boundary of the filled domain
xmin: (int) set mask to boundary value up to this x-index
xmax: (int) set mask to boundary value from this x-index
ymin: (int) set mask to boundary value up to this y-index
ymax: (int) set mask to boundary value from this y-index
x_cyclic: (Boolean) indicates whether x-domain cyclic if True
y_cyclic: (Boolean) indicates whether y-domain cyclic if True
mask_val: (int) value of the masked out region: nodes outside fill in mask</dd>
<dt>Returns:</dt>
<dd>2 dimension ndarray int mask of filled values</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="spacegrids.utilsg.fromcsv">
<tt class="descclassname">spacegrids.utilsg.</tt><tt class="descname">fromcsv</tt><big>(</big><em>raw_string</em>, <em>row_header=0</em>, <em>col_dates=0</em>, <em>data_start_row=1</em>, <em>data_start_col=1</em>, <em>hor_desc_col=None</em>, <em>separator='</em>, <em>'</em>, <em>row_delin='\n'</em>, <em>nanval=-999999</em><big>)</big><a class="reference internal" href="_modules/spacegrids/utilsg.html#fromcsv"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.utilsg.fromcsv" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert csv string to list of lists of floats T, list of header strings H and (optional) list pf dates D.</p>
</dd></dl>

<dl class="function">
<dt id="spacegrids.utilsg.get_att">
<tt class="descclassname">spacegrids.utilsg.</tt><tt class="descname">get_att</tt><big>(</big><em>obj</em>, <em>att_list</em>, <em>fail_val=None</em><big>)</big><a class="reference internal" href="_modules/spacegrids/utilsg.html#get_att"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.utilsg.get_att" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns attribute value corresponding to first element of a list of name strings that matches any attribute name of object, None otherwise.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>obj: an object of which to examine the attributes
att_list: an iterable containing strings
fail_val: value to return if att_list elements not in object attribute names</dd>
<dt>Returns: </dt>
<dd>attribute value that gives firs match in list, fail_val otherwise</dd>
</dl>
<p><strong>See also</strong>
_which_att</p>
</dd></dl>

<dl class="function">
<dt id="spacegrids.utilsg.id_in">
<tt class="descclassname">spacegrids.utilsg.</tt><tt class="descname">id_in</tt><big>(</big><em>L</em>, <em>e</em><big>)</big><a class="reference internal" href="_modules/spacegrids/utilsg.html#id_in"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.utilsg.id_in" title="Permalink to this definition">¶</a></dt>
<dd><p>Same as in function for lists, but with equality defined as &amp;.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>L: list of objects that implement &amp;-equality
e: an object of that same type.</dd>
<dt>Returns: </dt>
<dd>True or False depending on whether there is an element e2 of L such that e&amp;e2 is True</dd>
</dl>
<p>Used on Ax objects in code.</p>
<p><strong>See also</strong>
id_index
rem_equivs
List method &#8216;index&#8217;</p>
</dd></dl>

<dl class="function">
<dt id="spacegrids.utilsg.id_index">
<tt class="descclassname">spacegrids.utilsg.</tt><tt class="descname">id_index</tt><big>(</big><em>L</em>, <em>e</em><big>)</big><a class="reference internal" href="_modules/spacegrids/utilsg.html#id_index"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.utilsg.id_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Same as index method of lists, but with equality defined as &amp;.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>L: list of objects that implement &amp;-equality
e: an object of that same type.</dd>
<dt>Returns: </dt>
<dd>None or integer representing the index of e in L.</dd>
</dl>
<p>Used on both Ax and Coord objects in code. In Coord case, the &amp; method is identical to the weaksame method.</p>
<p><strong>See also</strong>
id_in
rem_equivs
__and__ methods of Ax and Coord class
List method &#8216;index&#8217;</p>
</dd></dl>

<dl class="function">
<dt id="spacegrids.utilsg.merge">
<tt class="descclassname">spacegrids.utilsg.</tt><tt class="descname">merge</tt><big>(</big><em>A1</em>, <em>A2</em>, <em>sort=True</em><big>)</big><a class="reference internal" href="_modules/spacegrids/utilsg.html#merge"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.utilsg.merge" title="Permalink to this definition">¶</a></dt>
<dd><p>_merge two ndarrays or iterables and order them.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>A1: first ndarray
A2: second ndarray to be combined with first array
sort: flag. sort called on result if True.</dd>
<dt>Returns:</dt>
<dd>new_list: sorted list of combined values.</dd>
</dl>
<p>Used to _merge Coord values.</p>
</dd></dl>

<dl class="function">
<dt id="spacegrids.utilsg.move_east_maker">
<tt class="descclassname">spacegrids.utilsg.</tt><tt class="descname">move_east_maker</tt><big>(</big><em>cyclic=False</em>, <em>m=10000</em><big>)</big><a class="reference internal" href="_modules/spacegrids/utilsg.html#move_east_maker"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.utilsg.move_east_maker" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="spacegrids.utilsg.move_north_maker">
<tt class="descclassname">spacegrids.utilsg.</tt><tt class="descname">move_north_maker</tt><big>(</big><em>cyclic=False</em>, <em>m=10000</em><big>)</big><a class="reference internal" href="_modules/spacegrids/utilsg.html#move_north_maker"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.utilsg.move_north_maker" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="spacegrids.utilsg.move_south">
<tt class="descclassname">spacegrids.utilsg.</tt><tt class="descname">move_south</tt><big>(</big><em>node</em><big>)</big><a class="reference internal" href="_modules/spacegrids/utilsg.html#move_south"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.utilsg.move_south" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="spacegrids.utilsg.move_west">
<tt class="descclassname">spacegrids.utilsg.</tt><tt class="descname">move_west</tt><big>(</big><em>node</em><big>)</big><a class="reference internal" href="_modules/spacegrids/utilsg.html#move_west"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.utilsg.move_west" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="spacegrids.utilsg.order_mag">
<tt class="descclassname">spacegrids.utilsg.</tt><tt class="descname">order_mag</tt><big>(</big><em>val</em><big>)</big><a class="reference internal" href="_modules/spacegrids/utilsg.html#order_mag"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.utilsg.order_mag" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Find order of magnitude of value.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>val: float</dd>
<dt>Returns: </dt>
<dd>order of magnitude of val</dd>
</dl>
<p>Examples:</p>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="spacegrids.utilsg.parse_control_file">
<tt class="descclassname">spacegrids.utilsg.</tt><tt class="descname">parse_control_file</tt><big>(</big><em>fname, rem_chars=['\n', '/']</em><big>)</big><a class="reference internal" href="_modules/spacegrids/utilsg.html#parse_control_file"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.utilsg.parse_control_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Read and parse a UVic/ MOM2 - style control file to yield list(s) of (name, value) pairs.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>fname: (str) full path to configuration file     
rem_chars: (list of str) characters to ignore in file (defaults recommended)</dd>
<dt>Returns: </dt>
<dd>La, L. Here, La is list of (name, value) pairs of all parameters found in the control file, excluding names of parameter groups (generally preceded with &amp; in file). If the same parameter name occurs more than once in the file, it is overwritten in the list (unique names are expected). L is a more detailed list. List of (parameter group name, list of (name, value) ) pairs, where the lists of (name, value) pairs belong to each parameter group name.</dd>
</dl>
<p>Data is organized in named blocks. The names of these blocks are included in the second return value L, but not L_all. L_all contains the raw (name, value) pairs</p>
</dd></dl>

<dl class="function">
<dt id="spacegrids.utilsg.plural">
<tt class="descclassname">spacegrids.utilsg.</tt><tt class="descname">plural</tt><big>(</big><em>n</em><big>)</big><a class="reference internal" href="_modules/spacegrids/utilsg.html#plural"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.utilsg.plural" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine whether to use plural of a word describing a qty n of something.</p>
<blockquote>
<div>Used in stdout messages that mention quantities of something.</div></blockquote>
<dl class="docutils">
<dt>Args:</dt>
<dd>n: int or float, the quantity of the thing that is reported on.</dd>
<dt>Returns:</dt>
<dd>A string that is &#8216;&#8217; or &#8216;s&#8217;, indicating a grammatical plural or singular.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="spacegrids.utilsg.read">
<tt class="descclassname">spacegrids.utilsg.</tt><tt class="descname">read</tt><big>(</big><em>fname</em><big>)</big><a class="reference internal" href="_modules/spacegrids/utilsg.html#read"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.utilsg.read" title="Permalink to this definition">¶</a></dt>
<dd><p>Open fname (full path) for simple reading and return data.</p>
</dd></dl>

<dl class="function">
<dt id="spacegrids.utilsg.rem_equivs">
<tt class="descclassname">spacegrids.utilsg.</tt><tt class="descname">rem_equivs</tt><big>(</big><em>L</em><big>)</big><a class="reference internal" href="_modules/spacegrids/utilsg.html#rem_equivs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.utilsg.rem_equivs" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes all all elements from list that are equivalent under &amp;-relationship</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>L: list of objects that implement &amp;-relationship</dd>
<dt>Returns: </dt>
<dd>A list of elements that are unique with respect to the &amp;-relationship</dd>
</dl>
<p>Uses function id_in.</p>
<p><strong>see also</strong>
id_in
id_index</p>
</dd></dl>

<dl class="function">
<dt id="spacegrids.utilsg.round_order">
<tt class="descclassname">spacegrids.utilsg.</tt><tt class="descname">round_order</tt><big>(</big><em>value</em>, <em>order=None</em><big>)</big><a class="reference internal" href="_modules/spacegrids/utilsg.html#round_order"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.utilsg.round_order" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Round value up to order of magnitude order.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>value: float
order:  (int) the order to which to round value (e.g. order=2 is 100)</dd>
<dt>Returns: </dt>
<dd>value rounded to the order &#8216;order&#8217;</dd>
</dl>
<p>Examples:</p>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="spacegrids.utilsg.simple_glob">
<tt class="descclassname">spacegrids.utilsg.</tt><tt class="descname">simple_glob</tt><big>(</big><em>L</em>, <em>name_filter</em><big>)</big><a class="reference internal" href="_modules/spacegrids/utilsg.html#simple_glob"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.utilsg.simple_glob" title="Permalink to this definition">¶</a></dt>
<dd><p>Very simple wildcard expansion on list of strings.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>L: list of strings       
name_filter: the wildcard glob pattern (e.g. &#8216;<a href="#id24"><span class="problematic" id="id25">*</span></a>hello&#8217;)</dd>
<dt>Returns: </dt>
<dd>A list of strings that match.</dd>
</dl>
<p>Applies very simple shell wildcard * expansion-type matching of argument name_filter on a list of strings, argument L, without using re module.
* can only appear at beginning or end of name_filter (e.g. &#8216;*foo*&#8217;).</p>
<p>E.g. name_filter = &#8216;*oo&#8217; and L=[&#8216;foo&#8217;,&#8217;bar&#8217;] yields [&#8216;foo&#8217;]</p>
</dd></dl>

<dl class="function">
<dt id="spacegrids.utilsg.sublist">
<tt class="descclassname">spacegrids.utilsg.</tt><tt class="descname">sublist</tt><big>(</big><em>L</em>, <em>pick_vals</em><big>)</big><a class="reference internal" href="_modules/spacegrids/utilsg.html#sublist"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.utilsg.sublist" title="Permalink to this definition">¶</a></dt>
<dd><p>Picks a sublist from a list L of strings (e.g. names) using the filematch function.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>L: list of strings from which to pick
pick_vals: pattern or list of patterns used in fnmatch.fnmatch</dd>
<dt>Returns:</dt>
<dd>sL: a list of matching values</dd>
</dl>
<p>For instance, a wildcard will pick all elements.</p>
</dd></dl>

<dl class="function">
<dt id="spacegrids.utilsg.tocsv">
<tt class="descclassname">spacegrids.utilsg.</tt><tt class="descname">tocsv</tt><big>(</big><em>T</em>, <em>H=None</em>, <em>D=None</em>, <em>separator='</em>, <em>'</em><big>)</big><a class="reference internal" href="_modules/spacegrids/utilsg.html#tocsv"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.utilsg.tocsv" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts lists to csv string.
T list of row lists containing cols of floats.
optional:
H list of head strings
D list of dates. Must be of length len(T)</p>
</dd></dl>

<dl class="function">
<dt id="spacegrids.utilsg.tohtml">
<tt class="descclassname">spacegrids.utilsg.</tt><tt class="descname">tohtml</tt><big>(</big><em>T</em>, <em>H=None</em>, <em>D=None</em>, <em>topleft=''</em>, <em>table_tag='table'</em>, <em>format='%.3f'</em><big>)</big><a class="reference internal" href="_modules/spacegrids/utilsg.html#tohtml"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#spacegrids.utilsg.tohtml" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts lists containing data, headers and dates to a HTML table.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>T: data
H: header
D: dates
topleft: string to fill topleft cell of table (e.g. a name)
table_tag: HTML tag to indicate table
format: string indicating the text formatting (see default).</dd>
<dt>Returns: </dt>
<dd>A string containing the HTML table only.</dd>
</dl>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">spacegrids Package</a><ul>
<li><a class="reference internal" href="#id1"><tt class="docutils literal"><span class="pre">spacegrids</span></tt> Package</a></li>
<li><a class="reference internal" href="#module-spacegrids.abstract"><tt class="docutils literal"><span class="pre">abstract</span></tt> Module</a><ul>
<li><a class="reference internal" href="#named">Named</a></li>
<li><a class="reference internal" href="#associative">Associative</a></li>
<li><a class="reference internal" href="#directional">Directional</a></li>
<li><a class="reference internal" href="#membered">Membered</a></li>
<li><a class="reference internal" href="#valued">Valued</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-spacegrids.expercls"><tt class="docutils literal"><span class="pre">expercls</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-spacegrids.fieldcls"><tt class="docutils literal"><span class="pre">fieldcls</span></tt> Module</a><ul>
<li><a class="reference internal" href="#coord">Coord</a></li>
<li><a class="reference internal" href="#gr">Gr</a></li>
<li><a class="reference internal" href="#ax">Ax</a></li>
<li><a class="reference internal" href="#axgr">AxGr</a></li>
<li><a class="reference internal" href="#field">Field</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-spacegrids.ops"><tt class="docutils literal"><span class="pre">ops</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-spacegrids.plotting"><tt class="docutils literal"><span class="pre">plotting</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-spacegrids.projectcls"><tt class="docutils literal"><span class="pre">projectcls</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-spacegrids.utilsg"><tt class="docutils literal"><span class="pre">utilsg</span></tt> Module</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="index.html"
                        title="previous chapter">Spacegrids data analysis documentation</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/spacegrids.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="index.html" title="Spacegrids data analysis documentation"
             >previous</a> |</li>
        <li><a href="index.html">spacegrids  documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2014, Willem Sijp.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
  </body>
</html>